var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all3) => {
  for (var name in all3)
    __defProp(target, name, { get: all3[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
)), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);

// node_modules/source-map-support/node_modules/source-map/lib/base64.js
var require_base64 = __commonJS({
  "node_modules/source-map-support/node_modules/source-map/lib/base64.js"(exports) {
    var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    exports.encode = function(number) {
      if (0 <= number && number < intToCharMap.length)
        return intToCharMap[number];
      throw new TypeError("Must be between 0 and 63: " + number);
    };
    exports.decode = function(charCode) {
      var bigA = 65, bigZ = 90, littleA = 97, littleZ = 122, zero = 48, nine = 57, plus = 43, slash = 47, littleOffset = 26, numberOffset = 52;
      return bigA <= charCode && charCode <= bigZ ? charCode - bigA : littleA <= charCode && charCode <= littleZ ? charCode - littleA + littleOffset : zero <= charCode && charCode <= nine ? charCode - zero + numberOffset : charCode == plus ? 62 : charCode == slash ? 63 : -1;
    };
  }
});

// node_modules/source-map-support/node_modules/source-map/lib/base64-vlq.js
var require_base64_vlq = __commonJS({
  "node_modules/source-map-support/node_modules/source-map/lib/base64-vlq.js"(exports) {
    var base64 = require_base64(), VLQ_BASE_SHIFT = 5, VLQ_BASE = 1 << VLQ_BASE_SHIFT, VLQ_BASE_MASK = VLQ_BASE - 1, VLQ_CONTINUATION_BIT = VLQ_BASE;
    function toVLQSigned(aValue) {
      return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
    }
    function fromVLQSigned(aValue) {
      var isNegative = (aValue & 1) === 1, shifted = aValue >> 1;
      return isNegative ? -shifted : shifted;
    }
    exports.encode = function(aValue) {
      var encoded = "", digit, vlq = toVLQSigned(aValue);
      do
        digit = vlq & VLQ_BASE_MASK, vlq >>>= VLQ_BASE_SHIFT, vlq > 0 && (digit |= VLQ_CONTINUATION_BIT), encoded += base64.encode(digit);
      while (vlq > 0);
      return encoded;
    };
    exports.decode = function(aStr, aIndex, aOutParam) {
      var strLen = aStr.length, result = 0, shift = 0, continuation, digit;
      do {
        if (aIndex >= strLen)
          throw new Error("Expected more digits in base 64 VLQ value.");
        if (digit = base64.decode(aStr.charCodeAt(aIndex++)), digit === -1)
          throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        continuation = !!(digit & VLQ_CONTINUATION_BIT), digit &= VLQ_BASE_MASK, result = result + (digit << shift), shift += VLQ_BASE_SHIFT;
      } while (continuation);
      aOutParam.value = fromVLQSigned(result), aOutParam.rest = aIndex;
    };
  }
});

// node_modules/source-map-support/node_modules/source-map/lib/util.js
var require_util = __commonJS({
  "node_modules/source-map-support/node_modules/source-map/lib/util.js"(exports) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs)
        return aArgs[aName];
      if (arguments.length === 3)
        return aDefaultValue;
      throw new Error('"' + aName + '" is a required argument.');
    }
    exports.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/, dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match = aUrl.match(urlRegexp);
      return match ? {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
      } : null;
    }
    exports.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url2 = "";
      return aParsedUrl.scheme && (url2 += aParsedUrl.scheme + ":"), url2 += "//", aParsedUrl.auth && (url2 += aParsedUrl.auth + "@"), aParsedUrl.host && (url2 += aParsedUrl.host), aParsedUrl.port && (url2 += ":" + aParsedUrl.port), aParsedUrl.path && (url2 += aParsedUrl.path), url2;
    }
    exports.urlGenerate = urlGenerate;
    function normalize(aPath) {
      var path = aPath, url2 = urlParse(aPath);
      if (url2) {
        if (!url2.path)
          return aPath;
        path = url2.path;
      }
      for (var isAbsolute = exports.isAbsolute(path), parts = path.split(/\/+/), part, up = 0, i = parts.length - 1; i >= 0; i--)
        part = parts[i], part === "." ? parts.splice(i, 1) : part === ".." ? up++ : up > 0 && (part === "" ? (parts.splice(i + 1, up), up = 0) : (parts.splice(i, 2), up--));
      return path = parts.join("/"), path === "" && (path = isAbsolute ? "/" : "."), url2 ? (url2.path = path, urlGenerate(url2)) : path;
    }
    exports.normalize = normalize;
    function join(aRoot, aPath) {
      aRoot === "" && (aRoot = "."), aPath === "" && (aPath = ".");
      var aPathUrl = urlParse(aPath), aRootUrl = urlParse(aRoot);
      if (aRootUrl && (aRoot = aRootUrl.path || "/"), aPathUrl && !aPathUrl.scheme)
        return aRootUrl && (aPathUrl.scheme = aRootUrl.scheme), urlGenerate(aPathUrl);
      if (aPathUrl || aPath.match(dataUrlRegexp))
        return aPath;
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path)
        return aRootUrl.host = aPath, urlGenerate(aRootUrl);
      var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
      return aRootUrl ? (aRootUrl.path = joined, urlGenerate(aRootUrl)) : joined;
    }
    exports.join = join;
    exports.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
    };
    function relative(aRoot, aPath) {
      aRoot === "" && (aRoot = "."), aRoot = aRoot.replace(/\/$/, "");
      for (var level = 0; aPath.indexOf(aRoot + "/") !== 0; ) {
        var index = aRoot.lastIndexOf("/");
        if (index < 0 || (aRoot = aRoot.slice(0, index), aRoot.match(/^([^\/]+:\/)?\/*$/)))
          return aPath;
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports.relative = relative;
    var supportsNullProto = function() {
      var obj = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in obj);
    }();
    function identity(s) {
      return s;
    }
    function toSetString(aStr) {
      return isProtoString(aStr) ? "$" + aStr : aStr;
    }
    exports.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      return isProtoString(aStr) ? aStr.slice(1) : aStr;
    }
    exports.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s) {
      if (!s)
        return !1;
      var length = s.length;
      if (length < 9 || s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95)
        return !1;
      for (var i = length - 10; i >= 0; i--)
        if (s.charCodeAt(i) !== 36)
          return !1;
      return !0;
    }
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = strcmp(mappingA.source, mappingB.source);
      return cmp !== 0 || (cmp = mappingA.originalLine - mappingB.originalLine, cmp !== 0) || (cmp = mappingA.originalColumn - mappingB.originalColumn, cmp !== 0 || onlyCompareOriginal) || (cmp = mappingA.generatedColumn - mappingB.generatedColumn, cmp !== 0) || (cmp = mappingA.generatedLine - mappingB.generatedLine, cmp !== 0) ? cmp : strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByOriginalPositions = compareByOriginalPositions;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      return cmp !== 0 || (cmp = mappingA.generatedColumn - mappingB.generatedColumn, cmp !== 0 || onlyCompareGenerated) || (cmp = strcmp(mappingA.source, mappingB.source), cmp !== 0) || (cmp = mappingA.originalLine - mappingB.originalLine, cmp !== 0) || (cmp = mappingA.originalColumn - mappingB.originalColumn, cmp !== 0) ? cmp : strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function strcmp(aStr1, aStr2) {
      return aStr1 === aStr2 ? 0 : aStr1 === null ? 1 : aStr2 === null ? -1 : aStr1 > aStr2 ? 1 : -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      return cmp !== 0 || (cmp = mappingA.generatedColumn - mappingB.generatedColumn, cmp !== 0) || (cmp = strcmp(mappingA.source, mappingB.source), cmp !== 0) || (cmp = mappingA.originalLine - mappingB.originalLine, cmp !== 0) || (cmp = mappingA.originalColumn - mappingB.originalColumn, cmp !== 0) ? cmp : strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
    function parseSourceMapInput(str) {
      return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
    }
    exports.parseSourceMapInput = parseSourceMapInput;
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      if (sourceURL = sourceURL || "", sourceRoot && (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/" && (sourceRoot += "/"), sourceURL = sourceRoot + sourceURL), sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed)
          throw new Error("sourceMapURL could not be parsed");
        if (parsed.path) {
          var index = parsed.path.lastIndexOf("/");
          index >= 0 && (parsed.path = parsed.path.substring(0, index + 1));
        }
        sourceURL = join(urlGenerate(parsed), sourceURL);
      }
      return normalize(sourceURL);
    }
    exports.computeSourceURL = computeSourceURL;
  }
});

// node_modules/source-map-support/node_modules/source-map/lib/array-set.js
var require_array_set = __commonJS({
  "node_modules/source-map-support/node_modules/source-map/lib/array-set.js"(exports) {
    var util2 = require_util(), has = Object.prototype.hasOwnProperty, hasNativeMap = typeof Map < "u";
    function ArraySet() {
      this._array = [], this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
    }
    ArraySet.fromArray = function(aArray, aAllowDuplicates) {
      for (var set = new ArraySet(), i = 0, len = aArray.length; i < len; i++)
        set.add(aArray[i], aAllowDuplicates);
      return set;
    };
    ArraySet.prototype.size = function() {
      return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
    };
    ArraySet.prototype.add = function(aStr, aAllowDuplicates) {
      var sStr = hasNativeMap ? aStr : util2.toSetString(aStr), isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr), idx = this._array.length;
      (!isDuplicate || aAllowDuplicates) && this._array.push(aStr), isDuplicate || (hasNativeMap ? this._set.set(aStr, idx) : this._set[sStr] = idx);
    };
    ArraySet.prototype.has = function(aStr) {
      if (hasNativeMap)
        return this._set.has(aStr);
      var sStr = util2.toSetString(aStr);
      return has.call(this._set, sStr);
    };
    ArraySet.prototype.indexOf = function(aStr) {
      if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0)
          return idx;
      } else {
        var sStr = util2.toSetString(aStr);
        if (has.call(this._set, sStr))
          return this._set[sStr];
      }
      throw new Error('"' + aStr + '" is not in the set.');
    };
    ArraySet.prototype.at = function(aIdx) {
      if (aIdx >= 0 && aIdx < this._array.length)
        return this._array[aIdx];
      throw new Error("No element indexed by " + aIdx);
    };
    ArraySet.prototype.toArray = function() {
      return this._array.slice();
    };
    exports.ArraySet = ArraySet;
  }
});

// node_modules/source-map-support/node_modules/source-map/lib/mapping-list.js
var require_mapping_list = __commonJS({
  "node_modules/source-map-support/node_modules/source-map/lib/mapping-list.js"(exports) {
    var util2 = require_util();
    function generatedPositionAfter(mappingA, mappingB) {
      var lineA = mappingA.generatedLine, lineB = mappingB.generatedLine, columnA = mappingA.generatedColumn, columnB = mappingB.generatedColumn;
      return lineB > lineA || lineB == lineA && columnB >= columnA || util2.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    }
    function MappingList() {
      this._array = [], this._sorted = !0, this._last = { generatedLine: -1, generatedColumn: 0 };
    }
    MappingList.prototype.unsortedForEach = function(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };
    MappingList.prototype.add = function(aMapping) {
      generatedPositionAfter(this._last, aMapping) ? (this._last = aMapping, this._array.push(aMapping)) : (this._sorted = !1, this._array.push(aMapping));
    };
    MappingList.prototype.toArray = function() {
      return this._sorted || (this._array.sort(util2.compareByGeneratedPositionsInflated), this._sorted = !0), this._array;
    };
    exports.MappingList = MappingList;
  }
});

// node_modules/source-map-support/node_modules/source-map/lib/source-map-generator.js
var require_source_map_generator = __commonJS({
  "node_modules/source-map-support/node_modules/source-map/lib/source-map-generator.js"(exports) {
    var base64VLQ = require_base64_vlq(), util2 = require_util(), ArraySet = require_array_set().ArraySet, MappingList = require_mapping_list().MappingList;
    function SourceMapGenerator(aArgs) {
      aArgs || (aArgs = {}), this._file = util2.getArg(aArgs, "file", null), this._sourceRoot = util2.getArg(aArgs, "sourceRoot", null), this._skipValidation = util2.getArg(aArgs, "skipValidation", !1), this._sources = new ArraySet(), this._names = new ArraySet(), this._mappings = new MappingList(), this._sourcesContents = null;
    }
    SourceMapGenerator.prototype._version = 3;
    SourceMapGenerator.fromSourceMap = function(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot, generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot
      });
      return aSourceMapConsumer.eachMapping(function(mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };
        mapping.source != null && (newMapping.source = mapping.source, sourceRoot != null && (newMapping.source = util2.relative(sourceRoot, newMapping.source)), newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        }, mapping.name != null && (newMapping.name = mapping.name)), generator.addMapping(newMapping);
      }), aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var sourceRelative = sourceFile;
        sourceRoot !== null && (sourceRelative = util2.relative(sourceRoot, sourceFile)), generator._sources.has(sourceRelative) || generator._sources.add(sourceRelative);
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        content != null && generator.setSourceContent(sourceFile, content);
      }), generator;
    };
    SourceMapGenerator.prototype.addMapping = function(aArgs) {
      var generated = util2.getArg(aArgs, "generated"), original = util2.getArg(aArgs, "original", null), source = util2.getArg(aArgs, "source", null), name = util2.getArg(aArgs, "name", null);
      this._skipValidation || this._validateMapping(generated, original, source, name), source != null && (source = String(source), this._sources.has(source) || this._sources.add(source)), name != null && (name = String(name), this._names.has(name) || this._names.add(name)), this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source,
        name
      });
    };
    SourceMapGenerator.prototype.setSourceContent = function(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      this._sourceRoot != null && (source = util2.relative(this._sourceRoot, source)), aSourceContent != null ? (this._sourcesContents || (this._sourcesContents = /* @__PURE__ */ Object.create(null)), this._sourcesContents[util2.toSetString(source)] = aSourceContent) : this._sourcesContents && (delete this._sourcesContents[util2.toSetString(source)], Object.keys(this._sourcesContents).length === 0 && (this._sourcesContents = null));
    };
    SourceMapGenerator.prototype.applySourceMap = function(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null)
          throw new Error(
            `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
          );
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      sourceRoot != null && (sourceFile = util2.relative(sourceRoot, sourceFile));
      var newSources = new ArraySet(), newNames = new ArraySet();
      this._mappings.unsortedForEach(function(mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          original.source != null && (mapping.source = original.source, aSourceMapPath != null && (mapping.source = util2.join(aSourceMapPath, mapping.source)), sourceRoot != null && (mapping.source = util2.relative(sourceRoot, mapping.source)), mapping.originalLine = original.line, mapping.originalColumn = original.column, original.name != null && (mapping.name = original.name));
        }
        var source = mapping.source;
        source != null && !newSources.has(source) && newSources.add(source);
        var name = mapping.name;
        name != null && !newNames.has(name) && newNames.add(name);
      }, this), this._sources = newSources, this._names = newNames, aSourceMapConsumer.sources.forEach(function(sourceFile2) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
        content != null && (aSourceMapPath != null && (sourceFile2 = util2.join(aSourceMapPath, sourceFile2)), sourceRoot != null && (sourceFile2 = util2.relative(sourceRoot, sourceFile2)), this.setSourceContent(sourceFile2, content));
      }, this);
    };
    SourceMapGenerator.prototype._validateMapping = function(aGenerated, aOriginal, aSource, aName) {
      if (aOriginal && typeof aOriginal.line != "number" && typeof aOriginal.column != "number")
        throw new Error(
          "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
        );
      if (!(aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName)) {
        if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource)
          return;
        throw new Error("Invalid mapping: " + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };
    SourceMapGenerator.prototype._serializeMappings = function() {
      for (var previousGeneratedColumn = 0, previousGeneratedLine = 1, previousOriginalColumn = 0, previousOriginalLine = 0, previousName = 0, previousSource = 0, result = "", next, mapping, nameIdx, sourceIdx, mappings = this._mappings.toArray(), i = 0, len = mappings.length; i < len; i++) {
        if (mapping = mappings[i], next = "", mapping.generatedLine !== previousGeneratedLine)
          for (previousGeneratedColumn = 0; mapping.generatedLine !== previousGeneratedLine; )
            next += ";", previousGeneratedLine++;
        else if (i > 0) {
          if (!util2.compareByGeneratedPositionsInflated(mapping, mappings[i - 1]))
            continue;
          next += ",";
        }
        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn), previousGeneratedColumn = mapping.generatedColumn, mapping.source != null && (sourceIdx = this._sources.indexOf(mapping.source), next += base64VLQ.encode(sourceIdx - previousSource), previousSource = sourceIdx, next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine), previousOriginalLine = mapping.originalLine - 1, next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn), previousOriginalColumn = mapping.originalColumn, mapping.name != null && (nameIdx = this._names.indexOf(mapping.name), next += base64VLQ.encode(nameIdx - previousName), previousName = nameIdx)), result += next;
      }
      return result;
    };
    SourceMapGenerator.prototype._generateSourcesContent = function(aSources, aSourceRoot) {
      return aSources.map(function(source) {
        if (!this._sourcesContents)
          return null;
        aSourceRoot != null && (source = util2.relative(aSourceRoot, source));
        var key = util2.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
      }, this);
    };
    SourceMapGenerator.prototype.toJSON = function() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      return this._file != null && (map.file = this._file), this._sourceRoot != null && (map.sourceRoot = this._sourceRoot), this._sourcesContents && (map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot)), map;
    };
    SourceMapGenerator.prototype.toString = function() {
      return JSON.stringify(this.toJSON());
    };
    exports.SourceMapGenerator = SourceMapGenerator;
  }
});

// node_modules/source-map-support/node_modules/source-map/lib/binary-search.js
var require_binary_search = __commonJS({
  "node_modules/source-map-support/node_modules/source-map/lib/binary-search.js"(exports) {
    exports.GREATEST_LOWER_BOUND = 1;
    exports.LEAST_UPPER_BOUND = 2;
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      var mid = Math.floor((aHigh - aLow) / 2) + aLow, cmp = aCompare(aNeedle, aHaystack[mid], !0);
      return cmp === 0 ? mid : cmp > 0 ? aHigh - mid > 1 ? recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias) : aBias == exports.LEAST_UPPER_BOUND ? aHigh < aHaystack.length ? aHigh : -1 : mid : mid - aLow > 1 ? recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias) : aBias == exports.LEAST_UPPER_BOUND ? mid : aLow < 0 ? -1 : aLow;
    }
    exports.search = function(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0)
        return -1;
      var index = recursiveSearch(
        -1,
        aHaystack.length,
        aNeedle,
        aHaystack,
        aCompare,
        aBias || exports.GREATEST_LOWER_BOUND
      );
      if (index < 0)
        return -1;
      for (; index - 1 >= 0 && aCompare(aHaystack[index], aHaystack[index - 1], !0) === 0; )
        --index;
      return index;
    };
  }
});

// node_modules/source-map-support/node_modules/source-map/lib/quick-sort.js
var require_quick_sort = __commonJS({
  "node_modules/source-map-support/node_modules/source-map/lib/quick-sort.js"(exports) {
    function swap(ary, x, y) {
      var temp = ary[x];
      ary[x] = ary[y], ary[y] = temp;
    }
    function randomIntInRange(low, high) {
      return Math.round(low + Math.random() * (high - low));
    }
    function doQuickSort(ary, comparator, p, r) {
      if (p < r) {
        var pivotIndex = randomIntInRange(p, r), i = p - 1;
        swap(ary, pivotIndex, r);
        for (var pivot = ary[r], j = p; j < r; j++)
          comparator(ary[j], pivot) <= 0 && (i += 1, swap(ary, i, j));
        swap(ary, i + 1, j);
        var q = i + 1;
        doQuickSort(ary, comparator, p, q - 1), doQuickSort(ary, comparator, q + 1, r);
      }
    }
    exports.quickSort = function(ary, comparator) {
      doQuickSort(ary, comparator, 0, ary.length - 1);
    };
  }
});

// node_modules/source-map-support/node_modules/source-map/lib/source-map-consumer.js
var require_source_map_consumer = __commonJS({
  "node_modules/source-map-support/node_modules/source-map/lib/source-map-consumer.js"(exports) {
    var util2 = require_util(), binarySearch = require_binary_search(), ArraySet = require_array_set().ArraySet, base64VLQ = require_base64_vlq(), quickSort = require_quick_sort().quickSort;
    function SourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      return typeof aSourceMap == "string" && (sourceMap = util2.parseSourceMapInput(aSourceMap)), sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
    }
    SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
      return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
    };
    SourceMapConsumer.prototype._version = 3;
    SourceMapConsumer.prototype.__generatedMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
      configurable: !0,
      enumerable: !0,
      get: function() {
        return this.__generatedMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__generatedMappings;
      }
    });
    SourceMapConsumer.prototype.__originalMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
      configurable: !0,
      enumerable: !0,
      get: function() {
        return this.__originalMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__originalMappings;
      }
    });
    SourceMapConsumer.prototype._charIsMappingSeparator = function(aStr, index) {
      var c = aStr.charAt(index);
      return c === ";" || c === ",";
    };
    SourceMapConsumer.prototype._parseMappings = function(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    };
    SourceMapConsumer.GENERATED_ORDER = 1;
    SourceMapConsumer.ORIGINAL_ORDER = 2;
    SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
    SourceMapConsumer.LEAST_UPPER_BOUND = 2;
    SourceMapConsumer.prototype.eachMapping = function(aCallback, aContext, aOrder) {
      var context = aContext || null, order = aOrder || SourceMapConsumer.GENERATED_ORDER, mappings;
      switch (order) {
        case SourceMapConsumer.GENERATED_ORDER:
          mappings = this._generatedMappings;
          break;
        case SourceMapConsumer.ORIGINAL_ORDER:
          mappings = this._originalMappings;
          break;
        default:
          throw new Error("Unknown order of iteration.");
      }
      var sourceRoot = this.sourceRoot;
      mappings.map(function(mapping) {
        var source = mapping.source === null ? null : this._sources.at(mapping.source);
        return source = util2.computeSourceURL(sourceRoot, source, this._sourceMapURL), {
          source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name === null ? null : this._names.at(mapping.name)
        };
      }, this).forEach(aCallback, context);
    };
    SourceMapConsumer.prototype.allGeneratedPositionsFor = function(aArgs) {
      var line = util2.getArg(aArgs, "line"), needle = {
        source: util2.getArg(aArgs, "source"),
        originalLine: line,
        originalColumn: util2.getArg(aArgs, "column", 0)
      };
      if (needle.source = this._findSourceIndex(needle.source), needle.source < 0)
        return [];
      var mappings = [], index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util2.compareByOriginalPositions,
        binarySearch.LEAST_UPPER_BOUND
      );
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (aArgs.column === void 0)
          for (var originalLine = mapping.originalLine; mapping && mapping.originalLine === originalLine; )
            mappings.push({
              line: util2.getArg(mapping, "generatedLine", null),
              column: util2.getArg(mapping, "generatedColumn", null),
              lastColumn: util2.getArg(mapping, "lastGeneratedColumn", null)
            }), mapping = this._originalMappings[++index];
        else
          for (var originalColumn = mapping.originalColumn; mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn; )
            mappings.push({
              line: util2.getArg(mapping, "generatedLine", null),
              column: util2.getArg(mapping, "generatedColumn", null),
              lastColumn: util2.getArg(mapping, "lastGeneratedColumn", null)
            }), mapping = this._originalMappings[++index];
      }
      return mappings;
    };
    exports.SourceMapConsumer = SourceMapConsumer;
    function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      typeof aSourceMap == "string" && (sourceMap = util2.parseSourceMapInput(aSourceMap));
      var version = util2.getArg(sourceMap, "version"), sources = util2.getArg(sourceMap, "sources"), names = util2.getArg(sourceMap, "names", []), sourceRoot = util2.getArg(sourceMap, "sourceRoot", null), sourcesContent = util2.getArg(sourceMap, "sourcesContent", null), mappings = util2.getArg(sourceMap, "mappings"), file = util2.getArg(sourceMap, "file", null);
      if (version != this._version)
        throw new Error("Unsupported version: " + version);
      sourceRoot && (sourceRoot = util2.normalize(sourceRoot)), sources = sources.map(String).map(util2.normalize).map(function(source) {
        return sourceRoot && util2.isAbsolute(sourceRoot) && util2.isAbsolute(source) ? util2.relative(sourceRoot, source) : source;
      }), this._names = ArraySet.fromArray(names.map(String), !0), this._sources = ArraySet.fromArray(sources, !0), this._absoluteSources = this._sources.toArray().map(function(s) {
        return util2.computeSourceURL(sourceRoot, s, aSourceMapURL);
      }), this.sourceRoot = sourceRoot, this.sourcesContent = sourcesContent, this._mappings = mappings, this._sourceMapURL = aSourceMapURL, this.file = file;
    }
    BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
    BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
      var relativeSource = aSource;
      if (this.sourceRoot != null && (relativeSource = util2.relative(this.sourceRoot, relativeSource)), this._sources.has(relativeSource))
        return this._sources.indexOf(relativeSource);
      var i;
      for (i = 0; i < this._absoluteSources.length; ++i)
        if (this._absoluteSources[i] == aSource)
          return i;
      return -1;
    };
    BasicSourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
      var smc = Object.create(BasicSourceMapConsumer.prototype), names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), !0), sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), !0);
      smc.sourceRoot = aSourceMap._sourceRoot, smc.sourcesContent = aSourceMap._generateSourcesContent(
        smc._sources.toArray(),
        smc.sourceRoot
      ), smc.file = aSourceMap._file, smc._sourceMapURL = aSourceMapURL, smc._absoluteSources = smc._sources.toArray().map(function(s) {
        return util2.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
      });
      for (var generatedMappings = aSourceMap._mappings.toArray().slice(), destGeneratedMappings = smc.__generatedMappings = [], destOriginalMappings = smc.__originalMappings = [], i = 0, length = generatedMappings.length; i < length; i++) {
        var srcMapping = generatedMappings[i], destMapping = new Mapping();
        destMapping.generatedLine = srcMapping.generatedLine, destMapping.generatedColumn = srcMapping.generatedColumn, srcMapping.source && (destMapping.source = sources.indexOf(srcMapping.source), destMapping.originalLine = srcMapping.originalLine, destMapping.originalColumn = srcMapping.originalColumn, srcMapping.name && (destMapping.name = names.indexOf(srcMapping.name)), destOriginalMappings.push(destMapping)), destGeneratedMappings.push(destMapping);
      }
      return quickSort(smc.__originalMappings, util2.compareByOriginalPositions), smc;
    };
    BasicSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
      get: function() {
        return this._absoluteSources.slice();
      }
    });
    function Mapping() {
      this.generatedLine = 0, this.generatedColumn = 0, this.source = null, this.originalLine = null, this.originalColumn = null, this.name = null;
    }
    BasicSourceMapConsumer.prototype._parseMappings = function(aStr, aSourceRoot) {
      for (var generatedLine = 1, previousGeneratedColumn = 0, previousOriginalLine = 0, previousOriginalColumn = 0, previousSource = 0, previousName = 0, length = aStr.length, index = 0, cachedSegments = {}, temp = {}, originalMappings = [], generatedMappings = [], mapping, str, segment, end, value; index < length; )
        if (aStr.charAt(index) === ";")
          generatedLine++, index++, previousGeneratedColumn = 0;
        else if (aStr.charAt(index) === ",")
          index++;
        else {
          for (mapping = new Mapping(), mapping.generatedLine = generatedLine, end = index; end < length && !this._charIsMappingSeparator(aStr, end); end++)
            ;
          if (str = aStr.slice(index, end), segment = cachedSegments[str], segment)
            index += str.length;
          else {
            for (segment = []; index < end; )
              base64VLQ.decode(aStr, index, temp), value = temp.value, index = temp.rest, segment.push(value);
            if (segment.length === 2)
              throw new Error("Found a source, but no line and column");
            if (segment.length === 3)
              throw new Error("Found a source and line, but no column");
            cachedSegments[str] = segment;
          }
          mapping.generatedColumn = previousGeneratedColumn + segment[0], previousGeneratedColumn = mapping.generatedColumn, segment.length > 1 && (mapping.source = previousSource + segment[1], previousSource += segment[1], mapping.originalLine = previousOriginalLine + segment[2], previousOriginalLine = mapping.originalLine, mapping.originalLine += 1, mapping.originalColumn = previousOriginalColumn + segment[3], previousOriginalColumn = mapping.originalColumn, segment.length > 4 && (mapping.name = previousName + segment[4], previousName += segment[4])), generatedMappings.push(mapping), typeof mapping.originalLine == "number" && originalMappings.push(mapping);
        }
      quickSort(generatedMappings, util2.compareByGeneratedPositionsDeflated), this.__generatedMappings = generatedMappings, quickSort(originalMappings, util2.compareByOriginalPositions), this.__originalMappings = originalMappings;
    };
    BasicSourceMapConsumer.prototype._findMapping = function(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
      if (aNeedle[aLineName] <= 0)
        throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
      if (aNeedle[aColumnName] < 0)
        throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
    };
    BasicSourceMapConsumer.prototype.computeColumnSpans = function() {
      for (var index = 0; index < this._generatedMappings.length; ++index) {
        var mapping = this._generatedMappings[index];
        if (index + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index + 1];
          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }
        mapping.lastGeneratedColumn = 1 / 0;
      }
    };
    BasicSourceMapConsumer.prototype.originalPositionFor = function(aArgs) {
      var needle = {
        generatedLine: util2.getArg(aArgs, "line"),
        generatedColumn: util2.getArg(aArgs, "column")
      }, index = this._findMapping(
        needle,
        this._generatedMappings,
        "generatedLine",
        "generatedColumn",
        util2.compareByGeneratedPositionsDeflated,
        util2.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index >= 0) {
        var mapping = this._generatedMappings[index];
        if (mapping.generatedLine === needle.generatedLine) {
          var source = util2.getArg(mapping, "source", null);
          source !== null && (source = this._sources.at(source), source = util2.computeSourceURL(this.sourceRoot, source, this._sourceMapURL));
          var name = util2.getArg(mapping, "name", null);
          return name !== null && (name = this._names.at(name)), {
            source,
            line: util2.getArg(mapping, "originalLine", null),
            column: util2.getArg(mapping, "originalColumn", null),
            name
          };
        }
      }
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };
    BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function() {
      return this.sourcesContent ? this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
        return sc == null;
      }) : !1;
    };
    BasicSourceMapConsumer.prototype.sourceContentFor = function(aSource, nullOnMissing) {
      if (!this.sourcesContent)
        return null;
      var index = this._findSourceIndex(aSource);
      if (index >= 0)
        return this.sourcesContent[index];
      var relativeSource = aSource;
      this.sourceRoot != null && (relativeSource = util2.relative(this.sourceRoot, relativeSource));
      var url2;
      if (this.sourceRoot != null && (url2 = util2.urlParse(this.sourceRoot))) {
        var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
        if (url2.scheme == "file" && this._sources.has(fileUriAbsPath))
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
        if ((!url2.path || url2.path == "/") && this._sources.has("/" + relativeSource))
          return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
      }
      if (nullOnMissing)
        return null;
      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
    };
    BasicSourceMapConsumer.prototype.generatedPositionFor = function(aArgs) {
      var source = util2.getArg(aArgs, "source");
      if (source = this._findSourceIndex(source), source < 0)
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      var needle = {
        source,
        originalLine: util2.getArg(aArgs, "line"),
        originalColumn: util2.getArg(aArgs, "column")
      }, index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util2.compareByOriginalPositions,
        util2.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (mapping.source === needle.source)
          return {
            line: util2.getArg(mapping, "generatedLine", null),
            column: util2.getArg(mapping, "generatedColumn", null),
            lastColumn: util2.getArg(mapping, "lastGeneratedColumn", null)
          };
      }
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };
    exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
    function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      typeof aSourceMap == "string" && (sourceMap = util2.parseSourceMapInput(aSourceMap));
      var version = util2.getArg(sourceMap, "version"), sections = util2.getArg(sourceMap, "sections");
      if (version != this._version)
        throw new Error("Unsupported version: " + version);
      this._sources = new ArraySet(), this._names = new ArraySet();
      var lastOffset = {
        line: -1,
        column: 0
      };
      this._sections = sections.map(function(s) {
        if (s.url)
          throw new Error("Support for url field in sections not implemented.");
        var offset = util2.getArg(s, "offset"), offsetLine = util2.getArg(offset, "line"), offsetColumn = util2.getArg(offset, "column");
        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column)
          throw new Error("Section offsets must be ordered and non-overlapping.");
        return lastOffset = offset, {
          generatedOffset: {
            // The offset fields are 0-based, but we use 1-based indices when
            // encoding/decoding from VLQ.
            generatedLine: offsetLine + 1,
            generatedColumn: offsetColumn + 1
          },
          consumer: new SourceMapConsumer(util2.getArg(s, "map"), aSourceMapURL)
        };
      });
    }
    IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
    IndexedSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
      get: function() {
        for (var sources = [], i = 0; i < this._sections.length; i++)
          for (var j = 0; j < this._sections[i].consumer.sources.length; j++)
            sources.push(this._sections[i].consumer.sources[j]);
        return sources;
      }
    });
    IndexedSourceMapConsumer.prototype.originalPositionFor = function(aArgs) {
      var needle = {
        generatedLine: util2.getArg(aArgs, "line"),
        generatedColumn: util2.getArg(aArgs, "column")
      }, sectionIndex = binarySearch.search(
        needle,
        this._sections,
        function(needle2, section2) {
          var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
          return cmp || needle2.generatedColumn - section2.generatedOffset.generatedColumn;
        }
      ), section = this._sections[sectionIndex];
      return section ? section.consumer.originalPositionFor({
        line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        bias: aArgs.bias
      }) : {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };
    IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function() {
      return this._sections.every(function(s) {
        return s.consumer.hasContentsOfAllSources();
      });
    };
    IndexedSourceMapConsumer.prototype.sourceContentFor = function(aSource, nullOnMissing) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i], content = section.consumer.sourceContentFor(aSource, !0);
        if (content)
          return content;
      }
      if (nullOnMissing)
        return null;
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    };
    IndexedSourceMapConsumer.prototype.generatedPositionFor = function(aArgs) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        if (section.consumer._findSourceIndex(util2.getArg(aArgs, "source")) !== -1) {
          var generatedPosition = section.consumer.generatedPositionFor(aArgs);
          if (generatedPosition) {
            var ret = {
              line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
              column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
            };
            return ret;
          }
        }
      }
      return {
        line: null,
        column: null
      };
    };
    IndexedSourceMapConsumer.prototype._parseMappings = function(aStr, aSourceRoot) {
      this.__generatedMappings = [], this.__originalMappings = [];
      for (var i = 0; i < this._sections.length; i++)
        for (var section = this._sections[i], sectionMappings = section.consumer._generatedMappings, j = 0; j < sectionMappings.length; j++) {
          var mapping = sectionMappings[j], source = section.consumer._sources.at(mapping.source);
          source = util2.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL), this._sources.add(source), source = this._sources.indexOf(source);
          var name = null;
          mapping.name && (name = section.consumer._names.at(mapping.name), this._names.add(name), name = this._names.indexOf(name));
          var adjustedMapping = {
            source,
            generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
            generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name
          };
          this.__generatedMappings.push(adjustedMapping), typeof adjustedMapping.originalLine == "number" && this.__originalMappings.push(adjustedMapping);
        }
      quickSort(this.__generatedMappings, util2.compareByGeneratedPositionsDeflated), quickSort(this.__originalMappings, util2.compareByOriginalPositions);
    };
    exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
  }
});

// node_modules/source-map-support/node_modules/source-map/lib/source-node.js
var require_source_node = __commonJS({
  "node_modules/source-map-support/node_modules/source-map/lib/source-node.js"(exports) {
    var SourceMapGenerator = require_source_map_generator().SourceMapGenerator, util2 = require_util(), REGEX_NEWLINE = /(\r?\n)/, NEWLINE_CODE = 10, isSourceNode = "$$$isSourceNode$$$";
    function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
      this.children = [], this.sourceContents = {}, this.line = aLine ?? null, this.column = aColumn ?? null, this.source = aSource ?? null, this.name = aName ?? null, this[isSourceNode] = !0, aChunks != null && this.add(aChunks);
    }
    SourceNode.fromStringWithSourceMap = function(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      var node = new SourceNode(), remainingLines = aGeneratedCode.split(REGEX_NEWLINE), remainingLinesIndex = 0, shiftNextLine = function() {
        var lineContents = getNextLine(), newLine = getNextLine() || "";
        return lineContents + newLine;
        function getNextLine() {
          return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
        }
      }, lastGeneratedLine = 1, lastGeneratedColumn = 0, lastMapping = null;
      return aSourceMapConsumer.eachMapping(function(mapping) {
        if (lastMapping !== null)
          if (lastGeneratedLine < mapping.generatedLine)
            addMappingWithCode(lastMapping, shiftNextLine()), lastGeneratedLine++, lastGeneratedColumn = 0;
          else {
            var nextLine = remainingLines[remainingLinesIndex] || "", code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn), lastGeneratedColumn = mapping.generatedColumn, addMappingWithCode(lastMapping, code), lastMapping = mapping;
            return;
          }
        for (; lastGeneratedLine < mapping.generatedLine; )
          node.add(shiftNextLine()), lastGeneratedLine++;
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[remainingLinesIndex] || "";
          node.add(nextLine.substr(0, mapping.generatedColumn)), remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn), lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this), remainingLinesIndex < remainingLines.length && (lastMapping && addMappingWithCode(lastMapping, shiftNextLine()), node.add(remainingLines.splice(remainingLinesIndex).join(""))), aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        content != null && (aRelativePath != null && (sourceFile = util2.join(aRelativePath, sourceFile)), node.setSourceContent(sourceFile, content));
      }), node;
      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === void 0)
          node.add(code);
        else {
          var source = aRelativePath ? util2.join(aRelativePath, mapping.source) : mapping.source;
          node.add(new SourceNode(
            mapping.originalLine,
            mapping.originalColumn,
            source,
            code,
            mapping.name
          ));
        }
      }
    };
    SourceNode.prototype.add = function(aChunk) {
      if (Array.isArray(aChunk))
        aChunk.forEach(function(chunk) {
          this.add(chunk);
        }, this);
      else if (aChunk[isSourceNode] || typeof aChunk == "string")
        aChunk && this.children.push(aChunk);
      else
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      return this;
    };
    SourceNode.prototype.prepend = function(aChunk) {
      if (Array.isArray(aChunk))
        for (var i = aChunk.length - 1; i >= 0; i--)
          this.prepend(aChunk[i]);
      else if (aChunk[isSourceNode] || typeof aChunk == "string")
        this.children.unshift(aChunk);
      else
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      return this;
    };
    SourceNode.prototype.walk = function(aFn) {
      for (var chunk, i = 0, len = this.children.length; i < len; i++)
        chunk = this.children[i], chunk[isSourceNode] ? chunk.walk(aFn) : chunk !== "" && aFn(chunk, {
          source: this.source,
          line: this.line,
          column: this.column,
          name: this.name
        });
    };
    SourceNode.prototype.join = function(aSep) {
      var newChildren, i, len = this.children.length;
      if (len > 0) {
        for (newChildren = [], i = 0; i < len - 1; i++)
          newChildren.push(this.children[i]), newChildren.push(aSep);
        newChildren.push(this.children[i]), this.children = newChildren;
      }
      return this;
    };
    SourceNode.prototype.replaceRight = function(aPattern, aReplacement) {
      var lastChild = this.children[this.children.length - 1];
      return lastChild[isSourceNode] ? lastChild.replaceRight(aPattern, aReplacement) : typeof lastChild == "string" ? this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement) : this.children.push("".replace(aPattern, aReplacement)), this;
    };
    SourceNode.prototype.setSourceContent = function(aSourceFile, aSourceContent) {
      this.sourceContents[util2.toSetString(aSourceFile)] = aSourceContent;
    };
    SourceNode.prototype.walkSourceContents = function(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++)
        this.children[i][isSourceNode] && this.children[i].walkSourceContents(aFn);
      for (var sources = Object.keys(this.sourceContents), i = 0, len = sources.length; i < len; i++)
        aFn(util2.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    };
    SourceNode.prototype.toString = function() {
      var str = "";
      return this.walk(function(chunk) {
        str += chunk;
      }), str;
    };
    SourceNode.prototype.toStringWithSourceMap = function(aArgs) {
      var generated = {
        code: "",
        line: 1,
        column: 0
      }, map = new SourceMapGenerator(aArgs), sourceMappingActive = !1, lastOriginalSource = null, lastOriginalLine = null, lastOriginalColumn = null, lastOriginalName = null;
      return this.walk(function(chunk, original) {
        generated.code += chunk, original.source !== null && original.line !== null && original.column !== null ? ((lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) && map.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        }), lastOriginalSource = original.source, lastOriginalLine = original.line, lastOriginalColumn = original.column, lastOriginalName = original.name, sourceMappingActive = !0) : sourceMappingActive && (map.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        }), lastOriginalSource = null, sourceMappingActive = !1);
        for (var idx = 0, length = chunk.length; idx < length; idx++)
          chunk.charCodeAt(idx) === NEWLINE_CODE ? (generated.line++, generated.column = 0, idx + 1 === length ? (lastOriginalSource = null, sourceMappingActive = !1) : sourceMappingActive && map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          })) : generated.column++;
      }), this.walkSourceContents(function(sourceFile, sourceContent) {
        map.setSourceContent(sourceFile, sourceContent);
      }), { code: generated.code, map };
    };
    exports.SourceNode = SourceNode;
  }
});

// node_modules/source-map-support/node_modules/source-map/source-map.js
var require_source_map = __commonJS({
  "node_modules/source-map-support/node_modules/source-map/source-map.js"(exports) {
    exports.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    exports.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
    exports.SourceNode = require_source_node().SourceNode;
  }
});

// node_modules/buffer-from/index.js
var require_buffer_from = __commonJS({
  "node_modules/buffer-from/index.js"(exports, module2) {
    var toString3 = Object.prototype.toString, isModern = typeof Buffer < "u" && typeof Buffer.alloc == "function" && typeof Buffer.allocUnsafe == "function" && typeof Buffer.from == "function";
    function isArrayBuffer2(input) {
      return toString3.call(input).slice(8, -1) === "ArrayBuffer";
    }
    function fromArrayBuffer(obj, byteOffset, length) {
      byteOffset >>>= 0;
      var maxLength = obj.byteLength - byteOffset;
      if (maxLength < 0)
        throw new RangeError("'offset' is out of bounds");
      if (length === void 0)
        length = maxLength;
      else if (length >>>= 0, length > maxLength)
        throw new RangeError("'length' is out of bounds");
      return isModern ? Buffer.from(obj.slice(byteOffset, byteOffset + length)) : new Buffer(new Uint8Array(obj.slice(byteOffset, byteOffset + length)));
    }
    function fromString(string, encoding) {
      if ((typeof encoding != "string" || encoding === "") && (encoding = "utf8"), !Buffer.isEncoding(encoding))
        throw new TypeError('"encoding" must be a valid string encoding');
      return isModern ? Buffer.from(string, encoding) : new Buffer(string, encoding);
    }
    function bufferFrom(value, encodingOrOffset, length) {
      if (typeof value == "number")
        throw new TypeError('"value" argument must not be a number');
      return isArrayBuffer2(value) ? fromArrayBuffer(value, encodingOrOffset, length) : typeof value == "string" ? fromString(value, encodingOrOffset) : isModern ? Buffer.from(value) : new Buffer(value);
    }
    module2.exports = bufferFrom;
  }
});

// node_modules/source-map-support/source-map-support.js
var require_source_map_support = __commonJS({
  "node_modules/source-map-support/source-map-support.js"(exports, module2) {
    var SourceMapConsumer = require_source_map().SourceMapConsumer, path = require("path"), fs;
    try {
      fs = require("fs"), (!fs.existsSync || !fs.readFileSync) && (fs = null);
    } catch {
    }
    var bufferFrom = require_buffer_from();
    function dynamicRequire(mod, request) {
      return mod.require(request);
    }
    var errorFormatterInstalled = !1, uncaughtShimInstalled = !1, emptyCacheBetweenOperations = !1, environment = "auto", fileContentsCache = {}, sourceMapCache = {}, reSourceMap = /^data:application\/json[^,]+base64,/, retrieveFileHandlers = [], retrieveMapHandlers = [];
    function isInBrowser() {
      return environment === "browser" ? !0 : environment === "node" ? !1 : typeof window < "u" && typeof XMLHttpRequest == "function" && !(window.require && window.module && window.process && window.process.type === "renderer");
    }
    function hasGlobalProcessEventEmitter() {
      return typeof process == "object" && process !== null && typeof process.on == "function";
    }
    function globalProcessVersion() {
      return typeof process == "object" && process !== null ? process.version : "";
    }
    function globalProcessStderr() {
      if (typeof process == "object" && process !== null)
        return process.stderr;
    }
    function globalProcessExit(code) {
      if (typeof process == "object" && process !== null && typeof process.exit == "function")
        return process.exit(code);
    }
    function handlerExec(list2) {
      return function(arg) {
        for (var i = 0; i < list2.length; i++) {
          var ret = list2[i](arg);
          if (ret)
            return ret;
        }
        return null;
      };
    }
    var retrieveFile = handlerExec(retrieveFileHandlers);
    retrieveFileHandlers.push(function(path2) {
      if (path2 = path2.trim(), /^file:/.test(path2) && (path2 = path2.replace(/file:\/\/\/(\w:)?/, function(protocol, drive) {
        return drive ? "" : (
          // file:///C:/dir/file -> C:/dir/file
          "/"
        );
      })), path2 in fileContentsCache)
        return fileContentsCache[path2];
      var contents = "";
      try {
        if (fs)
          fs.existsSync(path2) && (contents = fs.readFileSync(path2, "utf8"));
        else {
          var xhr = new XMLHttpRequest();
          xhr.open(
            "GET",
            path2,
            /** async */
            !1
          ), xhr.send(null), xhr.readyState === 4 && xhr.status === 200 && (contents = xhr.responseText);
        }
      } catch {
      }
      return fileContentsCache[path2] = contents;
    });
    function supportRelativeURL(file, url2) {
      if (!file)
        return url2;
      var dir = path.dirname(file), match = /^\w+:\/\/[^\/]*/.exec(dir), protocol = match ? match[0] : "", startPath = dir.slice(protocol.length);
      return protocol && /^\/\w\:/.test(startPath) ? (protocol += "/", protocol + path.resolve(dir.slice(protocol.length), url2).replace(/\\/g, "/")) : protocol + path.resolve(dir.slice(protocol.length), url2);
    }
    function retrieveSourceMapURL(source) {
      var fileData;
      if (isInBrowser())
        try {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", source, !1), xhr.send(null), fileData = xhr.readyState === 4 ? xhr.responseText : null;
          var sourceMapHeader = xhr.getResponseHeader("SourceMap") || xhr.getResponseHeader("X-SourceMap");
          if (sourceMapHeader)
            return sourceMapHeader;
        } catch {
        }
      fileData = retrieveFile(source);
      for (var re = /(?:\/\/[@#][\s]*sourceMappingURL=([^\s'"]+)[\s]*$)|(?:\/\*[@#][\s]*sourceMappingURL=([^\s*'"]+)[\s]*(?:\*\/)[\s]*$)/mg, lastMatch, match; match = re.exec(fileData); )
        lastMatch = match;
      return lastMatch ? lastMatch[1] : null;
    }
    var retrieveSourceMap = handlerExec(retrieveMapHandlers);
    retrieveMapHandlers.push(function(source) {
      var sourceMappingURL = retrieveSourceMapURL(source);
      if (!sourceMappingURL)
        return null;
      var sourceMapData;
      if (reSourceMap.test(sourceMappingURL)) {
        var rawData = sourceMappingURL.slice(sourceMappingURL.indexOf(",") + 1);
        sourceMapData = bufferFrom(rawData, "base64").toString(), sourceMappingURL = source;
      } else
        sourceMappingURL = supportRelativeURL(source, sourceMappingURL), sourceMapData = retrieveFile(sourceMappingURL);
      return sourceMapData ? {
        url: sourceMappingURL,
        map: sourceMapData
      } : null;
    });
    function mapSourcePosition(position) {
      var sourceMap = sourceMapCache[position.source];
      if (!sourceMap) {
        var urlAndMap = retrieveSourceMap(position.source);
        urlAndMap ? (sourceMap = sourceMapCache[position.source] = {
          url: urlAndMap.url,
          map: new SourceMapConsumer(urlAndMap.map)
        }, sourceMap.map.sourcesContent && sourceMap.map.sources.forEach(function(source, i) {
          var contents = sourceMap.map.sourcesContent[i];
          if (contents) {
            var url2 = supportRelativeURL(sourceMap.url, source);
            fileContentsCache[url2] = contents;
          }
        })) : sourceMap = sourceMapCache[position.source] = {
          url: null,
          map: null
        };
      }
      if (sourceMap && sourceMap.map && typeof sourceMap.map.originalPositionFor == "function") {
        var originalPosition = sourceMap.map.originalPositionFor(position);
        if (originalPosition.source !== null)
          return originalPosition.source = supportRelativeURL(
            sourceMap.url,
            originalPosition.source
          ), originalPosition;
      }
      return position;
    }
    function mapEvalOrigin(origin) {
      var match = /^eval at ([^(]+) \((.+):(\d+):(\d+)\)$/.exec(origin);
      if (match) {
        var position = mapSourcePosition({
          source: match[2],
          line: +match[3],
          column: match[4] - 1
        });
        return "eval at " + match[1] + " (" + position.source + ":" + position.line + ":" + (position.column + 1) + ")";
      }
      return match = /^eval at ([^(]+) \((.+)\)$/.exec(origin), match ? "eval at " + match[1] + " (" + mapEvalOrigin(match[2]) + ")" : origin;
    }
    function CallSiteToString() {
      var fileName, fileLocation = "";
      if (this.isNative())
        fileLocation = "native";
      else {
        fileName = this.getScriptNameOrSourceURL(), !fileName && this.isEval() && (fileLocation = this.getEvalOrigin(), fileLocation += ", "), fileName ? fileLocation += fileName : fileLocation += "<anonymous>";
        var lineNumber = this.getLineNumber();
        if (lineNumber != null) {
          fileLocation += ":" + lineNumber;
          var columnNumber = this.getColumnNumber();
          columnNumber && (fileLocation += ":" + columnNumber);
        }
      }
      var line = "", functionName = this.getFunctionName(), addSuffix = !0, isConstructor = this.isConstructor(), isMethodCall = !(this.isToplevel() || isConstructor);
      if (isMethodCall) {
        var typeName = this.getTypeName();
        typeName === "[object Object]" && (typeName = "null");
        var methodName = this.getMethodName();
        functionName ? (typeName && functionName.indexOf(typeName) != 0 && (line += typeName + "."), line += functionName, methodName && functionName.indexOf("." + methodName) != functionName.length - methodName.length - 1 && (line += " [as " + methodName + "]")) : line += typeName + "." + (methodName || "<anonymous>");
      } else
        isConstructor ? line += "new " + (functionName || "<anonymous>") : functionName ? line += functionName : (line += fileLocation, addSuffix = !1);
      return addSuffix && (line += " (" + fileLocation + ")"), line;
    }
    function cloneCallSite(frame) {
      var object = {};
      return Object.getOwnPropertyNames(Object.getPrototypeOf(frame)).forEach(function(name) {
        object[name] = /^(?:is|get)/.test(name) ? function() {
          return frame[name].call(frame);
        } : frame[name];
      }), object.toString = CallSiteToString, object;
    }
    function wrapCallSite(frame, state) {
      if (state === void 0 && (state = { nextPosition: null, curPosition: null }), frame.isNative())
        return state.curPosition = null, frame;
      var source = frame.getFileName() || frame.getScriptNameOrSourceURL();
      if (source) {
        var line = frame.getLineNumber(), column = frame.getColumnNumber() - 1, noHeader = /^v(10\.1[6-9]|10\.[2-9][0-9]|10\.[0-9]{3,}|1[2-9]\d*|[2-9]\d|\d{3,}|11\.11)/, headerLength = noHeader.test(globalProcessVersion()) ? 0 : 62;
        line === 1 && column > headerLength && !isInBrowser() && !frame.isEval() && (column -= headerLength);
        var position = mapSourcePosition({
          source,
          line,
          column
        });
        state.curPosition = position, frame = cloneCallSite(frame);
        var originalFunctionName = frame.getFunctionName;
        return frame.getFunctionName = function() {
          return state.nextPosition == null ? originalFunctionName() : state.nextPosition.name || originalFunctionName();
        }, frame.getFileName = function() {
          return position.source;
        }, frame.getLineNumber = function() {
          return position.line;
        }, frame.getColumnNumber = function() {
          return position.column + 1;
        }, frame.getScriptNameOrSourceURL = function() {
          return position.source;
        }, frame;
      }
      var origin = frame.isEval() && frame.getEvalOrigin();
      return origin && (origin = mapEvalOrigin(origin), frame = cloneCallSite(frame), frame.getEvalOrigin = function() {
        return origin;
      }), frame;
    }
    function prepareStackTrace(error, stack) {
      emptyCacheBetweenOperations && (fileContentsCache = {}, sourceMapCache = {});
      for (var name = error.name || "Error", message = error.message || "", errorString = name + ": " + message, state = { nextPosition: null, curPosition: null }, processedStack = [], i = stack.length - 1; i >= 0; i--)
        processedStack.push(`
    at ` + wrapCallSite(stack[i], state)), state.nextPosition = state.curPosition;
      return state.curPosition = state.nextPosition = null, errorString + processedStack.reverse().join("");
    }
    function getErrorSource(error) {
      var match = /\n    at [^(]+ \((.*):(\d+):(\d+)\)/.exec(error.stack);
      if (match) {
        var source = match[1], line = +match[2], column = +match[3], contents = fileContentsCache[source];
        if (!contents && fs && fs.existsSync(source))
          try {
            contents = fs.readFileSync(source, "utf8");
          } catch {
            contents = "";
          }
        if (contents) {
          var code = contents.split(/(?:\r\n|\r|\n)/)[line - 1];
          if (code)
            return source + ":" + line + `
` + code + `
` + new Array(column).join(" ") + "^";
        }
      }
      return null;
    }
    function printErrorAndExit(error) {
      var source = getErrorSource(error), stderr = globalProcessStderr();
      stderr && stderr._handle && stderr._handle.setBlocking && stderr._handle.setBlocking(!0), source && (console.error(), console.error(source)), console.error(error.stack), globalProcessExit(1);
    }
    function shimEmitUncaughtException() {
      var origEmit = process.emit;
      process.emit = function(type) {
        if (type === "uncaughtException") {
          var hasStack = arguments[1] && arguments[1].stack, hasListeners = this.listeners(type).length > 0;
          if (hasStack && !hasListeners)
            return printErrorAndExit(arguments[1]);
        }
        return origEmit.apply(this, arguments);
      };
    }
    var originalRetrieveFileHandlers = retrieveFileHandlers.slice(0), originalRetrieveMapHandlers = retrieveMapHandlers.slice(0);
    exports.wrapCallSite = wrapCallSite;
    exports.getErrorSource = getErrorSource;
    exports.mapSourcePosition = mapSourcePosition;
    exports.retrieveSourceMap = retrieveSourceMap;
    exports.install = function(options) {
      if (options = options || {}, options.environment && (environment = options.environment, ["node", "browser", "auto"].indexOf(environment) === -1))
        throw new Error("environment " + environment + " was unknown. Available options are {auto, browser, node}");
      if (options.retrieveFile && (options.overrideRetrieveFile && (retrieveFileHandlers.length = 0), retrieveFileHandlers.unshift(options.retrieveFile)), options.retrieveSourceMap && (options.overrideRetrieveSourceMap && (retrieveMapHandlers.length = 0), retrieveMapHandlers.unshift(options.retrieveSourceMap)), options.hookRequire && !isInBrowser()) {
        var Module = dynamicRequire(module2, "module"), $compile = Module.prototype._compile;
        $compile.__sourceMapSupport || (Module.prototype._compile = function(content, filename) {
          return fileContentsCache[filename] = content, sourceMapCache[filename] = void 0, $compile.call(this, content, filename);
        }, Module.prototype._compile.__sourceMapSupport = !0);
      }
      if (emptyCacheBetweenOperations || (emptyCacheBetweenOperations = "emptyCacheBetweenOperations" in options ? options.emptyCacheBetweenOperations : !1), errorFormatterInstalled || (errorFormatterInstalled = !0, Error.prepareStackTrace = prepareStackTrace), !uncaughtShimInstalled) {
        var installHandler = "handleUncaughtExceptions" in options ? options.handleUncaughtExceptions : !0;
        try {
          var worker_threads = dynamicRequire(module2, "worker_threads");
          worker_threads.isMainThread === !1 && (installHandler = !1);
        } catch {
        }
        installHandler && hasGlobalProcessEventEmitter() && (uncaughtShimInstalled = !0, shimEmitUncaughtException());
      }
    };
    exports.resetRetrieveHandlers = function() {
      retrieveFileHandlers.length = 0, retrieveMapHandlers.length = 0, retrieveFileHandlers = originalRetrieveFileHandlers.slice(0), retrieveMapHandlers = originalRetrieveMapHandlers.slice(0), retrieveSourceMap = handlerExec(retrieveMapHandlers), retrieveFile = handlerExec(retrieveFileHandlers);
    };
  }
});

// node_modules/event-target-shim/dist/event-target-shim.js
var require_event_target_shim = __commonJS({
  "node_modules/event-target-shim/dist/event-target-shim.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var privateData = /* @__PURE__ */ new WeakMap(), wrappers = /* @__PURE__ */ new WeakMap();
    function pd(event) {
      let retv = privateData.get(event);
      return console.assert(
        retv != null,
        "'this' is expected an Event object, but got",
        event
      ), retv;
    }
    function setCancelFlag(data) {
      if (data.passiveListener != null) {
        typeof console < "u" && typeof console.error == "function" && console.error(
          "Unable to preventDefault inside passive event listener invocation.",
          data.passiveListener
        );
        return;
      }
      data.event.cancelable && (data.canceled = !0, typeof data.event.preventDefault == "function" && data.event.preventDefault());
    }
    function Event(eventTarget, event) {
      privateData.set(this, {
        eventTarget,
        event,
        eventPhase: 2,
        currentTarget: eventTarget,
        canceled: !1,
        stopped: !1,
        immediateStopped: !1,
        passiveListener: null,
        timeStamp: event.timeStamp || Date.now()
      }), Object.defineProperty(this, "isTrusted", { value: !1, enumerable: !0 });
      let keys = Object.keys(event);
      for (let i = 0; i < keys.length; ++i) {
        let key = keys[i];
        key in this || Object.defineProperty(this, key, defineRedirectDescriptor(key));
      }
    }
    Event.prototype = {
      /**
       * The type of this event.
       * @type {string}
       */
      get type() {
        return pd(this).event.type;
      },
      /**
       * The target of this event.
       * @type {EventTarget}
       */
      get target() {
        return pd(this).eventTarget;
      },
      /**
       * The target of this event.
       * @type {EventTarget}
       */
      get currentTarget() {
        return pd(this).currentTarget;
      },
      /**
       * @returns {EventTarget[]} The composed path of this event.
       */
      composedPath() {
        let currentTarget = pd(this).currentTarget;
        return currentTarget == null ? [] : [currentTarget];
      },
      /**
       * Constant of NONE.
       * @type {number}
       */
      get NONE() {
        return 0;
      },
      /**
       * Constant of CAPTURING_PHASE.
       * @type {number}
       */
      get CAPTURING_PHASE() {
        return 1;
      },
      /**
       * Constant of AT_TARGET.
       * @type {number}
       */
      get AT_TARGET() {
        return 2;
      },
      /**
       * Constant of BUBBLING_PHASE.
       * @type {number}
       */
      get BUBBLING_PHASE() {
        return 3;
      },
      /**
       * The target of this event.
       * @type {number}
       */
      get eventPhase() {
        return pd(this).eventPhase;
      },
      /**
       * Stop event bubbling.
       * @returns {void}
       */
      stopPropagation() {
        let data = pd(this);
        data.stopped = !0, typeof data.event.stopPropagation == "function" && data.event.stopPropagation();
      },
      /**
       * Stop event bubbling.
       * @returns {void}
       */
      stopImmediatePropagation() {
        let data = pd(this);
        data.stopped = !0, data.immediateStopped = !0, typeof data.event.stopImmediatePropagation == "function" && data.event.stopImmediatePropagation();
      },
      /**
       * The flag to be bubbling.
       * @type {boolean}
       */
      get bubbles() {
        return Boolean(pd(this).event.bubbles);
      },
      /**
       * The flag to be cancelable.
       * @type {boolean}
       */
      get cancelable() {
        return Boolean(pd(this).event.cancelable);
      },
      /**
       * Cancel this event.
       * @returns {void}
       */
      preventDefault() {
        setCancelFlag(pd(this));
      },
      /**
       * The flag to indicate cancellation state.
       * @type {boolean}
       */
      get defaultPrevented() {
        return pd(this).canceled;
      },
      /**
       * The flag to be composed.
       * @type {boolean}
       */
      get composed() {
        return Boolean(pd(this).event.composed);
      },
      /**
       * The unix time of this event.
       * @type {number}
       */
      get timeStamp() {
        return pd(this).timeStamp;
      },
      /**
       * The target of this event.
       * @type {EventTarget}
       * @deprecated
       */
      get srcElement() {
        return pd(this).eventTarget;
      },
      /**
       * The flag to stop event bubbling.
       * @type {boolean}
       * @deprecated
       */
      get cancelBubble() {
        return pd(this).stopped;
      },
      set cancelBubble(value) {
        if (!value)
          return;
        let data = pd(this);
        data.stopped = !0, typeof data.event.cancelBubble == "boolean" && (data.event.cancelBubble = !0);
      },
      /**
       * The flag to indicate cancellation state.
       * @type {boolean}
       * @deprecated
       */
      get returnValue() {
        return !pd(this).canceled;
      },
      set returnValue(value) {
        value || setCancelFlag(pd(this));
      },
      /**
       * Initialize this event object. But do nothing under event dispatching.
       * @param {string} type The event type.
       * @param {boolean} [bubbles=false] The flag to be possible to bubble up.
       * @param {boolean} [cancelable=false] The flag to be possible to cancel.
       * @deprecated
       */
      initEvent() {
      }
    };
    Object.defineProperty(Event.prototype, "constructor", {
      value: Event,
      configurable: !0,
      writable: !0
    });
    typeof window < "u" && typeof window.Event < "u" && (Object.setPrototypeOf(Event.prototype, window.Event.prototype), wrappers.set(window.Event.prototype, Event));
    function defineRedirectDescriptor(key) {
      return {
        get() {
          return pd(this).event[key];
        },
        set(value) {
          pd(this).event[key] = value;
        },
        configurable: !0,
        enumerable: !0
      };
    }
    function defineCallDescriptor(key) {
      return {
        value() {
          let event = pd(this).event;
          return event[key].apply(event, arguments);
        },
        configurable: !0,
        enumerable: !0
      };
    }
    function defineWrapper(BaseEvent, proto) {
      let keys = Object.keys(proto);
      if (keys.length === 0)
        return BaseEvent;
      function CustomEvent(eventTarget, event) {
        BaseEvent.call(this, eventTarget, event);
      }
      CustomEvent.prototype = Object.create(BaseEvent.prototype, {
        constructor: { value: CustomEvent, configurable: !0, writable: !0 }
      });
      for (let i = 0; i < keys.length; ++i) {
        let key = keys[i];
        if (!(key in BaseEvent.prototype)) {
          let isFunc = typeof Object.getOwnPropertyDescriptor(proto, key).value == "function";
          Object.defineProperty(
            CustomEvent.prototype,
            key,
            isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key)
          );
        }
      }
      return CustomEvent;
    }
    function getWrapper(proto) {
      if (proto == null || proto === Object.prototype)
        return Event;
      let wrapper = wrappers.get(proto);
      return wrapper == null && (wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto), wrappers.set(proto, wrapper)), wrapper;
    }
    function wrapEvent(eventTarget, event) {
      let Wrapper = getWrapper(Object.getPrototypeOf(event));
      return new Wrapper(eventTarget, event);
    }
    function isStopped(event) {
      return pd(event).immediateStopped;
    }
    function setEventPhase(event, eventPhase) {
      pd(event).eventPhase = eventPhase;
    }
    function setCurrentTarget(event, currentTarget) {
      pd(event).currentTarget = currentTarget;
    }
    function setPassiveListener(event, passiveListener) {
      pd(event).passiveListener = passiveListener;
    }
    var listenersMap = /* @__PURE__ */ new WeakMap(), CAPTURE = 1, BUBBLE = 2, ATTRIBUTE = 3;
    function isObject2(x) {
      return x !== null && typeof x == "object";
    }
    function getListeners(eventTarget) {
      let listeners = listenersMap.get(eventTarget);
      if (listeners == null)
        throw new TypeError(
          "'this' is expected an EventTarget object, but got another value."
        );
      return listeners;
    }
    function defineEventAttributeDescriptor(eventName) {
      return {
        get() {
          let node = getListeners(this).get(eventName);
          for (; node != null; ) {
            if (node.listenerType === ATTRIBUTE)
              return node.listener;
            node = node.next;
          }
          return null;
        },
        set(listener) {
          typeof listener != "function" && !isObject2(listener) && (listener = null);
          let listeners = getListeners(this), prev = null, node = listeners.get(eventName);
          for (; node != null; )
            node.listenerType === ATTRIBUTE ? prev !== null ? prev.next = node.next : node.next !== null ? listeners.set(eventName, node.next) : listeners.delete(eventName) : prev = node, node = node.next;
          if (listener !== null) {
            let newNode = {
              listener,
              listenerType: ATTRIBUTE,
              passive: !1,
              once: !1,
              next: null
            };
            prev === null ? listeners.set(eventName, newNode) : prev.next = newNode;
          }
        },
        configurable: !0,
        enumerable: !0
      };
    }
    function defineEventAttribute(eventTargetPrototype, eventName) {
      Object.defineProperty(
        eventTargetPrototype,
        `on${eventName}`,
        defineEventAttributeDescriptor(eventName)
      );
    }
    function defineCustomEventTarget(eventNames) {
      function CustomEventTarget() {
        EventTarget.call(this);
      }
      CustomEventTarget.prototype = Object.create(EventTarget.prototype, {
        constructor: {
          value: CustomEventTarget,
          configurable: !0,
          writable: !0
        }
      });
      for (let i = 0; i < eventNames.length; ++i)
        defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);
      return CustomEventTarget;
    }
    function EventTarget() {
      if (this instanceof EventTarget) {
        listenersMap.set(this, /* @__PURE__ */ new Map());
        return;
      }
      if (arguments.length === 1 && Array.isArray(arguments[0]))
        return defineCustomEventTarget(arguments[0]);
      if (arguments.length > 0) {
        let types = new Array(arguments.length);
        for (let i = 0; i < arguments.length; ++i)
          types[i] = arguments[i];
        return defineCustomEventTarget(types);
      }
      throw new TypeError("Cannot call a class as a function");
    }
    EventTarget.prototype = {
      /**
       * Add a given listener to this event target.
       * @param {string} eventName The event name to add.
       * @param {Function} listener The listener to add.
       * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
       * @returns {void}
       */
      addEventListener(eventName, listener, options) {
        if (listener == null)
          return;
        if (typeof listener != "function" && !isObject2(listener))
          throw new TypeError("'listener' should be a function or an object.");
        let listeners = getListeners(this), optionsIsObj = isObject2(options), listenerType = Boolean(optionsIsObj ? options.capture : options) ? CAPTURE : BUBBLE, newNode = {
          listener,
          listenerType,
          passive: optionsIsObj && Boolean(options.passive),
          once: optionsIsObj && Boolean(options.once),
          next: null
        }, node = listeners.get(eventName);
        if (node === void 0) {
          listeners.set(eventName, newNode);
          return;
        }
        let prev = null;
        for (; node != null; ) {
          if (node.listener === listener && node.listenerType === listenerType)
            return;
          prev = node, node = node.next;
        }
        prev.next = newNode;
      },
      /**
       * Remove a given listener from this event target.
       * @param {string} eventName The event name to remove.
       * @param {Function} listener The listener to remove.
       * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
       * @returns {void}
       */
      removeEventListener(eventName, listener, options) {
        if (listener == null)
          return;
        let listeners = getListeners(this), listenerType = (isObject2(options) ? Boolean(options.capture) : Boolean(options)) ? CAPTURE : BUBBLE, prev = null, node = listeners.get(eventName);
        for (; node != null; ) {
          if (node.listener === listener && node.listenerType === listenerType) {
            prev !== null ? prev.next = node.next : node.next !== null ? listeners.set(eventName, node.next) : listeners.delete(eventName);
            return;
          }
          prev = node, node = node.next;
        }
      },
      /**
       * Dispatch a given event.
       * @param {Event|{type:string}} event The event to dispatch.
       * @returns {boolean} `false` if canceled.
       */
      dispatchEvent(event) {
        if (event == null || typeof event.type != "string")
          throw new TypeError('"event.type" should be a string.');
        let listeners = getListeners(this), eventName = event.type, node = listeners.get(eventName);
        if (node == null)
          return !0;
        let wrappedEvent = wrapEvent(this, event), prev = null;
        for (; node != null; ) {
          if (node.once ? prev !== null ? prev.next = node.next : node.next !== null ? listeners.set(eventName, node.next) : listeners.delete(eventName) : prev = node, setPassiveListener(
            wrappedEvent,
            node.passive ? node.listener : null
          ), typeof node.listener == "function")
            try {
              node.listener.call(this, wrappedEvent);
            } catch (err) {
              typeof console < "u" && typeof console.error == "function" && console.error(err);
            }
          else
            node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent == "function" && node.listener.handleEvent(wrappedEvent);
          if (isStopped(wrappedEvent))
            break;
          node = node.next;
        }
        return setPassiveListener(wrappedEvent, null), setEventPhase(wrappedEvent, 0), setCurrentTarget(wrappedEvent, null), !wrappedEvent.defaultPrevented;
      }
    };
    Object.defineProperty(EventTarget.prototype, "constructor", {
      value: EventTarget,
      configurable: !0,
      writable: !0
    });
    typeof window < "u" && typeof window.EventTarget < "u" && Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);
    exports.defineEventAttribute = defineEventAttribute;
    exports.EventTarget = EventTarget;
    exports.default = EventTarget;
    module2.exports = EventTarget;
    module2.exports.EventTarget = module2.exports.default = EventTarget;
    module2.exports.defineEventAttribute = defineEventAttribute;
  }
});

// node_modules/abort-controller/dist/abort-controller.js
var require_abort_controller = __commonJS({
  "node_modules/abort-controller/dist/abort-controller.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var eventTargetShim = require_event_target_shim(), AbortSignal = class extends eventTargetShim.EventTarget {
      /**
       * AbortSignal cannot be constructed directly.
       */
      constructor() {
        throw super(), new TypeError("AbortSignal cannot be constructed directly");
      }
      /**
       * Returns `true` if this `AbortSignal`'s `AbortController` has signaled to abort, and `false` otherwise.
       */
      get aborted() {
        let aborted = abortedFlags.get(this);
        if (typeof aborted != "boolean")
          throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? "null" : typeof this}`);
        return aborted;
      }
    };
    eventTargetShim.defineEventAttribute(AbortSignal.prototype, "abort");
    function createAbortSignal() {
      let signal = Object.create(AbortSignal.prototype);
      return eventTargetShim.EventTarget.call(signal), abortedFlags.set(signal, !1), signal;
    }
    function abortSignal(signal) {
      abortedFlags.get(signal) === !1 && (abortedFlags.set(signal, !0), signal.dispatchEvent({ type: "abort" }));
    }
    var abortedFlags = /* @__PURE__ */ new WeakMap();
    Object.defineProperties(AbortSignal.prototype, {
      aborted: { enumerable: !0 }
    });
    typeof Symbol == "function" && typeof Symbol.toStringTag == "symbol" && Object.defineProperty(AbortSignal.prototype, Symbol.toStringTag, {
      configurable: !0,
      value: "AbortSignal"
    });
    var AbortController2 = class {
      /**
       * Initialize this controller.
       */
      constructor() {
        signals.set(this, createAbortSignal());
      }
      /**
       * Returns the `AbortSignal` object associated with this object.
       */
      get signal() {
        return getSignal(this);
      }
      /**
       * Abort and signal to any observers that the associated activity is to be aborted.
       */
      abort() {
        abortSignal(getSignal(this));
      }
    }, signals = /* @__PURE__ */ new WeakMap();
    function getSignal(controller) {
      let signal = signals.get(controller);
      if (signal == null)
        throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${controller === null ? "null" : typeof controller}`);
      return signal;
    }
    Object.defineProperties(AbortController2.prototype, {
      signal: { enumerable: !0 },
      abort: { enumerable: !0 }
    });
    typeof Symbol == "function" && typeof Symbol.toStringTag == "symbol" && Object.defineProperty(AbortController2.prototype, Symbol.toStringTag, {
      configurable: !0,
      value: "AbortController"
    });
    exports.AbortController = AbortController2;
    exports.AbortSignal = AbortSignal;
    exports.default = AbortController2;
    module2.exports = AbortController2;
    module2.exports.AbortController = module2.exports.default = AbortController2;
    module2.exports.AbortSignal = AbortSignal;
  }
});

// node_modules/mrmime/index.js
var require_mrmime = __commonJS({
  "node_modules/mrmime/index.js"(exports) {
    var mimes = {
      ez: "application/andrew-inset",
      aw: "application/applixware",
      atom: "application/atom+xml",
      atomcat: "application/atomcat+xml",
      atomdeleted: "application/atomdeleted+xml",
      atomsvc: "application/atomsvc+xml",
      dwd: "application/atsc-dwd+xml",
      held: "application/atsc-held+xml",
      rsat: "application/atsc-rsat+xml",
      bdoc: "application/bdoc",
      xcs: "application/calendar+xml",
      ccxml: "application/ccxml+xml",
      cdfx: "application/cdfx+xml",
      cdmia: "application/cdmi-capability",
      cdmic: "application/cdmi-container",
      cdmid: "application/cdmi-domain",
      cdmio: "application/cdmi-object",
      cdmiq: "application/cdmi-queue",
      cu: "application/cu-seeme",
      mpd: "application/dash+xml",
      davmount: "application/davmount+xml",
      dbk: "application/docbook+xml",
      dssc: "application/dssc+der",
      xdssc: "application/dssc+xml",
      es: "application/ecmascript",
      ecma: "application/ecmascript",
      emma: "application/emma+xml",
      emotionml: "application/emotionml+xml",
      epub: "application/epub+zip",
      exi: "application/exi",
      fdt: "application/fdt+xml",
      pfr: "application/font-tdpfr",
      geojson: "application/geo+json",
      gml: "application/gml+xml",
      gpx: "application/gpx+xml",
      gxf: "application/gxf",
      gz: "application/gzip",
      hjson: "application/hjson",
      stk: "application/hyperstudio",
      ink: "application/inkml+xml",
      inkml: "application/inkml+xml",
      ipfix: "application/ipfix",
      its: "application/its+xml",
      jar: "application/java-archive",
      war: "application/java-archive",
      ear: "application/java-archive",
      ser: "application/java-serialized-object",
      class: "application/java-vm",
      js: "application/javascript",
      mjs: "application/javascript",
      json: "application/json",
      map: "application/json",
      json5: "application/json5",
      jsonml: "application/jsonml+json",
      jsonld: "application/ld+json",
      lgr: "application/lgr+xml",
      lostxml: "application/lost+xml",
      hqx: "application/mac-binhex40",
      cpt: "application/mac-compactpro",
      mads: "application/mads+xml",
      webmanifest: "application/manifest+json",
      mrc: "application/marc",
      mrcx: "application/marcxml+xml",
      ma: "application/mathematica",
      nb: "application/mathematica",
      mb: "application/mathematica",
      mathml: "application/mathml+xml",
      mbox: "application/mbox",
      mscml: "application/mediaservercontrol+xml",
      metalink: "application/metalink+xml",
      meta4: "application/metalink4+xml",
      mets: "application/mets+xml",
      maei: "application/mmt-aei+xml",
      musd: "application/mmt-usd+xml",
      mods: "application/mods+xml",
      m21: "application/mp21",
      mp21: "application/mp21",
      mp4s: "application/mp4",
      m4p: "application/mp4",
      doc: "application/msword",
      dot: "application/msword",
      mxf: "application/mxf",
      nq: "application/n-quads",
      nt: "application/n-triples",
      cjs: "application/node",
      bin: "application/octet-stream",
      dms: "application/octet-stream",
      lrf: "application/octet-stream",
      mar: "application/octet-stream",
      so: "application/octet-stream",
      dist: "application/octet-stream",
      distz: "application/octet-stream",
      pkg: "application/octet-stream",
      bpk: "application/octet-stream",
      dump: "application/octet-stream",
      elc: "application/octet-stream",
      deploy: "application/octet-stream",
      exe: "application/octet-stream",
      dll: "application/octet-stream",
      deb: "application/octet-stream",
      dmg: "application/octet-stream",
      iso: "application/octet-stream",
      img: "application/octet-stream",
      msi: "application/octet-stream",
      msp: "application/octet-stream",
      msm: "application/octet-stream",
      buffer: "application/octet-stream",
      oda: "application/oda",
      opf: "application/oebps-package+xml",
      ogx: "application/ogg",
      omdoc: "application/omdoc+xml",
      onetoc: "application/onenote",
      onetoc2: "application/onenote",
      onetmp: "application/onenote",
      onepkg: "application/onenote",
      oxps: "application/oxps",
      relo: "application/p2p-overlay+xml",
      xer: "application/patch-ops-error+xml",
      pdf: "application/pdf",
      pgp: "application/pgp-encrypted",
      asc: "application/pgp-signature",
      sig: "application/pgp-signature",
      prf: "application/pics-rules",
      p10: "application/pkcs10",
      p7m: "application/pkcs7-mime",
      p7c: "application/pkcs7-mime",
      p7s: "application/pkcs7-signature",
      p8: "application/pkcs8",
      ac: "application/pkix-attr-cert",
      cer: "application/pkix-cert",
      crl: "application/pkix-crl",
      pkipath: "application/pkix-pkipath",
      pki: "application/pkixcmp",
      pls: "application/pls+xml",
      ai: "application/postscript",
      eps: "application/postscript",
      ps: "application/postscript",
      provx: "application/provenance+xml",
      cww: "application/prs.cww",
      pskcxml: "application/pskc+xml",
      raml: "application/raml+yaml",
      rdf: "application/rdf+xml",
      owl: "application/rdf+xml",
      rif: "application/reginfo+xml",
      rnc: "application/relax-ng-compact-syntax",
      rl: "application/resource-lists+xml",
      rld: "application/resource-lists-diff+xml",
      rs: "application/rls-services+xml",
      rapd: "application/route-apd+xml",
      sls: "application/route-s-tsid+xml",
      rusd: "application/route-usd+xml",
      gbr: "application/rpki-ghostbusters",
      mft: "application/rpki-manifest",
      roa: "application/rpki-roa",
      rsd: "application/rsd+xml",
      rss: "application/rss+xml",
      rtf: "application/rtf",
      sbml: "application/sbml+xml",
      scq: "application/scvp-cv-request",
      scs: "application/scvp-cv-response",
      spq: "application/scvp-vp-request",
      spp: "application/scvp-vp-response",
      sdp: "application/sdp",
      senmlx: "application/senml+xml",
      sensmlx: "application/sensml+xml",
      setpay: "application/set-payment-initiation",
      setreg: "application/set-registration-initiation",
      shf: "application/shf+xml",
      siv: "application/sieve",
      sieve: "application/sieve",
      smi: "application/smil+xml",
      smil: "application/smil+xml",
      rq: "application/sparql-query",
      srx: "application/sparql-results+xml",
      gram: "application/srgs",
      grxml: "application/srgs+xml",
      sru: "application/sru+xml",
      ssdl: "application/ssdl+xml",
      ssml: "application/ssml+xml",
      swidtag: "application/swid+xml",
      tei: "application/tei+xml",
      teicorpus: "application/tei+xml",
      tfi: "application/thraud+xml",
      tsd: "application/timestamped-data",
      toml: "application/toml",
      trig: "application/trig",
      ttml: "application/ttml+xml",
      ubj: "application/ubjson",
      rsheet: "application/urc-ressheet+xml",
      td: "application/urc-targetdesc+xml",
      vxml: "application/voicexml+xml",
      wasm: "application/wasm",
      wgt: "application/widget",
      hlp: "application/winhlp",
      wsdl: "application/wsdl+xml",
      wspolicy: "application/wspolicy+xml",
      xaml: "application/xaml+xml",
      xav: "application/xcap-att+xml",
      xca: "application/xcap-caps+xml",
      xdf: "application/xcap-diff+xml",
      xel: "application/xcap-el+xml",
      xns: "application/xcap-ns+xml",
      xenc: "application/xenc+xml",
      xhtml: "application/xhtml+xml",
      xht: "application/xhtml+xml",
      xlf: "application/xliff+xml",
      xml: "application/xml",
      xsl: "application/xml",
      xsd: "application/xml",
      rng: "application/xml",
      dtd: "application/xml-dtd",
      xop: "application/xop+xml",
      xpl: "application/xproc+xml",
      xslt: "application/xml",
      xspf: "application/xspf+xml",
      mxml: "application/xv+xml",
      xhvml: "application/xv+xml",
      xvml: "application/xv+xml",
      xvm: "application/xv+xml",
      yang: "application/yang",
      yin: "application/yin+xml",
      zip: "application/zip",
      "3gpp": "video/3gpp",
      adp: "audio/adpcm",
      amr: "audio/amr",
      au: "audio/basic",
      snd: "audio/basic",
      mid: "audio/midi",
      midi: "audio/midi",
      kar: "audio/midi",
      rmi: "audio/midi",
      mxmf: "audio/mobile-xmf",
      mp3: "audio/mpeg",
      m4a: "audio/mp4",
      mp4a: "audio/mp4",
      mpga: "audio/mpeg",
      mp2: "audio/mpeg",
      mp2a: "audio/mpeg",
      m2a: "audio/mpeg",
      m3a: "audio/mpeg",
      oga: "audio/ogg",
      ogg: "audio/ogg",
      spx: "audio/ogg",
      opus: "audio/ogg",
      s3m: "audio/s3m",
      sil: "audio/silk",
      wav: "audio/wav",
      weba: "audio/webm",
      xm: "audio/xm",
      ttc: "font/collection",
      otf: "font/otf",
      ttf: "font/ttf",
      woff: "font/woff",
      woff2: "font/woff2",
      exr: "image/aces",
      apng: "image/apng",
      avif: "image/avif",
      bmp: "image/bmp",
      cgm: "image/cgm",
      drle: "image/dicom-rle",
      emf: "image/emf",
      fits: "image/fits",
      g3: "image/g3fax",
      gif: "image/gif",
      heic: "image/heic",
      heics: "image/heic-sequence",
      heif: "image/heif",
      heifs: "image/heif-sequence",
      hej2: "image/hej2k",
      hsj2: "image/hsj2",
      ief: "image/ief",
      jls: "image/jls",
      jp2: "image/jp2",
      jpg2: "image/jp2",
      jpeg: "image/jpeg",
      jpg: "image/jpeg",
      jpe: "image/jpeg",
      jph: "image/jph",
      jhc: "image/jphc",
      jpm: "image/jpm",
      jpx: "image/jpx",
      jpf: "image/jpx",
      jxr: "image/jxr",
      jxra: "image/jxra",
      jxrs: "image/jxrs",
      jxs: "image/jxs",
      jxsc: "image/jxsc",
      jxsi: "image/jxsi",
      jxss: "image/jxss",
      ktx: "image/ktx",
      ktx2: "image/ktx2",
      png: "image/png",
      btif: "image/prs.btif",
      pti: "image/prs.pti",
      sgi: "image/sgi",
      svg: "image/svg+xml",
      svgz: "image/svg+xml",
      t38: "image/t38",
      tif: "image/tiff",
      tiff: "image/tiff",
      tfx: "image/tiff-fx",
      webp: "image/webp",
      wmf: "image/wmf",
      "disposition-notification": "message/disposition-notification",
      u8msg: "message/global",
      u8dsn: "message/global-delivery-status",
      u8mdn: "message/global-disposition-notification",
      u8hdr: "message/global-headers",
      eml: "message/rfc822",
      mime: "message/rfc822",
      "3mf": "model/3mf",
      gltf: "model/gltf+json",
      glb: "model/gltf-binary",
      igs: "model/iges",
      iges: "model/iges",
      msh: "model/mesh",
      mesh: "model/mesh",
      silo: "model/mesh",
      mtl: "model/mtl",
      obj: "model/obj",
      stpz: "model/step+zip",
      stpxz: "model/step-xml+zip",
      stl: "model/stl",
      wrl: "model/vrml",
      vrml: "model/vrml",
      x3db: "model/x3d+fastinfoset",
      x3dbz: "model/x3d+binary",
      x3dv: "model/x3d-vrml",
      x3dvz: "model/x3d+vrml",
      x3d: "model/x3d+xml",
      x3dz: "model/x3d+xml",
      appcache: "text/cache-manifest",
      manifest: "text/cache-manifest",
      ics: "text/calendar",
      ifb: "text/calendar",
      coffee: "text/coffeescript",
      litcoffee: "text/coffeescript",
      css: "text/css",
      csv: "text/csv",
      html: "text/html",
      htm: "text/html",
      shtml: "text/html",
      jade: "text/jade",
      jsx: "text/jsx",
      less: "text/less",
      markdown: "text/markdown",
      md: "text/markdown",
      mml: "text/mathml",
      mdx: "text/mdx",
      n3: "text/n3",
      txt: "text/plain",
      text: "text/plain",
      conf: "text/plain",
      def: "text/plain",
      list: "text/plain",
      log: "text/plain",
      in: "text/plain",
      ini: "text/plain",
      dsc: "text/prs.lines.tag",
      rtx: "text/richtext",
      sgml: "text/sgml",
      sgm: "text/sgml",
      shex: "text/shex",
      slim: "text/slim",
      slm: "text/slim",
      spdx: "text/spdx",
      stylus: "text/stylus",
      styl: "text/stylus",
      tsv: "text/tab-separated-values",
      t: "text/troff",
      tr: "text/troff",
      roff: "text/troff",
      man: "text/troff",
      me: "text/troff",
      ms: "text/troff",
      ttl: "text/turtle",
      uri: "text/uri-list",
      uris: "text/uri-list",
      urls: "text/uri-list",
      vcard: "text/vcard",
      vtt: "text/vtt",
      yaml: "text/yaml",
      yml: "text/yaml",
      "3gp": "video/3gpp",
      "3g2": "video/3gpp2",
      h261: "video/h261",
      h263: "video/h263",
      h264: "video/h264",
      m4s: "video/iso.segment",
      jpgv: "video/jpeg",
      jpgm: "image/jpm",
      mj2: "video/mj2",
      mjp2: "video/mj2",
      ts: "video/mp2t",
      mp4: "video/mp4",
      mp4v: "video/mp4",
      mpg4: "video/mp4",
      mpeg: "video/mpeg",
      mpg: "video/mpeg",
      mpe: "video/mpeg",
      m1v: "video/mpeg",
      m2v: "video/mpeg",
      ogv: "video/ogg",
      qt: "video/quicktime",
      mov: "video/quicktime",
      webm: "video/webm"
    };
    function lookup(extn) {
      let tmp = ("" + extn).trim().toLowerCase(), idx = tmp.lastIndexOf(".");
      return mimes[~idx ? tmp.substring(++idx) : tmp];
    }
    exports.lookup = lookup;
    exports.mimes = mimes;
  }
});

// node_modules/data-uri-to-buffer/dist/src/index.js
var require_src = __commonJS({
  "node_modules/data-uri-to-buffer/dist/src/index.js"(exports, module2) {
    "use strict";
    function dataUriToBuffer(uri) {
      if (!/^data:/i.test(uri))
        throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
      uri = uri.replace(/\r?\n/g, "");
      let firstComma = uri.indexOf(",");
      if (firstComma === -1 || firstComma <= 4)
        throw new TypeError("malformed data: URI");
      let meta = uri.substring(5, firstComma).split(";"), charset = "", base64 = !1, type = meta[0] || "text/plain", typeFull = type;
      for (let i = 1; i < meta.length; i++)
        meta[i] === "base64" ? base64 = !0 : (typeFull += `;${meta[i]}`, meta[i].indexOf("charset=") === 0 && (charset = meta[i].substring(8)));
      !meta[0] && !charset.length && (typeFull += ";charset=US-ASCII", charset = "US-ASCII");
      let encoding = base64 ? "base64" : "ascii", data = unescape(uri.substring(firstComma + 1)), buffer = Buffer.from(data, encoding);
      return buffer.type = type, buffer.typeFull = typeFull, buffer.charset = charset, buffer;
    }
    module2.exports = dataUriToBuffer;
  }
});

// node_modules/web-encoding/src/lib.js
var require_lib = __commonJS({
  "node_modules/web-encoding/src/lib.js"(exports) {
    "use strict";
    exports.TextEncoder = typeof TextEncoder < "u" ? TextEncoder : require("util").TextEncoder;
    exports.TextDecoder = typeof TextDecoder < "u" ? TextDecoder : require("util").TextDecoder;
  }
});

// node_modules/web-streams-polyfill/dist/ponyfill.js
var require_ponyfill = __commonJS({
  "node_modules/web-streams-polyfill/dist/ponyfill.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports == "object" && typeof module2 < "u" ? factory(exports) : typeof define == "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis < "u" ? globalThis : global2 || self, factory(global2.WebStreamsPolyfill = {}));
    })(exports, function(exports2) {
      "use strict";
      var SymbolPolyfill = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol : function(description) {
        return "Symbol(" + description + ")";
      };
      function noop2() {
      }
      function getGlobals() {
        if (typeof self < "u")
          return self;
        if (typeof window < "u")
          return window;
        if (typeof global < "u")
          return global;
      }
      var globals = getGlobals();
      function typeIsObject(x) {
        return typeof x == "object" && x !== null || typeof x == "function";
      }
      var rethrowAssertionErrorRejection = noop2, originalPromise = Promise, originalPromiseThen = Promise.prototype.then, originalPromiseResolve = Promise.resolve.bind(originalPromise), originalPromiseReject = Promise.reject.bind(originalPromise);
      function newPromise(executor) {
        return new originalPromise(executor);
      }
      function promiseResolvedWith(value) {
        return originalPromiseResolve(value);
      }
      function promiseRejectedWith(reason) {
        return originalPromiseReject(reason);
      }
      function PerformPromiseThen(promise, onFulfilled, onRejected) {
        return originalPromiseThen.call(promise, onFulfilled, onRejected);
      }
      function uponPromise(promise, onFulfilled, onRejected) {
        PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), void 0, rethrowAssertionErrorRejection);
      }
      function uponFulfillment(promise, onFulfilled) {
        uponPromise(promise, onFulfilled);
      }
      function uponRejection(promise, onRejected) {
        uponPromise(promise, void 0, onRejected);
      }
      function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
        return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
      }
      function setPromiseIsHandledToTrue(promise) {
        PerformPromiseThen(promise, void 0, rethrowAssertionErrorRejection);
      }
      var queueMicrotask = function() {
        var globalQueueMicrotask = globals && globals.queueMicrotask;
        if (typeof globalQueueMicrotask == "function")
          return globalQueueMicrotask;
        var resolvedPromise = promiseResolvedWith(void 0);
        return function(fn) {
          return PerformPromiseThen(resolvedPromise, fn);
        };
      }();
      function reflectCall(F, V, args) {
        if (typeof F != "function")
          throw new TypeError("Argument is not a function");
        return Function.prototype.apply.call(F, V, args);
      }
      function promiseCall(F, V, args) {
        try {
          return promiseResolvedWith(reflectCall(F, V, args));
        } catch (value) {
          return promiseRejectedWith(value);
        }
      }
      var QUEUE_MAX_ARRAY_SIZE = 16384, SimpleQueue = (
        /** @class */
        function() {
          function SimpleQueue2() {
            this._cursor = 0, this._size = 0, this._front = {
              _elements: [],
              _next: void 0
            }, this._back = this._front, this._cursor = 0, this._size = 0;
          }
          return Object.defineProperty(SimpleQueue2.prototype, "length", {
            get: function() {
              return this._size;
            },
            enumerable: !1,
            configurable: !0
          }), SimpleQueue2.prototype.push = function(element) {
            var oldBack = this._back, newBack = oldBack;
            oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1 && (newBack = {
              _elements: [],
              _next: void 0
            }), oldBack._elements.push(element), newBack !== oldBack && (this._back = newBack, oldBack._next = newBack), ++this._size;
          }, SimpleQueue2.prototype.shift = function() {
            var oldFront = this._front, newFront = oldFront, oldCursor = this._cursor, newCursor = oldCursor + 1, elements = oldFront._elements, element = elements[oldCursor];
            return newCursor === QUEUE_MAX_ARRAY_SIZE && (newFront = oldFront._next, newCursor = 0), --this._size, this._cursor = newCursor, oldFront !== newFront && (this._front = newFront), elements[oldCursor] = void 0, element;
          }, SimpleQueue2.prototype.forEach = function(callback) {
            for (var i = this._cursor, node = this._front, elements = node._elements; (i !== elements.length || node._next !== void 0) && !(i === elements.length && (node = node._next, elements = node._elements, i = 0, elements.length === 0)); )
              callback(elements[i]), ++i;
          }, SimpleQueue2.prototype.peek = function() {
            var front = this._front, cursor = this._cursor;
            return front._elements[cursor];
          }, SimpleQueue2;
        }()
      );
      function ReadableStreamReaderGenericInitialize(reader, stream4) {
        reader._ownerReadableStream = stream4, stream4._reader = reader, stream4._state === "readable" ? defaultReaderClosedPromiseInitialize(reader) : stream4._state === "closed" ? defaultReaderClosedPromiseInitializeAsResolved(reader) : defaultReaderClosedPromiseInitializeAsRejected(reader, stream4._storedError);
      }
      function ReadableStreamReaderGenericCancel(reader, reason) {
        var stream4 = reader._ownerReadableStream;
        return ReadableStreamCancel(stream4, reason);
      }
      function ReadableStreamReaderGenericRelease(reader) {
        reader._ownerReadableStream._state === "readable" ? defaultReaderClosedPromiseReject(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")) : defaultReaderClosedPromiseResetToRejected(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")), reader._ownerReadableStream._reader = void 0, reader._ownerReadableStream = void 0;
      }
      function readerLockException(name) {
        return new TypeError("Cannot " + name + " a stream using a released reader");
      }
      function defaultReaderClosedPromiseInitialize(reader) {
        reader._closedPromise = newPromise(function(resolve, reject) {
          reader._closedPromise_resolve = resolve, reader._closedPromise_reject = reject;
        });
      }
      function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
        defaultReaderClosedPromiseInitialize(reader), defaultReaderClosedPromiseReject(reader, reason);
      }
      function defaultReaderClosedPromiseInitializeAsResolved(reader) {
        defaultReaderClosedPromiseInitialize(reader), defaultReaderClosedPromiseResolve(reader);
      }
      function defaultReaderClosedPromiseReject(reader, reason) {
        reader._closedPromise_reject !== void 0 && (setPromiseIsHandledToTrue(reader._closedPromise), reader._closedPromise_reject(reason), reader._closedPromise_resolve = void 0, reader._closedPromise_reject = void 0);
      }
      function defaultReaderClosedPromiseResetToRejected(reader, reason) {
        defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
      }
      function defaultReaderClosedPromiseResolve(reader) {
        reader._closedPromise_resolve !== void 0 && (reader._closedPromise_resolve(void 0), reader._closedPromise_resolve = void 0, reader._closedPromise_reject = void 0);
      }
      var AbortSteps = SymbolPolyfill("[[AbortSteps]]"), ErrorSteps = SymbolPolyfill("[[ErrorSteps]]"), CancelSteps = SymbolPolyfill("[[CancelSteps]]"), PullSteps = SymbolPolyfill("[[PullSteps]]"), NumberIsFinite = Number.isFinite || function(x) {
        return typeof x == "number" && isFinite(x);
      }, MathTrunc = Math.trunc || function(v) {
        return v < 0 ? Math.ceil(v) : Math.floor(v);
      };
      function isDictionary(x) {
        return typeof x == "object" || typeof x == "function";
      }
      function assertDictionary(obj, context) {
        if (obj !== void 0 && !isDictionary(obj))
          throw new TypeError(context + " is not an object.");
      }
      function assertFunction(x, context) {
        if (typeof x != "function")
          throw new TypeError(context + " is not a function.");
      }
      function isObject2(x) {
        return typeof x == "object" && x !== null || typeof x == "function";
      }
      function assertObject(x, context) {
        if (!isObject2(x))
          throw new TypeError(context + " is not an object.");
      }
      function assertRequiredArgument(x, position, context) {
        if (x === void 0)
          throw new TypeError("Parameter " + position + " is required in '" + context + "'.");
      }
      function assertRequiredField(x, field, context) {
        if (x === void 0)
          throw new TypeError(field + " is required in '" + context + "'.");
      }
      function convertUnrestrictedDouble(value) {
        return Number(value);
      }
      function censorNegativeZero(x) {
        return x === 0 ? 0 : x;
      }
      function integerPart(x) {
        return censorNegativeZero(MathTrunc(x));
      }
      function convertUnsignedLongLongWithEnforceRange(value, context) {
        var lowerBound = 0, upperBound = Number.MAX_SAFE_INTEGER, x = Number(value);
        if (x = censorNegativeZero(x), !NumberIsFinite(x))
          throw new TypeError(context + " is not a finite number");
        if (x = integerPart(x), x < lowerBound || x > upperBound)
          throw new TypeError(context + " is outside the accepted range of " + lowerBound + " to " + upperBound + ", inclusive");
        return !NumberIsFinite(x) || x === 0 ? 0 : x;
      }
      function assertReadableStream(x, context) {
        if (!IsReadableStream(x))
          throw new TypeError(context + " is not a ReadableStream.");
      }
      function AcquireReadableStreamDefaultReader(stream4) {
        return new ReadableStreamDefaultReader(stream4);
      }
      function ReadableStreamAddReadRequest(stream4, readRequest) {
        stream4._reader._readRequests.push(readRequest);
      }
      function ReadableStreamFulfillReadRequest(stream4, chunk, done) {
        var reader = stream4._reader, readRequest = reader._readRequests.shift();
        done ? readRequest._closeSteps() : readRequest._chunkSteps(chunk);
      }
      function ReadableStreamGetNumReadRequests(stream4) {
        return stream4._reader._readRequests.length;
      }
      function ReadableStreamHasDefaultReader(stream4) {
        var reader = stream4._reader;
        return !(reader === void 0 || !IsReadableStreamDefaultReader(reader));
      }
      var ReadableStreamDefaultReader = (
        /** @class */
        function() {
          function ReadableStreamDefaultReader2(stream4) {
            if (assertRequiredArgument(stream4, 1, "ReadableStreamDefaultReader"), assertReadableStream(stream4, "First parameter"), IsReadableStreamLocked(stream4))
              throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            ReadableStreamReaderGenericInitialize(this, stream4), this._readRequests = new SimpleQueue();
          }
          return Object.defineProperty(ReadableStreamDefaultReader2.prototype, "closed", {
            /**
             * Returns a promise that will be fulfilled when the stream becomes closed,
             * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.
             */
            get: function() {
              return IsReadableStreamDefaultReader(this) ? this._closedPromise : promiseRejectedWith(defaultReaderBrandCheckException("closed"));
            },
            enumerable: !1,
            configurable: !0
          }), ReadableStreamDefaultReader2.prototype.cancel = function(reason) {
            return reason === void 0 && (reason = void 0), IsReadableStreamDefaultReader(this) ? this._ownerReadableStream === void 0 ? promiseRejectedWith(readerLockException("cancel")) : ReadableStreamReaderGenericCancel(this, reason) : promiseRejectedWith(defaultReaderBrandCheckException("cancel"));
          }, ReadableStreamDefaultReader2.prototype.read = function() {
            if (!IsReadableStreamDefaultReader(this))
              return promiseRejectedWith(defaultReaderBrandCheckException("read"));
            if (this._ownerReadableStream === void 0)
              return promiseRejectedWith(readerLockException("read from"));
            var resolvePromise, rejectPromise, promise = newPromise(function(resolve, reject) {
              resolvePromise = resolve, rejectPromise = reject;
            }), readRequest = {
              _chunkSteps: function(chunk) {
                return resolvePromise({ value: chunk, done: !1 });
              },
              _closeSteps: function() {
                return resolvePromise({ value: void 0, done: !0 });
              },
              _errorSteps: function(e) {
                return rejectPromise(e);
              }
            };
            return ReadableStreamDefaultReaderRead(this, readRequest), promise;
          }, ReadableStreamDefaultReader2.prototype.releaseLock = function() {
            if (!IsReadableStreamDefaultReader(this))
              throw defaultReaderBrandCheckException("releaseLock");
            if (this._ownerReadableStream !== void 0) {
              if (this._readRequests.length > 0)
                throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
              ReadableStreamReaderGenericRelease(this);
            }
          }, ReadableStreamDefaultReader2;
        }()
      );
      Object.defineProperties(ReadableStreamDefaultReader.prototype, {
        cancel: { enumerable: !0 },
        read: { enumerable: !0 },
        releaseLock: { enumerable: !0 },
        closed: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableStreamDefaultReader",
        configurable: !0
      });
      function IsReadableStreamDefaultReader(x) {
        return !typeIsObject(x) || !Object.prototype.hasOwnProperty.call(x, "_readRequests") ? !1 : x instanceof ReadableStreamDefaultReader;
      }
      function ReadableStreamDefaultReaderRead(reader, readRequest) {
        var stream4 = reader._ownerReadableStream;
        stream4._disturbed = !0, stream4._state === "closed" ? readRequest._closeSteps() : stream4._state === "errored" ? readRequest._errorSteps(stream4._storedError) : stream4._readableStreamController[PullSteps](readRequest);
      }
      function defaultReaderBrandCheckException(name) {
        return new TypeError("ReadableStreamDefaultReader.prototype." + name + " can only be used on a ReadableStreamDefaultReader");
      }
      var _a, AsyncIteratorPrototype;
      typeof SymbolPolyfill.asyncIterator == "symbol" && (AsyncIteratorPrototype = (_a = {}, // 25.1.3.1 %AsyncIteratorPrototype% [ @@asyncIterator ] ( )
      // https://tc39.github.io/ecma262/#sec-asynciteratorprototype-asynciterator
      _a[SymbolPolyfill.asyncIterator] = function() {
        return this;
      }, _a), Object.defineProperty(AsyncIteratorPrototype, SymbolPolyfill.asyncIterator, { enumerable: !1 }));
      var ReadableStreamAsyncIteratorImpl = (
        /** @class */
        function() {
          function ReadableStreamAsyncIteratorImpl2(reader, preventCancel) {
            this._ongoingPromise = void 0, this._isFinished = !1, this._reader = reader, this._preventCancel = preventCancel;
          }
          return ReadableStreamAsyncIteratorImpl2.prototype.next = function() {
            var _this = this, nextSteps = function() {
              return _this._nextSteps();
            };
            return this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps(), this._ongoingPromise;
          }, ReadableStreamAsyncIteratorImpl2.prototype.return = function(value) {
            var _this = this, returnSteps = function() {
              return _this._returnSteps(value);
            };
            return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
          }, ReadableStreamAsyncIteratorImpl2.prototype._nextSteps = function() {
            var _this = this;
            if (this._isFinished)
              return Promise.resolve({ value: void 0, done: !0 });
            var reader = this._reader;
            if (reader._ownerReadableStream === void 0)
              return promiseRejectedWith(readerLockException("iterate"));
            var resolvePromise, rejectPromise, promise = newPromise(function(resolve, reject) {
              resolvePromise = resolve, rejectPromise = reject;
            }), readRequest = {
              _chunkSteps: function(chunk) {
                _this._ongoingPromise = void 0, queueMicrotask(function() {
                  return resolvePromise({ value: chunk, done: !1 });
                });
              },
              _closeSteps: function() {
                _this._ongoingPromise = void 0, _this._isFinished = !0, ReadableStreamReaderGenericRelease(reader), resolvePromise({ value: void 0, done: !0 });
              },
              _errorSteps: function(reason) {
                _this._ongoingPromise = void 0, _this._isFinished = !0, ReadableStreamReaderGenericRelease(reader), rejectPromise(reason);
              }
            };
            return ReadableStreamDefaultReaderRead(reader, readRequest), promise;
          }, ReadableStreamAsyncIteratorImpl2.prototype._returnSteps = function(value) {
            if (this._isFinished)
              return Promise.resolve({ value, done: !0 });
            this._isFinished = !0;
            var reader = this._reader;
            if (reader._ownerReadableStream === void 0)
              return promiseRejectedWith(readerLockException("finish iterating"));
            if (!this._preventCancel) {
              var result = ReadableStreamReaderGenericCancel(reader, value);
              return ReadableStreamReaderGenericRelease(reader), transformPromiseWith(result, function() {
                return { value, done: !0 };
              });
            }
            return ReadableStreamReaderGenericRelease(reader), promiseResolvedWith({ value, done: !0 });
          }, ReadableStreamAsyncIteratorImpl2;
        }()
      ), ReadableStreamAsyncIteratorPrototype = {
        next: function() {
          return IsReadableStreamAsyncIterator(this) ? this._asyncIteratorImpl.next() : promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
        },
        return: function(value) {
          return IsReadableStreamAsyncIterator(this) ? this._asyncIteratorImpl.return(value) : promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"));
        }
      };
      AsyncIteratorPrototype !== void 0 && Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
      function AcquireReadableStreamAsyncIterator(stream4, preventCancel) {
        var reader = AcquireReadableStreamDefaultReader(stream4), impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel), iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
        return iterator._asyncIteratorImpl = impl, iterator;
      }
      function IsReadableStreamAsyncIterator(x) {
        if (!typeIsObject(x) || !Object.prototype.hasOwnProperty.call(x, "_asyncIteratorImpl"))
          return !1;
        try {
          return x._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
        } catch {
          return !1;
        }
      }
      function streamAsyncIteratorBrandCheckException(name) {
        return new TypeError("ReadableStreamAsyncIterator." + name + " can only be used on a ReadableSteamAsyncIterator");
      }
      var NumberIsNaN = Number.isNaN || function(x) {
        return x !== x;
      };
      function CreateArrayFromList(elements) {
        return elements.slice();
      }
      function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {
        new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
      }
      function TransferArrayBuffer(O) {
        return O;
      }
      function IsDetachedBuffer(O) {
        return !1;
      }
      function ArrayBufferSlice(buffer, begin, end) {
        if (buffer.slice)
          return buffer.slice(begin, end);
        var length = end - begin, slice = new ArrayBuffer(length);
        return CopyDataBlockBytes(slice, 0, buffer, begin, length), slice;
      }
      function IsNonNegativeNumber(v) {
        return !(typeof v != "number" || NumberIsNaN(v) || v < 0);
      }
      function CloneAsUint8Array(O) {
        var buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
        return new Uint8Array(buffer);
      }
      function DequeueValue(container) {
        var pair = container._queue.shift();
        return container._queueTotalSize -= pair.size, container._queueTotalSize < 0 && (container._queueTotalSize = 0), pair.value;
      }
      function EnqueueValueWithSize(container, value, size) {
        if (!IsNonNegativeNumber(size) || size === 1 / 0)
          throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
        container._queue.push({ value, size }), container._queueTotalSize += size;
      }
      function PeekQueueValue(container) {
        var pair = container._queue.peek();
        return pair.value;
      }
      function ResetQueue(container) {
        container._queue = new SimpleQueue(), container._queueTotalSize = 0;
      }
      var ReadableStreamBYOBRequest = (
        /** @class */
        function() {
          function ReadableStreamBYOBRequest2() {
            throw new TypeError("Illegal constructor");
          }
          return Object.defineProperty(ReadableStreamBYOBRequest2.prototype, "view", {
            /**
             * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.
             */
            get: function() {
              if (!IsReadableStreamBYOBRequest(this))
                throw byobRequestBrandCheckException("view");
              return this._view;
            },
            enumerable: !1,
            configurable: !0
          }), ReadableStreamBYOBRequest2.prototype.respond = function(bytesWritten) {
            if (!IsReadableStreamBYOBRequest(this))
              throw byobRequestBrandCheckException("respond");
            if (assertRequiredArgument(bytesWritten, 1, "respond"), bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, "First parameter"), this._associatedReadableByteStreamController === void 0)
              throw new TypeError("This BYOB request has been invalidated");
            IsDetachedBuffer(this._view.buffer), ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
          }, ReadableStreamBYOBRequest2.prototype.respondWithNewView = function(view) {
            if (!IsReadableStreamBYOBRequest(this))
              throw byobRequestBrandCheckException("respondWithNewView");
            if (assertRequiredArgument(view, 1, "respondWithNewView"), !ArrayBuffer.isView(view))
              throw new TypeError("You can only respond with array buffer views");
            if (this._associatedReadableByteStreamController === void 0)
              throw new TypeError("This BYOB request has been invalidated");
            IsDetachedBuffer(view.buffer), ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
          }, ReadableStreamBYOBRequest2;
        }()
      );
      Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
        respond: { enumerable: !0 },
        respondWithNewView: { enumerable: !0 },
        view: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableStreamBYOBRequest",
        configurable: !0
      });
      var ReadableByteStreamController = (
        /** @class */
        function() {
          function ReadableByteStreamController2() {
            throw new TypeError("Illegal constructor");
          }
          return Object.defineProperty(ReadableByteStreamController2.prototype, "byobRequest", {
            /**
             * Returns the current BYOB pull request, or `null` if there isn't one.
             */
            get: function() {
              if (!IsReadableByteStreamController(this))
                throw byteStreamControllerBrandCheckException("byobRequest");
              return ReadableByteStreamControllerGetBYOBRequest(this);
            },
            enumerable: !1,
            configurable: !0
          }), Object.defineProperty(ReadableByteStreamController2.prototype, "desiredSize", {
            /**
             * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
             * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.
             */
            get: function() {
              if (!IsReadableByteStreamController(this))
                throw byteStreamControllerBrandCheckException("desiredSize");
              return ReadableByteStreamControllerGetDesiredSize(this);
            },
            enumerable: !1,
            configurable: !0
          }), ReadableByteStreamController2.prototype.close = function() {
            if (!IsReadableByteStreamController(this))
              throw byteStreamControllerBrandCheckException("close");
            if (this._closeRequested)
              throw new TypeError("The stream has already been closed; do not close it again!");
            var state = this._controlledReadableByteStream._state;
            if (state !== "readable")
              throw new TypeError("The stream (in " + state + " state) is not in the readable state and cannot be closed");
            ReadableByteStreamControllerClose(this);
          }, ReadableByteStreamController2.prototype.enqueue = function(chunk) {
            if (!IsReadableByteStreamController(this))
              throw byteStreamControllerBrandCheckException("enqueue");
            if (assertRequiredArgument(chunk, 1, "enqueue"), !ArrayBuffer.isView(chunk))
              throw new TypeError("chunk must be an array buffer view");
            if (chunk.byteLength === 0)
              throw new TypeError("chunk must have non-zero byteLength");
            if (chunk.buffer.byteLength === 0)
              throw new TypeError("chunk's buffer must have non-zero byteLength");
            if (this._closeRequested)
              throw new TypeError("stream is closed or draining");
            var state = this._controlledReadableByteStream._state;
            if (state !== "readable")
              throw new TypeError("The stream (in " + state + " state) is not in the readable state and cannot be enqueued to");
            ReadableByteStreamControllerEnqueue(this, chunk);
          }, ReadableByteStreamController2.prototype.error = function(e) {
            if (e === void 0 && (e = void 0), !IsReadableByteStreamController(this))
              throw byteStreamControllerBrandCheckException("error");
            ReadableByteStreamControllerError(this, e);
          }, ReadableByteStreamController2.prototype[CancelSteps] = function(reason) {
            ReadableByteStreamControllerClearPendingPullIntos(this), ResetQueue(this);
            var result = this._cancelAlgorithm(reason);
            return ReadableByteStreamControllerClearAlgorithms(this), result;
          }, ReadableByteStreamController2.prototype[PullSteps] = function(readRequest) {
            var stream4 = this._controlledReadableByteStream;
            if (this._queueTotalSize > 0) {
              var entry2 = this._queue.shift();
              this._queueTotalSize -= entry2.byteLength, ReadableByteStreamControllerHandleQueueDrain(this);
              var view = new Uint8Array(entry2.buffer, entry2.byteOffset, entry2.byteLength);
              readRequest._chunkSteps(view);
              return;
            }
            var autoAllocateChunkSize = this._autoAllocateChunkSize;
            if (autoAllocateChunkSize !== void 0) {
              var buffer = void 0;
              try {
                buffer = new ArrayBuffer(autoAllocateChunkSize);
              } catch (bufferE) {
                readRequest._errorSteps(bufferE);
                return;
              }
              var pullIntoDescriptor = {
                buffer,
                bufferByteLength: autoAllocateChunkSize,
                byteOffset: 0,
                byteLength: autoAllocateChunkSize,
                bytesFilled: 0,
                elementSize: 1,
                viewConstructor: Uint8Array,
                readerType: "default"
              };
              this._pendingPullIntos.push(pullIntoDescriptor);
            }
            ReadableStreamAddReadRequest(stream4, readRequest), ReadableByteStreamControllerCallPullIfNeeded(this);
          }, ReadableByteStreamController2;
        }()
      );
      Object.defineProperties(ReadableByteStreamController.prototype, {
        close: { enumerable: !0 },
        enqueue: { enumerable: !0 },
        error: { enumerable: !0 },
        byobRequest: { enumerable: !0 },
        desiredSize: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableByteStreamController",
        configurable: !0
      });
      function IsReadableByteStreamController(x) {
        return !typeIsObject(x) || !Object.prototype.hasOwnProperty.call(x, "_controlledReadableByteStream") ? !1 : x instanceof ReadableByteStreamController;
      }
      function IsReadableStreamBYOBRequest(x) {
        return !typeIsObject(x) || !Object.prototype.hasOwnProperty.call(x, "_associatedReadableByteStreamController") ? !1 : x instanceof ReadableStreamBYOBRequest;
      }
      function ReadableByteStreamControllerCallPullIfNeeded(controller) {
        var shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
        if (shouldPull) {
          if (controller._pulling) {
            controller._pullAgain = !0;
            return;
          }
          controller._pulling = !0;
          var pullPromise = controller._pullAlgorithm();
          uponPromise(pullPromise, function() {
            controller._pulling = !1, controller._pullAgain && (controller._pullAgain = !1, ReadableByteStreamControllerCallPullIfNeeded(controller));
          }, function(e) {
            ReadableByteStreamControllerError(controller, e);
          });
        }
      }
      function ReadableByteStreamControllerClearPendingPullIntos(controller) {
        ReadableByteStreamControllerInvalidateBYOBRequest(controller), controller._pendingPullIntos = new SimpleQueue();
      }
      function ReadableByteStreamControllerCommitPullIntoDescriptor(stream4, pullIntoDescriptor) {
        var done = !1;
        stream4._state === "closed" && (done = !0);
        var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
        pullIntoDescriptor.readerType === "default" ? ReadableStreamFulfillReadRequest(stream4, filledView, done) : ReadableStreamFulfillReadIntoRequest(stream4, filledView, done);
      }
      function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
        var bytesFilled = pullIntoDescriptor.bytesFilled, elementSize = pullIntoDescriptor.elementSize;
        return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
      }
      function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
        controller._queue.push({ buffer, byteOffset, byteLength }), controller._queueTotalSize += byteLength;
      }
      function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
        var elementSize = pullIntoDescriptor.elementSize, currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize, maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled), maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy, maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize, totalBytesToCopyRemaining = maxBytesToCopy, ready = !1;
        maxAlignedBytes > currentAlignedBytes && (totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled, ready = !0);
        for (var queue = controller._queue; totalBytesToCopyRemaining > 0; ) {
          var headOfQueue = queue.peek(), bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength), destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
          CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy), headOfQueue.byteLength === bytesToCopy ? queue.shift() : (headOfQueue.byteOffset += bytesToCopy, headOfQueue.byteLength -= bytesToCopy), controller._queueTotalSize -= bytesToCopy, ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor), totalBytesToCopyRemaining -= bytesToCopy;
        }
        return ready;
      }
      function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
        pullIntoDescriptor.bytesFilled += size;
      }
      function ReadableByteStreamControllerHandleQueueDrain(controller) {
        controller._queueTotalSize === 0 && controller._closeRequested ? (ReadableByteStreamControllerClearAlgorithms(controller), ReadableStreamClose(controller._controlledReadableByteStream)) : ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
        controller._byobRequest !== null && (controller._byobRequest._associatedReadableByteStreamController = void 0, controller._byobRequest._view = null, controller._byobRequest = null);
      }
      function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
        for (; controller._pendingPullIntos.length > 0; ) {
          if (controller._queueTotalSize === 0)
            return;
          var pullIntoDescriptor = controller._pendingPullIntos.peek();
          ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) && (ReadableByteStreamControllerShiftPendingPullInto(controller), ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor));
        }
      }
      function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {
        var stream4 = controller._controlledReadableByteStream, elementSize = 1;
        view.constructor !== DataView && (elementSize = view.constructor.BYTES_PER_ELEMENT);
        var ctor = view.constructor, buffer = view.buffer, pullIntoDescriptor = {
          buffer,
          bufferByteLength: buffer.byteLength,
          byteOffset: view.byteOffset,
          byteLength: view.byteLength,
          bytesFilled: 0,
          elementSize,
          viewConstructor: ctor,
          readerType: "byob"
        };
        if (controller._pendingPullIntos.length > 0) {
          controller._pendingPullIntos.push(pullIntoDescriptor), ReadableStreamAddReadIntoRequest(stream4, readIntoRequest);
          return;
        }
        if (stream4._state === "closed") {
          var emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
          readIntoRequest._closeSteps(emptyView);
          return;
        }
        if (controller._queueTotalSize > 0) {
          if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
            var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
            ReadableByteStreamControllerHandleQueueDrain(controller), readIntoRequest._chunkSteps(filledView);
            return;
          }
          if (controller._closeRequested) {
            var e = new TypeError("Insufficient bytes to fill elements in the given buffer");
            ReadableByteStreamControllerError(controller, e), readIntoRequest._errorSteps(e);
            return;
          }
        }
        controller._pendingPullIntos.push(pullIntoDescriptor), ReadableStreamAddReadIntoRequest(stream4, readIntoRequest), ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
        var stream4 = controller._controlledReadableByteStream;
        if (ReadableStreamHasBYOBReader(stream4))
          for (; ReadableStreamGetNumReadIntoRequests(stream4) > 0; ) {
            var pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
            ReadableByteStreamControllerCommitPullIntoDescriptor(stream4, pullIntoDescriptor);
          }
      }
      function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
        if (ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor), !(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize)) {
          ReadableByteStreamControllerShiftPendingPullInto(controller);
          var remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
          if (remainderSize > 0) {
            var end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled, remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
          }
          pullIntoDescriptor.bytesFilled -= remainderSize, ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor), ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
        }
      }
      function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
        var firstDescriptor = controller._pendingPullIntos.peek();
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        var state = controller._controlledReadableByteStream._state;
        state === "closed" ? ReadableByteStreamControllerRespondInClosedState(controller) : ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor), ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
      function ReadableByteStreamControllerShiftPendingPullInto(controller) {
        var descriptor = controller._pendingPullIntos.shift();
        return descriptor;
      }
      function ReadableByteStreamControllerShouldCallPull(controller) {
        var stream4 = controller._controlledReadableByteStream;
        if (stream4._state !== "readable" || controller._closeRequested || !controller._started)
          return !1;
        if (ReadableStreamHasDefaultReader(stream4) && ReadableStreamGetNumReadRequests(stream4) > 0 || ReadableStreamHasBYOBReader(stream4) && ReadableStreamGetNumReadIntoRequests(stream4) > 0)
          return !0;
        var desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
        return desiredSize > 0;
      }
      function ReadableByteStreamControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = void 0, controller._cancelAlgorithm = void 0;
      }
      function ReadableByteStreamControllerClose(controller) {
        var stream4 = controller._controlledReadableByteStream;
        if (!(controller._closeRequested || stream4._state !== "readable")) {
          if (controller._queueTotalSize > 0) {
            controller._closeRequested = !0;
            return;
          }
          if (controller._pendingPullIntos.length > 0) {
            var firstPendingPullInto = controller._pendingPullIntos.peek();
            if (firstPendingPullInto.bytesFilled > 0) {
              var e = new TypeError("Insufficient bytes to fill elements in the given buffer");
              throw ReadableByteStreamControllerError(controller, e), e;
            }
          }
          ReadableByteStreamControllerClearAlgorithms(controller), ReadableStreamClose(stream4);
        }
      }
      function ReadableByteStreamControllerEnqueue(controller, chunk) {
        var stream4 = controller._controlledReadableByteStream;
        if (!(controller._closeRequested || stream4._state !== "readable")) {
          var buffer = chunk.buffer, byteOffset = chunk.byteOffset, byteLength = chunk.byteLength, transferredBuffer = buffer;
          if (controller._pendingPullIntos.length > 0) {
            var firstPendingPullInto = controller._pendingPullIntos.peek();
            IsDetachedBuffer(firstPendingPullInto.buffer), firstPendingPullInto.buffer = firstPendingPullInto.buffer;
          }
          if (ReadableByteStreamControllerInvalidateBYOBRequest(controller), ReadableStreamHasDefaultReader(stream4))
            if (ReadableStreamGetNumReadRequests(stream4) === 0)
              ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
            else {
              controller._pendingPullIntos.length > 0 && ReadableByteStreamControllerShiftPendingPullInto(controller);
              var transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
              ReadableStreamFulfillReadRequest(stream4, transferredView, !1);
            }
          else
            ReadableStreamHasBYOBReader(stream4) ? (ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength), ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller)) : ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
      }
      function ReadableByteStreamControllerError(controller, e) {
        var stream4 = controller._controlledReadableByteStream;
        stream4._state === "readable" && (ReadableByteStreamControllerClearPendingPullIntos(controller), ResetQueue(controller), ReadableByteStreamControllerClearAlgorithms(controller), ReadableStreamError(stream4, e));
      }
      function ReadableByteStreamControllerGetBYOBRequest(controller) {
        if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
          var firstDescriptor = controller._pendingPullIntos.peek(), view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled), byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
          SetUpReadableStreamBYOBRequest(byobRequest, controller, view), controller._byobRequest = byobRequest;
        }
        return controller._byobRequest;
      }
      function ReadableByteStreamControllerGetDesiredSize(controller) {
        var state = controller._controlledReadableByteStream._state;
        return state === "errored" ? null : state === "closed" ? 0 : controller._strategyHWM - controller._queueTotalSize;
      }
      function ReadableByteStreamControllerRespond(controller, bytesWritten) {
        var firstDescriptor = controller._pendingPullIntos.peek(), state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
          if (bytesWritten !== 0)
            throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
        } else {
          if (bytesWritten === 0)
            throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
          if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength)
            throw new RangeError("bytesWritten out of range");
        }
        firstDescriptor.buffer = firstDescriptor.buffer, ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
      }
      function ReadableByteStreamControllerRespondWithNewView(controller, view) {
        var firstDescriptor = controller._pendingPullIntos.peek(), state = controller._controlledReadableByteStream._state;
        if (state === "closed") {
          if (view.byteLength !== 0)
            throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
        } else if (view.byteLength === 0)
          throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
        if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset)
          throw new RangeError("The region specified by view does not match byobRequest");
        if (firstDescriptor.bufferByteLength !== view.buffer.byteLength)
          throw new RangeError("The buffer of view has different capacity than byobRequest");
        if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength)
          throw new RangeError("The region specified by view is larger than byobRequest");
        var viewByteLength = view.byteLength;
        firstDescriptor.buffer = view.buffer, ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
      }
      function SetUpReadableByteStreamController(stream4, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
        controller._controlledReadableByteStream = stream4, controller._pullAgain = !1, controller._pulling = !1, controller._byobRequest = null, controller._queue = controller._queueTotalSize = void 0, ResetQueue(controller), controller._closeRequested = !1, controller._started = !1, controller._strategyHWM = highWaterMark, controller._pullAlgorithm = pullAlgorithm, controller._cancelAlgorithm = cancelAlgorithm, controller._autoAllocateChunkSize = autoAllocateChunkSize, controller._pendingPullIntos = new SimpleQueue(), stream4._readableStreamController = controller;
        var startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), function() {
          controller._started = !0, ReadableByteStreamControllerCallPullIfNeeded(controller);
        }, function(r) {
          ReadableByteStreamControllerError(controller, r);
        });
      }
      function SetUpReadableByteStreamControllerFromUnderlyingSource(stream4, underlyingByteSource, highWaterMark) {
        var controller = Object.create(ReadableByteStreamController.prototype), startAlgorithm = function() {
        }, pullAlgorithm = function() {
          return promiseResolvedWith(void 0);
        }, cancelAlgorithm = function() {
          return promiseResolvedWith(void 0);
        };
        underlyingByteSource.start !== void 0 && (startAlgorithm = function() {
          return underlyingByteSource.start(controller);
        }), underlyingByteSource.pull !== void 0 && (pullAlgorithm = function() {
          return underlyingByteSource.pull(controller);
        }), underlyingByteSource.cancel !== void 0 && (cancelAlgorithm = function(reason) {
          return underlyingByteSource.cancel(reason);
        });
        var autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
        if (autoAllocateChunkSize === 0)
          throw new TypeError("autoAllocateChunkSize must be greater than 0");
        SetUpReadableByteStreamController(stream4, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
      }
      function SetUpReadableStreamBYOBRequest(request, controller, view) {
        request._associatedReadableByteStreamController = controller, request._view = view;
      }
      function byobRequestBrandCheckException(name) {
        return new TypeError("ReadableStreamBYOBRequest.prototype." + name + " can only be used on a ReadableStreamBYOBRequest");
      }
      function byteStreamControllerBrandCheckException(name) {
        return new TypeError("ReadableByteStreamController.prototype." + name + " can only be used on a ReadableByteStreamController");
      }
      function AcquireReadableStreamBYOBReader(stream4) {
        return new ReadableStreamBYOBReader(stream4);
      }
      function ReadableStreamAddReadIntoRequest(stream4, readIntoRequest) {
        stream4._reader._readIntoRequests.push(readIntoRequest);
      }
      function ReadableStreamFulfillReadIntoRequest(stream4, chunk, done) {
        var reader = stream4._reader, readIntoRequest = reader._readIntoRequests.shift();
        done ? readIntoRequest._closeSteps(chunk) : readIntoRequest._chunkSteps(chunk);
      }
      function ReadableStreamGetNumReadIntoRequests(stream4) {
        return stream4._reader._readIntoRequests.length;
      }
      function ReadableStreamHasBYOBReader(stream4) {
        var reader = stream4._reader;
        return !(reader === void 0 || !IsReadableStreamBYOBReader(reader));
      }
      var ReadableStreamBYOBReader = (
        /** @class */
        function() {
          function ReadableStreamBYOBReader2(stream4) {
            if (assertRequiredArgument(stream4, 1, "ReadableStreamBYOBReader"), assertReadableStream(stream4, "First parameter"), IsReadableStreamLocked(stream4))
              throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            if (!IsReadableByteStreamController(stream4._readableStreamController))
              throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
            ReadableStreamReaderGenericInitialize(this, stream4), this._readIntoRequests = new SimpleQueue();
          }
          return Object.defineProperty(ReadableStreamBYOBReader2.prototype, "closed", {
            /**
             * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
             * the reader's lock is released before the stream finishes closing.
             */
            get: function() {
              return IsReadableStreamBYOBReader(this) ? this._closedPromise : promiseRejectedWith(byobReaderBrandCheckException("closed"));
            },
            enumerable: !1,
            configurable: !0
          }), ReadableStreamBYOBReader2.prototype.cancel = function(reason) {
            return reason === void 0 && (reason = void 0), IsReadableStreamBYOBReader(this) ? this._ownerReadableStream === void 0 ? promiseRejectedWith(readerLockException("cancel")) : ReadableStreamReaderGenericCancel(this, reason) : promiseRejectedWith(byobReaderBrandCheckException("cancel"));
          }, ReadableStreamBYOBReader2.prototype.read = function(view) {
            if (!IsReadableStreamBYOBReader(this))
              return promiseRejectedWith(byobReaderBrandCheckException("read"));
            if (!ArrayBuffer.isView(view))
              return promiseRejectedWith(new TypeError("view must be an array buffer view"));
            if (view.byteLength === 0)
              return promiseRejectedWith(new TypeError("view must have non-zero byteLength"));
            if (view.buffer.byteLength === 0)
              return promiseRejectedWith(new TypeError("view's buffer must have non-zero byteLength"));
            if (IsDetachedBuffer(view.buffer), this._ownerReadableStream === void 0)
              return promiseRejectedWith(readerLockException("read from"));
            var resolvePromise, rejectPromise, promise = newPromise(function(resolve, reject) {
              resolvePromise = resolve, rejectPromise = reject;
            }), readIntoRequest = {
              _chunkSteps: function(chunk) {
                return resolvePromise({ value: chunk, done: !1 });
              },
              _closeSteps: function(chunk) {
                return resolvePromise({ value: chunk, done: !0 });
              },
              _errorSteps: function(e) {
                return rejectPromise(e);
              }
            };
            return ReadableStreamBYOBReaderRead(this, view, readIntoRequest), promise;
          }, ReadableStreamBYOBReader2.prototype.releaseLock = function() {
            if (!IsReadableStreamBYOBReader(this))
              throw byobReaderBrandCheckException("releaseLock");
            if (this._ownerReadableStream !== void 0) {
              if (this._readIntoRequests.length > 0)
                throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
              ReadableStreamReaderGenericRelease(this);
            }
          }, ReadableStreamBYOBReader2;
        }()
      );
      Object.defineProperties(ReadableStreamBYOBReader.prototype, {
        cancel: { enumerable: !0 },
        read: { enumerable: !0 },
        releaseLock: { enumerable: !0 },
        closed: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableStreamBYOBReader",
        configurable: !0
      });
      function IsReadableStreamBYOBReader(x) {
        return !typeIsObject(x) || !Object.prototype.hasOwnProperty.call(x, "_readIntoRequests") ? !1 : x instanceof ReadableStreamBYOBReader;
      }
      function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {
        var stream4 = reader._ownerReadableStream;
        stream4._disturbed = !0, stream4._state === "errored" ? readIntoRequest._errorSteps(stream4._storedError) : ReadableByteStreamControllerPullInto(stream4._readableStreamController, view, readIntoRequest);
      }
      function byobReaderBrandCheckException(name) {
        return new TypeError("ReadableStreamBYOBReader.prototype." + name + " can only be used on a ReadableStreamBYOBReader");
      }
      function ExtractHighWaterMark(strategy, defaultHWM) {
        var highWaterMark = strategy.highWaterMark;
        if (highWaterMark === void 0)
          return defaultHWM;
        if (NumberIsNaN(highWaterMark) || highWaterMark < 0)
          throw new RangeError("Invalid highWaterMark");
        return highWaterMark;
      }
      function ExtractSizeAlgorithm(strategy) {
        var size = strategy.size;
        return size || function() {
          return 1;
        };
      }
      function convertQueuingStrategy(init, context) {
        assertDictionary(init, context);
        var highWaterMark = init == null ? void 0 : init.highWaterMark, size = init == null ? void 0 : init.size;
        return {
          highWaterMark: highWaterMark === void 0 ? void 0 : convertUnrestrictedDouble(highWaterMark),
          size: size === void 0 ? void 0 : convertQueuingStrategySize(size, context + " has member 'size' that")
        };
      }
      function convertQueuingStrategySize(fn, context) {
        return assertFunction(fn, context), function(chunk) {
          return convertUnrestrictedDouble(fn(chunk));
        };
      }
      function convertUnderlyingSink(original, context) {
        assertDictionary(original, context);
        var abort = original == null ? void 0 : original.abort, close = original == null ? void 0 : original.close, start = original == null ? void 0 : original.start, type = original == null ? void 0 : original.type, write = original == null ? void 0 : original.write;
        return {
          abort: abort === void 0 ? void 0 : convertUnderlyingSinkAbortCallback(abort, original, context + " has member 'abort' that"),
          close: close === void 0 ? void 0 : convertUnderlyingSinkCloseCallback(close, original, context + " has member 'close' that"),
          start: start === void 0 ? void 0 : convertUnderlyingSinkStartCallback(start, original, context + " has member 'start' that"),
          write: write === void 0 ? void 0 : convertUnderlyingSinkWriteCallback(write, original, context + " has member 'write' that"),
          type
        };
      }
      function convertUnderlyingSinkAbortCallback(fn, original, context) {
        return assertFunction(fn, context), function(reason) {
          return promiseCall(fn, original, [reason]);
        };
      }
      function convertUnderlyingSinkCloseCallback(fn, original, context) {
        return assertFunction(fn, context), function() {
          return promiseCall(fn, original, []);
        };
      }
      function convertUnderlyingSinkStartCallback(fn, original, context) {
        return assertFunction(fn, context), function(controller) {
          return reflectCall(fn, original, [controller]);
        };
      }
      function convertUnderlyingSinkWriteCallback(fn, original, context) {
        return assertFunction(fn, context), function(chunk, controller) {
          return promiseCall(fn, original, [chunk, controller]);
        };
      }
      function assertWritableStream(x, context) {
        if (!IsWritableStream(x))
          throw new TypeError(context + " is not a WritableStream.");
      }
      function isAbortSignal(value) {
        if (typeof value != "object" || value === null)
          return !1;
        try {
          return typeof value.aborted == "boolean";
        } catch {
          return !1;
        }
      }
      var supportsAbortController = typeof AbortController == "function";
      function createAbortController() {
        if (supportsAbortController)
          return new AbortController();
      }
      var WritableStream = (
        /** @class */
        function() {
          function WritableStream2(rawUnderlyingSink, rawStrategy) {
            rawUnderlyingSink === void 0 && (rawUnderlyingSink = {}), rawStrategy === void 0 && (rawStrategy = {}), rawUnderlyingSink === void 0 ? rawUnderlyingSink = null : assertObject(rawUnderlyingSink, "First parameter");
            var strategy = convertQueuingStrategy(rawStrategy, "Second parameter"), underlyingSink = convertUnderlyingSink(rawUnderlyingSink, "First parameter");
            InitializeWritableStream(this);
            var type = underlyingSink.type;
            if (type !== void 0)
              throw new RangeError("Invalid type is specified");
            var sizeAlgorithm = ExtractSizeAlgorithm(strategy), highWaterMark = ExtractHighWaterMark(strategy, 1);
            SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
          }
          return Object.defineProperty(WritableStream2.prototype, "locked", {
            /**
             * Returns whether or not the writable stream is locked to a writer.
             */
            get: function() {
              if (!IsWritableStream(this))
                throw streamBrandCheckException$2("locked");
              return IsWritableStreamLocked(this);
            },
            enumerable: !1,
            configurable: !0
          }), WritableStream2.prototype.abort = function(reason) {
            return reason === void 0 && (reason = void 0), IsWritableStream(this) ? IsWritableStreamLocked(this) ? promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer")) : WritableStreamAbort(this, reason) : promiseRejectedWith(streamBrandCheckException$2("abort"));
          }, WritableStream2.prototype.close = function() {
            return IsWritableStream(this) ? IsWritableStreamLocked(this) ? promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer")) : WritableStreamCloseQueuedOrInFlight(this) ? promiseRejectedWith(new TypeError("Cannot close an already-closing stream")) : WritableStreamClose(this) : promiseRejectedWith(streamBrandCheckException$2("close"));
          }, WritableStream2.prototype.getWriter = function() {
            if (!IsWritableStream(this))
              throw streamBrandCheckException$2("getWriter");
            return AcquireWritableStreamDefaultWriter(this);
          }, WritableStream2;
        }()
      );
      Object.defineProperties(WritableStream.prototype, {
        abort: { enumerable: !0 },
        close: { enumerable: !0 },
        getWriter: { enumerable: !0 },
        locked: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {
        value: "WritableStream",
        configurable: !0
      });
      function AcquireWritableStreamDefaultWriter(stream4) {
        return new WritableStreamDefaultWriter(stream4);
      }
      function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
        highWaterMark === void 0 && (highWaterMark = 1), sizeAlgorithm === void 0 && (sizeAlgorithm = function() {
          return 1;
        });
        var stream4 = Object.create(WritableStream.prototype);
        InitializeWritableStream(stream4);
        var controller = Object.create(WritableStreamDefaultController.prototype);
        return SetUpWritableStreamDefaultController(stream4, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm), stream4;
      }
      function InitializeWritableStream(stream4) {
        stream4._state = "writable", stream4._storedError = void 0, stream4._writer = void 0, stream4._writableStreamController = void 0, stream4._writeRequests = new SimpleQueue(), stream4._inFlightWriteRequest = void 0, stream4._closeRequest = void 0, stream4._inFlightCloseRequest = void 0, stream4._pendingAbortRequest = void 0, stream4._backpressure = !1;
      }
      function IsWritableStream(x) {
        return !typeIsObject(x) || !Object.prototype.hasOwnProperty.call(x, "_writableStreamController") ? !1 : x instanceof WritableStream;
      }
      function IsWritableStreamLocked(stream4) {
        return stream4._writer !== void 0;
      }
      function WritableStreamAbort(stream4, reason) {
        var _a2;
        if (stream4._state === "closed" || stream4._state === "errored")
          return promiseResolvedWith(void 0);
        stream4._writableStreamController._abortReason = reason, (_a2 = stream4._writableStreamController._abortController) === null || _a2 === void 0 || _a2.abort();
        var state = stream4._state;
        if (state === "closed" || state === "errored")
          return promiseResolvedWith(void 0);
        if (stream4._pendingAbortRequest !== void 0)
          return stream4._pendingAbortRequest._promise;
        var wasAlreadyErroring = !1;
        state === "erroring" && (wasAlreadyErroring = !0, reason = void 0);
        var promise = newPromise(function(resolve, reject) {
          stream4._pendingAbortRequest = {
            _promise: void 0,
            _resolve: resolve,
            _reject: reject,
            _reason: reason,
            _wasAlreadyErroring: wasAlreadyErroring
          };
        });
        return stream4._pendingAbortRequest._promise = promise, wasAlreadyErroring || WritableStreamStartErroring(stream4, reason), promise;
      }
      function WritableStreamClose(stream4) {
        var state = stream4._state;
        if (state === "closed" || state === "errored")
          return promiseRejectedWith(new TypeError("The stream (in " + state + " state) is not in the writable state and cannot be closed"));
        var promise = newPromise(function(resolve, reject) {
          var closeRequest = {
            _resolve: resolve,
            _reject: reject
          };
          stream4._closeRequest = closeRequest;
        }), writer = stream4._writer;
        return writer !== void 0 && stream4._backpressure && state === "writable" && defaultWriterReadyPromiseResolve(writer), WritableStreamDefaultControllerClose(stream4._writableStreamController), promise;
      }
      function WritableStreamAddWriteRequest(stream4) {
        var promise = newPromise(function(resolve, reject) {
          var writeRequest = {
            _resolve: resolve,
            _reject: reject
          };
          stream4._writeRequests.push(writeRequest);
        });
        return promise;
      }
      function WritableStreamDealWithRejection(stream4, error) {
        var state = stream4._state;
        if (state === "writable") {
          WritableStreamStartErroring(stream4, error);
          return;
        }
        WritableStreamFinishErroring(stream4);
      }
      function WritableStreamStartErroring(stream4, reason) {
        var controller = stream4._writableStreamController;
        stream4._state = "erroring", stream4._storedError = reason;
        var writer = stream4._writer;
        writer !== void 0 && WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason), !WritableStreamHasOperationMarkedInFlight(stream4) && controller._started && WritableStreamFinishErroring(stream4);
      }
      function WritableStreamFinishErroring(stream4) {
        stream4._state = "errored", stream4._writableStreamController[ErrorSteps]();
        var storedError = stream4._storedError;
        if (stream4._writeRequests.forEach(function(writeRequest) {
          writeRequest._reject(storedError);
        }), stream4._writeRequests = new SimpleQueue(), stream4._pendingAbortRequest === void 0) {
          WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream4);
          return;
        }
        var abortRequest = stream4._pendingAbortRequest;
        if (stream4._pendingAbortRequest = void 0, abortRequest._wasAlreadyErroring) {
          abortRequest._reject(storedError), WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream4);
          return;
        }
        var promise = stream4._writableStreamController[AbortSteps](abortRequest._reason);
        uponPromise(promise, function() {
          abortRequest._resolve(), WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream4);
        }, function(reason) {
          abortRequest._reject(reason), WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream4);
        });
      }
      function WritableStreamFinishInFlightWrite(stream4) {
        stream4._inFlightWriteRequest._resolve(void 0), stream4._inFlightWriteRequest = void 0;
      }
      function WritableStreamFinishInFlightWriteWithError(stream4, error) {
        stream4._inFlightWriteRequest._reject(error), stream4._inFlightWriteRequest = void 0, WritableStreamDealWithRejection(stream4, error);
      }
      function WritableStreamFinishInFlightClose(stream4) {
        stream4._inFlightCloseRequest._resolve(void 0), stream4._inFlightCloseRequest = void 0;
        var state = stream4._state;
        state === "erroring" && (stream4._storedError = void 0, stream4._pendingAbortRequest !== void 0 && (stream4._pendingAbortRequest._resolve(), stream4._pendingAbortRequest = void 0)), stream4._state = "closed";
        var writer = stream4._writer;
        writer !== void 0 && defaultWriterClosedPromiseResolve(writer);
      }
      function WritableStreamFinishInFlightCloseWithError(stream4, error) {
        stream4._inFlightCloseRequest._reject(error), stream4._inFlightCloseRequest = void 0, stream4._pendingAbortRequest !== void 0 && (stream4._pendingAbortRequest._reject(error), stream4._pendingAbortRequest = void 0), WritableStreamDealWithRejection(stream4, error);
      }
      function WritableStreamCloseQueuedOrInFlight(stream4) {
        return !(stream4._closeRequest === void 0 && stream4._inFlightCloseRequest === void 0);
      }
      function WritableStreamHasOperationMarkedInFlight(stream4) {
        return !(stream4._inFlightWriteRequest === void 0 && stream4._inFlightCloseRequest === void 0);
      }
      function WritableStreamMarkCloseRequestInFlight(stream4) {
        stream4._inFlightCloseRequest = stream4._closeRequest, stream4._closeRequest = void 0;
      }
      function WritableStreamMarkFirstWriteRequestInFlight(stream4) {
        stream4._inFlightWriteRequest = stream4._writeRequests.shift();
      }
      function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream4) {
        stream4._closeRequest !== void 0 && (stream4._closeRequest._reject(stream4._storedError), stream4._closeRequest = void 0);
        var writer = stream4._writer;
        writer !== void 0 && defaultWriterClosedPromiseReject(writer, stream4._storedError);
      }
      function WritableStreamUpdateBackpressure(stream4, backpressure) {
        var writer = stream4._writer;
        writer !== void 0 && backpressure !== stream4._backpressure && (backpressure ? defaultWriterReadyPromiseReset(writer) : defaultWriterReadyPromiseResolve(writer)), stream4._backpressure = backpressure;
      }
      var WritableStreamDefaultWriter = (
        /** @class */
        function() {
          function WritableStreamDefaultWriter2(stream4) {
            if (assertRequiredArgument(stream4, 1, "WritableStreamDefaultWriter"), assertWritableStream(stream4, "First parameter"), IsWritableStreamLocked(stream4))
              throw new TypeError("This stream has already been locked for exclusive writing by another writer");
            this._ownerWritableStream = stream4, stream4._writer = this;
            var state = stream4._state;
            if (state === "writable")
              !WritableStreamCloseQueuedOrInFlight(stream4) && stream4._backpressure ? defaultWriterReadyPromiseInitialize(this) : defaultWriterReadyPromiseInitializeAsResolved(this), defaultWriterClosedPromiseInitialize(this);
            else if (state === "erroring")
              defaultWriterReadyPromiseInitializeAsRejected(this, stream4._storedError), defaultWriterClosedPromiseInitialize(this);
            else if (state === "closed")
              defaultWriterReadyPromiseInitializeAsResolved(this), defaultWriterClosedPromiseInitializeAsResolved(this);
            else {
              var storedError = stream4._storedError;
              defaultWriterReadyPromiseInitializeAsRejected(this, storedError), defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
            }
          }
          return Object.defineProperty(WritableStreamDefaultWriter2.prototype, "closed", {
            /**
             * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
             * the writers lock is released before the stream finishes closing.
             */
            get: function() {
              return IsWritableStreamDefaultWriter(this) ? this._closedPromise : promiseRejectedWith(defaultWriterBrandCheckException("closed"));
            },
            enumerable: !1,
            configurable: !0
          }), Object.defineProperty(WritableStreamDefaultWriter2.prototype, "desiredSize", {
            /**
             * Returns the desired size to fill the streams internal queue. It can be negative, if the queue is over-full.
             * A producer can use this information to determine the right amount of data to write.
             *
             * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort
             * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when
             * the writers lock is released.
             */
            get: function() {
              if (!IsWritableStreamDefaultWriter(this))
                throw defaultWriterBrandCheckException("desiredSize");
              if (this._ownerWritableStream === void 0)
                throw defaultWriterLockException("desiredSize");
              return WritableStreamDefaultWriterGetDesiredSize(this);
            },
            enumerable: !1,
            configurable: !0
          }), Object.defineProperty(WritableStreamDefaultWriter2.prototype, "ready", {
            /**
             * Returns a promise that will be fulfilled when the desired size to fill the streams internal queue transitions
             * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips
             * back to zero or below, the getter will return a new promise that stays pending until the next transition.
             *
             * If the stream becomes errored or aborted, or the writers lock is released, the returned promise will become
             * rejected.
             */
            get: function() {
              return IsWritableStreamDefaultWriter(this) ? this._readyPromise : promiseRejectedWith(defaultWriterBrandCheckException("ready"));
            },
            enumerable: !1,
            configurable: !0
          }), WritableStreamDefaultWriter2.prototype.abort = function(reason) {
            return reason === void 0 && (reason = void 0), IsWritableStreamDefaultWriter(this) ? this._ownerWritableStream === void 0 ? promiseRejectedWith(defaultWriterLockException("abort")) : WritableStreamDefaultWriterAbort(this, reason) : promiseRejectedWith(defaultWriterBrandCheckException("abort"));
          }, WritableStreamDefaultWriter2.prototype.close = function() {
            if (!IsWritableStreamDefaultWriter(this))
              return promiseRejectedWith(defaultWriterBrandCheckException("close"));
            var stream4 = this._ownerWritableStream;
            return stream4 === void 0 ? promiseRejectedWith(defaultWriterLockException("close")) : WritableStreamCloseQueuedOrInFlight(stream4) ? promiseRejectedWith(new TypeError("Cannot close an already-closing stream")) : WritableStreamDefaultWriterClose(this);
          }, WritableStreamDefaultWriter2.prototype.releaseLock = function() {
            if (!IsWritableStreamDefaultWriter(this))
              throw defaultWriterBrandCheckException("releaseLock");
            var stream4 = this._ownerWritableStream;
            stream4 !== void 0 && WritableStreamDefaultWriterRelease(this);
          }, WritableStreamDefaultWriter2.prototype.write = function(chunk) {
            return chunk === void 0 && (chunk = void 0), IsWritableStreamDefaultWriter(this) ? this._ownerWritableStream === void 0 ? promiseRejectedWith(defaultWriterLockException("write to")) : WritableStreamDefaultWriterWrite(this, chunk) : promiseRejectedWith(defaultWriterBrandCheckException("write"));
          }, WritableStreamDefaultWriter2;
        }()
      );
      Object.defineProperties(WritableStreamDefaultWriter.prototype, {
        abort: { enumerable: !0 },
        close: { enumerable: !0 },
        releaseLock: { enumerable: !0 },
        write: { enumerable: !0 },
        closed: { enumerable: !0 },
        desiredSize: { enumerable: !0 },
        ready: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {
        value: "WritableStreamDefaultWriter",
        configurable: !0
      });
      function IsWritableStreamDefaultWriter(x) {
        return !typeIsObject(x) || !Object.prototype.hasOwnProperty.call(x, "_ownerWritableStream") ? !1 : x instanceof WritableStreamDefaultWriter;
      }
      function WritableStreamDefaultWriterAbort(writer, reason) {
        var stream4 = writer._ownerWritableStream;
        return WritableStreamAbort(stream4, reason);
      }
      function WritableStreamDefaultWriterClose(writer) {
        var stream4 = writer._ownerWritableStream;
        return WritableStreamClose(stream4);
      }
      function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
        var stream4 = writer._ownerWritableStream, state = stream4._state;
        return WritableStreamCloseQueuedOrInFlight(stream4) || state === "closed" ? promiseResolvedWith(void 0) : state === "errored" ? promiseRejectedWith(stream4._storedError) : WritableStreamDefaultWriterClose(writer);
      }
      function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {
        writer._closedPromiseState === "pending" ? defaultWriterClosedPromiseReject(writer, error) : defaultWriterClosedPromiseResetToRejected(writer, error);
      }
      function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {
        writer._readyPromiseState === "pending" ? defaultWriterReadyPromiseReject(writer, error) : defaultWriterReadyPromiseResetToRejected(writer, error);
      }
      function WritableStreamDefaultWriterGetDesiredSize(writer) {
        var stream4 = writer._ownerWritableStream, state = stream4._state;
        return state === "errored" || state === "erroring" ? null : state === "closed" ? 0 : WritableStreamDefaultControllerGetDesiredSize(stream4._writableStreamController);
      }
      function WritableStreamDefaultWriterRelease(writer) {
        var stream4 = writer._ownerWritableStream, releasedError = new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");
        WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError), WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError), stream4._writer = void 0, writer._ownerWritableStream = void 0;
      }
      function WritableStreamDefaultWriterWrite(writer, chunk) {
        var stream4 = writer._ownerWritableStream, controller = stream4._writableStreamController, chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
        if (stream4 !== writer._ownerWritableStream)
          return promiseRejectedWith(defaultWriterLockException("write to"));
        var state = stream4._state;
        if (state === "errored")
          return promiseRejectedWith(stream4._storedError);
        if (WritableStreamCloseQueuedOrInFlight(stream4) || state === "closed")
          return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"));
        if (state === "erroring")
          return promiseRejectedWith(stream4._storedError);
        var promise = WritableStreamAddWriteRequest(stream4);
        return WritableStreamDefaultControllerWrite(controller, chunk, chunkSize), promise;
      }
      var closeSentinel = {}, WritableStreamDefaultController = (
        /** @class */
        function() {
          function WritableStreamDefaultController2() {
            throw new TypeError("Illegal constructor");
          }
          return Object.defineProperty(WritableStreamDefaultController2.prototype, "abortReason", {
            /**
             * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.
             *
             * @deprecated
             *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.
             *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.
             */
            get: function() {
              if (!IsWritableStreamDefaultController(this))
                throw defaultControllerBrandCheckException$2("abortReason");
              return this._abortReason;
            },
            enumerable: !1,
            configurable: !0
          }), Object.defineProperty(WritableStreamDefaultController2.prototype, "signal", {
            /**
             * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.
             */
            get: function() {
              if (!IsWritableStreamDefaultController(this))
                throw defaultControllerBrandCheckException$2("signal");
              if (this._abortController === void 0)
                throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
              return this._abortController.signal;
            },
            enumerable: !1,
            configurable: !0
          }), WritableStreamDefaultController2.prototype.error = function(e) {
            if (e === void 0 && (e = void 0), !IsWritableStreamDefaultController(this))
              throw defaultControllerBrandCheckException$2("error");
            var state = this._controlledWritableStream._state;
            state === "writable" && WritableStreamDefaultControllerError(this, e);
          }, WritableStreamDefaultController2.prototype[AbortSteps] = function(reason) {
            var result = this._abortAlgorithm(reason);
            return WritableStreamDefaultControllerClearAlgorithms(this), result;
          }, WritableStreamDefaultController2.prototype[ErrorSteps] = function() {
            ResetQueue(this);
          }, WritableStreamDefaultController2;
        }()
      );
      Object.defineProperties(WritableStreamDefaultController.prototype, {
        abortReason: { enumerable: !0 },
        signal: { enumerable: !0 },
        error: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
        value: "WritableStreamDefaultController",
        configurable: !0
      });
      function IsWritableStreamDefaultController(x) {
        return !typeIsObject(x) || !Object.prototype.hasOwnProperty.call(x, "_controlledWritableStream") ? !1 : x instanceof WritableStreamDefaultController;
      }
      function SetUpWritableStreamDefaultController(stream4, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledWritableStream = stream4, stream4._writableStreamController = controller, controller._queue = void 0, controller._queueTotalSize = void 0, ResetQueue(controller), controller._abortReason = void 0, controller._abortController = createAbortController(), controller._started = !1, controller._strategySizeAlgorithm = sizeAlgorithm, controller._strategyHWM = highWaterMark, controller._writeAlgorithm = writeAlgorithm, controller._closeAlgorithm = closeAlgorithm, controller._abortAlgorithm = abortAlgorithm;
        var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
        WritableStreamUpdateBackpressure(stream4, backpressure);
        var startResult = startAlgorithm(), startPromise = promiseResolvedWith(startResult);
        uponPromise(startPromise, function() {
          controller._started = !0, WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }, function(r) {
          controller._started = !0, WritableStreamDealWithRejection(stream4, r);
        });
      }
      function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream4, underlyingSink, highWaterMark, sizeAlgorithm) {
        var controller = Object.create(WritableStreamDefaultController.prototype), startAlgorithm = function() {
        }, writeAlgorithm = function() {
          return promiseResolvedWith(void 0);
        }, closeAlgorithm = function() {
          return promiseResolvedWith(void 0);
        }, abortAlgorithm = function() {
          return promiseResolvedWith(void 0);
        };
        underlyingSink.start !== void 0 && (startAlgorithm = function() {
          return underlyingSink.start(controller);
        }), underlyingSink.write !== void 0 && (writeAlgorithm = function(chunk) {
          return underlyingSink.write(chunk, controller);
        }), underlyingSink.close !== void 0 && (closeAlgorithm = function() {
          return underlyingSink.close();
        }), underlyingSink.abort !== void 0 && (abortAlgorithm = function(reason) {
          return underlyingSink.abort(reason);
        }), SetUpWritableStreamDefaultController(stream4, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
      }
      function WritableStreamDefaultControllerClearAlgorithms(controller) {
        controller._writeAlgorithm = void 0, controller._closeAlgorithm = void 0, controller._abortAlgorithm = void 0, controller._strategySizeAlgorithm = void 0;
      }
      function WritableStreamDefaultControllerClose(controller) {
        EnqueueValueWithSize(controller, closeSentinel, 0), WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
      }
      function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
        try {
          return controller._strategySizeAlgorithm(chunk);
        } catch (chunkSizeE) {
          return WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE), 1;
        }
      }
      function WritableStreamDefaultControllerGetDesiredSize(controller) {
        return controller._strategyHWM - controller._queueTotalSize;
      }
      function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
        try {
          EnqueueValueWithSize(controller, chunk, chunkSize);
        } catch (enqueueE) {
          WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
          return;
        }
        var stream4 = controller._controlledWritableStream;
        if (!WritableStreamCloseQueuedOrInFlight(stream4) && stream4._state === "writable") {
          var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
          WritableStreamUpdateBackpressure(stream4, backpressure);
        }
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
      }
      function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
        var stream4 = controller._controlledWritableStream;
        if (controller._started && stream4._inFlightWriteRequest === void 0) {
          var state = stream4._state;
          if (state === "erroring") {
            WritableStreamFinishErroring(stream4);
            return;
          }
          if (controller._queue.length !== 0) {
            var value = PeekQueueValue(controller);
            value === closeSentinel ? WritableStreamDefaultControllerProcessClose(controller) : WritableStreamDefaultControllerProcessWrite(controller, value);
          }
        }
      }
      function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {
        controller._controlledWritableStream._state === "writable" && WritableStreamDefaultControllerError(controller, error);
      }
      function WritableStreamDefaultControllerProcessClose(controller) {
        var stream4 = controller._controlledWritableStream;
        WritableStreamMarkCloseRequestInFlight(stream4), DequeueValue(controller);
        var sinkClosePromise = controller._closeAlgorithm();
        WritableStreamDefaultControllerClearAlgorithms(controller), uponPromise(sinkClosePromise, function() {
          WritableStreamFinishInFlightClose(stream4);
        }, function(reason) {
          WritableStreamFinishInFlightCloseWithError(stream4, reason);
        });
      }
      function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
        var stream4 = controller._controlledWritableStream;
        WritableStreamMarkFirstWriteRequestInFlight(stream4);
        var sinkWritePromise = controller._writeAlgorithm(chunk);
        uponPromise(sinkWritePromise, function() {
          WritableStreamFinishInFlightWrite(stream4);
          var state = stream4._state;
          if (DequeueValue(controller), !WritableStreamCloseQueuedOrInFlight(stream4) && state === "writable") {
            var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
            WritableStreamUpdateBackpressure(stream4, backpressure);
          }
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }, function(reason) {
          stream4._state === "writable" && WritableStreamDefaultControllerClearAlgorithms(controller), WritableStreamFinishInFlightWriteWithError(stream4, reason);
        });
      }
      function WritableStreamDefaultControllerGetBackpressure(controller) {
        var desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
        return desiredSize <= 0;
      }
      function WritableStreamDefaultControllerError(controller, error) {
        var stream4 = controller._controlledWritableStream;
        WritableStreamDefaultControllerClearAlgorithms(controller), WritableStreamStartErroring(stream4, error);
      }
      function streamBrandCheckException$2(name) {
        return new TypeError("WritableStream.prototype." + name + " can only be used on a WritableStream");
      }
      function defaultControllerBrandCheckException$2(name) {
        return new TypeError("WritableStreamDefaultController.prototype." + name + " can only be used on a WritableStreamDefaultController");
      }
      function defaultWriterBrandCheckException(name) {
        return new TypeError("WritableStreamDefaultWriter.prototype." + name + " can only be used on a WritableStreamDefaultWriter");
      }
      function defaultWriterLockException(name) {
        return new TypeError("Cannot " + name + " a stream using a released writer");
      }
      function defaultWriterClosedPromiseInitialize(writer) {
        writer._closedPromise = newPromise(function(resolve, reject) {
          writer._closedPromise_resolve = resolve, writer._closedPromise_reject = reject, writer._closedPromiseState = "pending";
        });
      }
      function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
        defaultWriterClosedPromiseInitialize(writer), defaultWriterClosedPromiseReject(writer, reason);
      }
      function defaultWriterClosedPromiseInitializeAsResolved(writer) {
        defaultWriterClosedPromiseInitialize(writer), defaultWriterClosedPromiseResolve(writer);
      }
      function defaultWriterClosedPromiseReject(writer, reason) {
        writer._closedPromise_reject !== void 0 && (setPromiseIsHandledToTrue(writer._closedPromise), writer._closedPromise_reject(reason), writer._closedPromise_resolve = void 0, writer._closedPromise_reject = void 0, writer._closedPromiseState = "rejected");
      }
      function defaultWriterClosedPromiseResetToRejected(writer, reason) {
        defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
      }
      function defaultWriterClosedPromiseResolve(writer) {
        writer._closedPromise_resolve !== void 0 && (writer._closedPromise_resolve(void 0), writer._closedPromise_resolve = void 0, writer._closedPromise_reject = void 0, writer._closedPromiseState = "resolved");
      }
      function defaultWriterReadyPromiseInitialize(writer) {
        writer._readyPromise = newPromise(function(resolve, reject) {
          writer._readyPromise_resolve = resolve, writer._readyPromise_reject = reject;
        }), writer._readyPromiseState = "pending";
      }
      function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
        defaultWriterReadyPromiseInitialize(writer), defaultWriterReadyPromiseReject(writer, reason);
      }
      function defaultWriterReadyPromiseInitializeAsResolved(writer) {
        defaultWriterReadyPromiseInitialize(writer), defaultWriterReadyPromiseResolve(writer);
      }
      function defaultWriterReadyPromiseReject(writer, reason) {
        writer._readyPromise_reject !== void 0 && (setPromiseIsHandledToTrue(writer._readyPromise), writer._readyPromise_reject(reason), writer._readyPromise_resolve = void 0, writer._readyPromise_reject = void 0, writer._readyPromiseState = "rejected");
      }
      function defaultWriterReadyPromiseReset(writer) {
        defaultWriterReadyPromiseInitialize(writer);
      }
      function defaultWriterReadyPromiseResetToRejected(writer, reason) {
        defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
      }
      function defaultWriterReadyPromiseResolve(writer) {
        writer._readyPromise_resolve !== void 0 && (writer._readyPromise_resolve(void 0), writer._readyPromise_resolve = void 0, writer._readyPromise_reject = void 0, writer._readyPromiseState = "fulfilled");
      }
      var NativeDOMException = typeof DOMException < "u" ? DOMException : void 0;
      function isDOMExceptionConstructor(ctor) {
        if (!(typeof ctor == "function" || typeof ctor == "object"))
          return !1;
        try {
          return new ctor(), !0;
        } catch {
          return !1;
        }
      }
      function createDOMExceptionPolyfill() {
        var ctor = function(message, name) {
          this.message = message || "", this.name = name || "Error", Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
        };
        return ctor.prototype = Object.create(Error.prototype), Object.defineProperty(ctor.prototype, "constructor", { value: ctor, writable: !0, configurable: !0 }), ctor;
      }
      var DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();
      function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
        var reader = AcquireReadableStreamDefaultReader(source), writer = AcquireWritableStreamDefaultWriter(dest);
        source._disturbed = !0;
        var shuttingDown = !1, currentWrite = promiseResolvedWith(void 0);
        return newPromise(function(resolve, reject) {
          var abortAlgorithm;
          if (signal !== void 0) {
            if (abortAlgorithm = function() {
              var error = new DOMException$1("Aborted", "AbortError"), actions = [];
              preventAbort || actions.push(function() {
                return dest._state === "writable" ? WritableStreamAbort(dest, error) : promiseResolvedWith(void 0);
              }), preventCancel || actions.push(function() {
                return source._state === "readable" ? ReadableStreamCancel(source, error) : promiseResolvedWith(void 0);
              }), shutdownWithAction(function() {
                return Promise.all(actions.map(function(action) {
                  return action();
                }));
              }, !0, error);
            }, signal.aborted) {
              abortAlgorithm();
              return;
            }
            signal.addEventListener("abort", abortAlgorithm);
          }
          function pipeLoop() {
            return newPromise(function(resolveLoop, rejectLoop) {
              function next(done) {
                done ? resolveLoop() : PerformPromiseThen(pipeStep(), next, rejectLoop);
              }
              next(!1);
            });
          }
          function pipeStep() {
            return shuttingDown ? promiseResolvedWith(!0) : PerformPromiseThen(writer._readyPromise, function() {
              return newPromise(function(resolveRead, rejectRead) {
                ReadableStreamDefaultReaderRead(reader, {
                  _chunkSteps: function(chunk) {
                    currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), void 0, noop2), resolveRead(!1);
                  },
                  _closeSteps: function() {
                    return resolveRead(!0);
                  },
                  _errorSteps: rejectRead
                });
              });
            });
          }
          if (isOrBecomesErrored(source, reader._closedPromise, function(storedError) {
            preventAbort ? shutdown(!0, storedError) : shutdownWithAction(function() {
              return WritableStreamAbort(dest, storedError);
            }, !0, storedError);
          }), isOrBecomesErrored(dest, writer._closedPromise, function(storedError) {
            preventCancel ? shutdown(!0, storedError) : shutdownWithAction(function() {
              return ReadableStreamCancel(source, storedError);
            }, !0, storedError);
          }), isOrBecomesClosed(source, reader._closedPromise, function() {
            preventClose ? shutdown() : shutdownWithAction(function() {
              return WritableStreamDefaultWriterCloseWithErrorPropagation(writer);
            });
          }), WritableStreamCloseQueuedOrInFlight(dest) || dest._state === "closed") {
            var destClosed_1 = new TypeError("the destination writable stream closed before all data could be piped to it");
            preventCancel ? shutdown(!0, destClosed_1) : shutdownWithAction(function() {
              return ReadableStreamCancel(source, destClosed_1);
            }, !0, destClosed_1);
          }
          setPromiseIsHandledToTrue(pipeLoop());
          function waitForWritesToFinish() {
            var oldCurrentWrite = currentWrite;
            return PerformPromiseThen(currentWrite, function() {
              return oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0;
            });
          }
          function isOrBecomesErrored(stream4, promise, action) {
            stream4._state === "errored" ? action(stream4._storedError) : uponRejection(promise, action);
          }
          function isOrBecomesClosed(stream4, promise, action) {
            stream4._state === "closed" ? action() : uponFulfillment(promise, action);
          }
          function shutdownWithAction(action, originalIsError, originalError) {
            if (shuttingDown)
              return;
            shuttingDown = !0, dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest) ? uponFulfillment(waitForWritesToFinish(), doTheRest) : doTheRest();
            function doTheRest() {
              uponPromise(action(), function() {
                return finalize(originalIsError, originalError);
              }, function(newError) {
                return finalize(!0, newError);
              });
            }
          }
          function shutdown(isError, error) {
            shuttingDown || (shuttingDown = !0, dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest) ? uponFulfillment(waitForWritesToFinish(), function() {
              return finalize(isError, error);
            }) : finalize(isError, error));
          }
          function finalize(isError, error) {
            WritableStreamDefaultWriterRelease(writer), ReadableStreamReaderGenericRelease(reader), signal !== void 0 && signal.removeEventListener("abort", abortAlgorithm), isError ? reject(error) : resolve(void 0);
          }
        });
      }
      var ReadableStreamDefaultController = (
        /** @class */
        function() {
          function ReadableStreamDefaultController2() {
            throw new TypeError("Illegal constructor");
          }
          return Object.defineProperty(ReadableStreamDefaultController2.prototype, "desiredSize", {
            /**
             * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
             * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.
             */
            get: function() {
              if (!IsReadableStreamDefaultController(this))
                throw defaultControllerBrandCheckException$1("desiredSize");
              return ReadableStreamDefaultControllerGetDesiredSize(this);
            },
            enumerable: !1,
            configurable: !0
          }), ReadableStreamDefaultController2.prototype.close = function() {
            if (!IsReadableStreamDefaultController(this))
              throw defaultControllerBrandCheckException$1("close");
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this))
              throw new TypeError("The stream is not in a state that permits close");
            ReadableStreamDefaultControllerClose(this);
          }, ReadableStreamDefaultController2.prototype.enqueue = function(chunk) {
            if (chunk === void 0 && (chunk = void 0), !IsReadableStreamDefaultController(this))
              throw defaultControllerBrandCheckException$1("enqueue");
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this))
              throw new TypeError("The stream is not in a state that permits enqueue");
            return ReadableStreamDefaultControllerEnqueue(this, chunk);
          }, ReadableStreamDefaultController2.prototype.error = function(e) {
            if (e === void 0 && (e = void 0), !IsReadableStreamDefaultController(this))
              throw defaultControllerBrandCheckException$1("error");
            ReadableStreamDefaultControllerError(this, e);
          }, ReadableStreamDefaultController2.prototype[CancelSteps] = function(reason) {
            ResetQueue(this);
            var result = this._cancelAlgorithm(reason);
            return ReadableStreamDefaultControllerClearAlgorithms(this), result;
          }, ReadableStreamDefaultController2.prototype[PullSteps] = function(readRequest) {
            var stream4 = this._controlledReadableStream;
            if (this._queue.length > 0) {
              var chunk = DequeueValue(this);
              this._closeRequested && this._queue.length === 0 ? (ReadableStreamDefaultControllerClearAlgorithms(this), ReadableStreamClose(stream4)) : ReadableStreamDefaultControllerCallPullIfNeeded(this), readRequest._chunkSteps(chunk);
            } else
              ReadableStreamAddReadRequest(stream4, readRequest), ReadableStreamDefaultControllerCallPullIfNeeded(this);
          }, ReadableStreamDefaultController2;
        }()
      );
      Object.defineProperties(ReadableStreamDefaultController.prototype, {
        close: { enumerable: !0 },
        enqueue: { enumerable: !0 },
        error: { enumerable: !0 },
        desiredSize: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableStreamDefaultController",
        configurable: !0
      });
      function IsReadableStreamDefaultController(x) {
        return !typeIsObject(x) || !Object.prototype.hasOwnProperty.call(x, "_controlledReadableStream") ? !1 : x instanceof ReadableStreamDefaultController;
      }
      function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
        var shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
        if (shouldPull) {
          if (controller._pulling) {
            controller._pullAgain = !0;
            return;
          }
          controller._pulling = !0;
          var pullPromise = controller._pullAlgorithm();
          uponPromise(pullPromise, function() {
            controller._pulling = !1, controller._pullAgain && (controller._pullAgain = !1, ReadableStreamDefaultControllerCallPullIfNeeded(controller));
          }, function(e) {
            ReadableStreamDefaultControllerError(controller, e);
          });
        }
      }
      function ReadableStreamDefaultControllerShouldCallPull(controller) {
        var stream4 = controller._controlledReadableStream;
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) || !controller._started)
          return !1;
        if (IsReadableStreamLocked(stream4) && ReadableStreamGetNumReadRequests(stream4) > 0)
          return !0;
        var desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
        return desiredSize > 0;
      }
      function ReadableStreamDefaultControllerClearAlgorithms(controller) {
        controller._pullAlgorithm = void 0, controller._cancelAlgorithm = void 0, controller._strategySizeAlgorithm = void 0;
      }
      function ReadableStreamDefaultControllerClose(controller) {
        if (ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          var stream4 = controller._controlledReadableStream;
          controller._closeRequested = !0, controller._queue.length === 0 && (ReadableStreamDefaultControllerClearAlgorithms(controller), ReadableStreamClose(stream4));
        }
      }
      function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
        if (ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
          var stream4 = controller._controlledReadableStream;
          if (IsReadableStreamLocked(stream4) && ReadableStreamGetNumReadRequests(stream4) > 0)
            ReadableStreamFulfillReadRequest(stream4, chunk, !1);
          else {
            var chunkSize = void 0;
            try {
              chunkSize = controller._strategySizeAlgorithm(chunk);
            } catch (chunkSizeE) {
              throw ReadableStreamDefaultControllerError(controller, chunkSizeE), chunkSizeE;
            }
            try {
              EnqueueValueWithSize(controller, chunk, chunkSize);
            } catch (enqueueE) {
              throw ReadableStreamDefaultControllerError(controller, enqueueE), enqueueE;
            }
          }
          ReadableStreamDefaultControllerCallPullIfNeeded(controller);
        }
      }
      function ReadableStreamDefaultControllerError(controller, e) {
        var stream4 = controller._controlledReadableStream;
        stream4._state === "readable" && (ResetQueue(controller), ReadableStreamDefaultControllerClearAlgorithms(controller), ReadableStreamError(stream4, e));
      }
      function ReadableStreamDefaultControllerGetDesiredSize(controller) {
        var state = controller._controlledReadableStream._state;
        return state === "errored" ? null : state === "closed" ? 0 : controller._strategyHWM - controller._queueTotalSize;
      }
      function ReadableStreamDefaultControllerHasBackpressure(controller) {
        return !ReadableStreamDefaultControllerShouldCallPull(controller);
      }
      function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
        var state = controller._controlledReadableStream._state;
        return !controller._closeRequested && state === "readable";
      }
      function SetUpReadableStreamDefaultController(stream4, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
        controller._controlledReadableStream = stream4, controller._queue = void 0, controller._queueTotalSize = void 0, ResetQueue(controller), controller._started = !1, controller._closeRequested = !1, controller._pullAgain = !1, controller._pulling = !1, controller._strategySizeAlgorithm = sizeAlgorithm, controller._strategyHWM = highWaterMark, controller._pullAlgorithm = pullAlgorithm, controller._cancelAlgorithm = cancelAlgorithm, stream4._readableStreamController = controller;
        var startResult = startAlgorithm();
        uponPromise(promiseResolvedWith(startResult), function() {
          controller._started = !0, ReadableStreamDefaultControllerCallPullIfNeeded(controller);
        }, function(r) {
          ReadableStreamDefaultControllerError(controller, r);
        });
      }
      function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream4, underlyingSource, highWaterMark, sizeAlgorithm) {
        var controller = Object.create(ReadableStreamDefaultController.prototype), startAlgorithm = function() {
        }, pullAlgorithm = function() {
          return promiseResolvedWith(void 0);
        }, cancelAlgorithm = function() {
          return promiseResolvedWith(void 0);
        };
        underlyingSource.start !== void 0 && (startAlgorithm = function() {
          return underlyingSource.start(controller);
        }), underlyingSource.pull !== void 0 && (pullAlgorithm = function() {
          return underlyingSource.pull(controller);
        }), underlyingSource.cancel !== void 0 && (cancelAlgorithm = function(reason) {
          return underlyingSource.cancel(reason);
        }), SetUpReadableStreamDefaultController(stream4, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
      }
      function defaultControllerBrandCheckException$1(name) {
        return new TypeError("ReadableStreamDefaultController.prototype." + name + " can only be used on a ReadableStreamDefaultController");
      }
      function ReadableStreamTee(stream4, cloneForBranch2) {
        return IsReadableByteStreamController(stream4._readableStreamController) ? ReadableByteStreamTee(stream4) : ReadableStreamDefaultTee(stream4);
      }
      function ReadableStreamDefaultTee(stream4, cloneForBranch2) {
        var reader = AcquireReadableStreamDefaultReader(stream4), reading = !1, readAgain = !1, canceled1 = !1, canceled2 = !1, reason1, reason2, branch1, branch2, resolveCancelPromise, cancelPromise = newPromise(function(resolve) {
          resolveCancelPromise = resolve;
        });
        function pullAlgorithm() {
          if (reading)
            return readAgain = !0, promiseResolvedWith(void 0);
          reading = !0;
          var readRequest = {
            _chunkSteps: function(chunk) {
              queueMicrotask(function() {
                readAgain = !1;
                var chunk1 = chunk, chunk2 = chunk;
                canceled1 || ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1), canceled2 || ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2), reading = !1, readAgain && pullAlgorithm();
              });
            },
            _closeSteps: function() {
              reading = !1, canceled1 || ReadableStreamDefaultControllerClose(branch1._readableStreamController), canceled2 || ReadableStreamDefaultControllerClose(branch2._readableStreamController), (!canceled1 || !canceled2) && resolveCancelPromise(void 0);
            },
            _errorSteps: function() {
              reading = !1;
            }
          };
          return ReadableStreamDefaultReaderRead(reader, readRequest), promiseResolvedWith(void 0);
        }
        function cancel1Algorithm(reason) {
          if (canceled1 = !0, reason1 = reason, canceled2) {
            var compositeReason = CreateArrayFromList([reason1, reason2]), cancelResult = ReadableStreamCancel(stream4, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function cancel2Algorithm(reason) {
          if (canceled2 = !0, reason2 = reason, canceled1) {
            var compositeReason = CreateArrayFromList([reason1, reason2]), cancelResult = ReadableStreamCancel(stream4, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function startAlgorithm() {
        }
        return branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm), branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm), uponRejection(reader._closedPromise, function(r) {
          ReadableStreamDefaultControllerError(branch1._readableStreamController, r), ReadableStreamDefaultControllerError(branch2._readableStreamController, r), (!canceled1 || !canceled2) && resolveCancelPromise(void 0);
        }), [branch1, branch2];
      }
      function ReadableByteStreamTee(stream4) {
        var reader = AcquireReadableStreamDefaultReader(stream4), reading = !1, readAgainForBranch1 = !1, readAgainForBranch2 = !1, canceled1 = !1, canceled2 = !1, reason1, reason2, branch1, branch2, resolveCancelPromise, cancelPromise = newPromise(function(resolve) {
          resolveCancelPromise = resolve;
        });
        function forwardReaderError(thisReader) {
          uponRejection(thisReader._closedPromise, function(r) {
            thisReader === reader && (ReadableByteStreamControllerError(branch1._readableStreamController, r), ReadableByteStreamControllerError(branch2._readableStreamController, r), (!canceled1 || !canceled2) && resolveCancelPromise(void 0));
          });
        }
        function pullWithDefaultReader() {
          IsReadableStreamBYOBReader(reader) && (ReadableStreamReaderGenericRelease(reader), reader = AcquireReadableStreamDefaultReader(stream4), forwardReaderError(reader));
          var readRequest = {
            _chunkSteps: function(chunk) {
              queueMicrotask(function() {
                readAgainForBranch1 = !1, readAgainForBranch2 = !1;
                var chunk1 = chunk, chunk2 = chunk;
                if (!canceled1 && !canceled2)
                  try {
                    chunk2 = CloneAsUint8Array(chunk);
                  } catch (cloneE) {
                    ReadableByteStreamControllerError(branch1._readableStreamController, cloneE), ReadableByteStreamControllerError(branch2._readableStreamController, cloneE), resolveCancelPromise(ReadableStreamCancel(stream4, cloneE));
                    return;
                  }
                canceled1 || ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1), canceled2 || ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2), reading = !1, readAgainForBranch1 ? pull1Algorithm() : readAgainForBranch2 && pull2Algorithm();
              });
            },
            _closeSteps: function() {
              reading = !1, canceled1 || ReadableByteStreamControllerClose(branch1._readableStreamController), canceled2 || ReadableByteStreamControllerClose(branch2._readableStreamController), branch1._readableStreamController._pendingPullIntos.length > 0 && ReadableByteStreamControllerRespond(branch1._readableStreamController, 0), branch2._readableStreamController._pendingPullIntos.length > 0 && ReadableByteStreamControllerRespond(branch2._readableStreamController, 0), (!canceled1 || !canceled2) && resolveCancelPromise(void 0);
            },
            _errorSteps: function() {
              reading = !1;
            }
          };
          ReadableStreamDefaultReaderRead(reader, readRequest);
        }
        function pullWithBYOBReader(view, forBranch2) {
          IsReadableStreamDefaultReader(reader) && (ReadableStreamReaderGenericRelease(reader), reader = AcquireReadableStreamBYOBReader(stream4), forwardReaderError(reader));
          var byobBranch = forBranch2 ? branch2 : branch1, otherBranch = forBranch2 ? branch1 : branch2, readIntoRequest = {
            _chunkSteps: function(chunk) {
              queueMicrotask(function() {
                readAgainForBranch1 = !1, readAgainForBranch2 = !1;
                var byobCanceled = forBranch2 ? canceled2 : canceled1, otherCanceled = forBranch2 ? canceled1 : canceled2;
                if (otherCanceled)
                  byobCanceled || ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                else {
                  var clonedChunk = void 0;
                  try {
                    clonedChunk = CloneAsUint8Array(chunk);
                  } catch (cloneE) {
                    ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE), ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE), resolveCancelPromise(ReadableStreamCancel(stream4, cloneE));
                    return;
                  }
                  byobCanceled || ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk), ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
                }
                reading = !1, readAgainForBranch1 ? pull1Algorithm() : readAgainForBranch2 && pull2Algorithm();
              });
            },
            _closeSteps: function(chunk) {
              reading = !1;
              var byobCanceled = forBranch2 ? canceled2 : canceled1, otherCanceled = forBranch2 ? canceled1 : canceled2;
              byobCanceled || ReadableByteStreamControllerClose(byobBranch._readableStreamController), otherCanceled || ReadableByteStreamControllerClose(otherBranch._readableStreamController), chunk !== void 0 && (byobCanceled || ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk), !otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0 && ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0)), (!byobCanceled || !otherCanceled) && resolveCancelPromise(void 0);
            },
            _errorSteps: function() {
              reading = !1;
            }
          };
          ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);
        }
        function pull1Algorithm() {
          if (reading)
            return readAgainForBranch1 = !0, promiseResolvedWith(void 0);
          reading = !0;
          var byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
          return byobRequest === null ? pullWithDefaultReader() : pullWithBYOBReader(byobRequest._view, !1), promiseResolvedWith(void 0);
        }
        function pull2Algorithm() {
          if (reading)
            return readAgainForBranch2 = !0, promiseResolvedWith(void 0);
          reading = !0;
          var byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
          return byobRequest === null ? pullWithDefaultReader() : pullWithBYOBReader(byobRequest._view, !0), promiseResolvedWith(void 0);
        }
        function cancel1Algorithm(reason) {
          if (canceled1 = !0, reason1 = reason, canceled2) {
            var compositeReason = CreateArrayFromList([reason1, reason2]), cancelResult = ReadableStreamCancel(stream4, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function cancel2Algorithm(reason) {
          if (canceled2 = !0, reason2 = reason, canceled1) {
            var compositeReason = CreateArrayFromList([reason1, reason2]), cancelResult = ReadableStreamCancel(stream4, compositeReason);
            resolveCancelPromise(cancelResult);
          }
          return cancelPromise;
        }
        function startAlgorithm() {
        }
        return branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm), branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm), forwardReaderError(reader), [branch1, branch2];
      }
      function convertUnderlyingDefaultOrByteSource(source, context) {
        assertDictionary(source, context);
        var original = source, autoAllocateChunkSize = original == null ? void 0 : original.autoAllocateChunkSize, cancel = original == null ? void 0 : original.cancel, pull = original == null ? void 0 : original.pull, start = original == null ? void 0 : original.start, type = original == null ? void 0 : original.type;
        return {
          autoAllocateChunkSize: autoAllocateChunkSize === void 0 ? void 0 : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, context + " has member 'autoAllocateChunkSize' that"),
          cancel: cancel === void 0 ? void 0 : convertUnderlyingSourceCancelCallback(cancel, original, context + " has member 'cancel' that"),
          pull: pull === void 0 ? void 0 : convertUnderlyingSourcePullCallback(pull, original, context + " has member 'pull' that"),
          start: start === void 0 ? void 0 : convertUnderlyingSourceStartCallback(start, original, context + " has member 'start' that"),
          type: type === void 0 ? void 0 : convertReadableStreamType(type, context + " has member 'type' that")
        };
      }
      function convertUnderlyingSourceCancelCallback(fn, original, context) {
        return assertFunction(fn, context), function(reason) {
          return promiseCall(fn, original, [reason]);
        };
      }
      function convertUnderlyingSourcePullCallback(fn, original, context) {
        return assertFunction(fn, context), function(controller) {
          return promiseCall(fn, original, [controller]);
        };
      }
      function convertUnderlyingSourceStartCallback(fn, original, context) {
        return assertFunction(fn, context), function(controller) {
          return reflectCall(fn, original, [controller]);
        };
      }
      function convertReadableStreamType(type, context) {
        if (type = "" + type, type !== "bytes")
          throw new TypeError(context + " '" + type + "' is not a valid enumeration value for ReadableStreamType");
        return type;
      }
      function convertReaderOptions(options, context) {
        assertDictionary(options, context);
        var mode = options == null ? void 0 : options.mode;
        return {
          mode: mode === void 0 ? void 0 : convertReadableStreamReaderMode(mode, context + " has member 'mode' that")
        };
      }
      function convertReadableStreamReaderMode(mode, context) {
        if (mode = "" + mode, mode !== "byob")
          throw new TypeError(context + " '" + mode + "' is not a valid enumeration value for ReadableStreamReaderMode");
        return mode;
      }
      function convertIteratorOptions(options, context) {
        assertDictionary(options, context);
        var preventCancel = options == null ? void 0 : options.preventCancel;
        return { preventCancel: Boolean(preventCancel) };
      }
      function convertPipeOptions(options, context) {
        assertDictionary(options, context);
        var preventAbort = options == null ? void 0 : options.preventAbort, preventCancel = options == null ? void 0 : options.preventCancel, preventClose = options == null ? void 0 : options.preventClose, signal = options == null ? void 0 : options.signal;
        return signal !== void 0 && assertAbortSignal(signal, context + " has member 'signal' that"), {
          preventAbort: Boolean(preventAbort),
          preventCancel: Boolean(preventCancel),
          preventClose: Boolean(preventClose),
          signal
        };
      }
      function assertAbortSignal(signal, context) {
        if (!isAbortSignal(signal))
          throw new TypeError(context + " is not an AbortSignal.");
      }
      function convertReadableWritablePair(pair, context) {
        assertDictionary(pair, context);
        var readable = pair == null ? void 0 : pair.readable;
        assertRequiredField(readable, "readable", "ReadableWritablePair"), assertReadableStream(readable, context + " has member 'readable' that");
        var writable = pair == null ? void 0 : pair.writable;
        return assertRequiredField(writable, "writable", "ReadableWritablePair"), assertWritableStream(writable, context + " has member 'writable' that"), { readable, writable };
      }
      var ReadableStream2 = (
        /** @class */
        function() {
          function ReadableStream3(rawUnderlyingSource, rawStrategy) {
            rawUnderlyingSource === void 0 && (rawUnderlyingSource = {}), rawStrategy === void 0 && (rawStrategy = {}), rawUnderlyingSource === void 0 ? rawUnderlyingSource = null : assertObject(rawUnderlyingSource, "First parameter");
            var strategy = convertQueuingStrategy(rawStrategy, "Second parameter"), underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, "First parameter");
            if (InitializeReadableStream(this), underlyingSource.type === "bytes") {
              if (strategy.size !== void 0)
                throw new RangeError("The strategy for a byte stream cannot have a size function");
              var highWaterMark = ExtractHighWaterMark(strategy, 0);
              SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
            } else {
              var sizeAlgorithm = ExtractSizeAlgorithm(strategy), highWaterMark = ExtractHighWaterMark(strategy, 1);
              SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
            }
          }
          return Object.defineProperty(ReadableStream3.prototype, "locked", {
            /**
             * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.
             */
            get: function() {
              if (!IsReadableStream(this))
                throw streamBrandCheckException$1("locked");
              return IsReadableStreamLocked(this);
            },
            enumerable: !1,
            configurable: !0
          }), ReadableStream3.prototype.cancel = function(reason) {
            return reason === void 0 && (reason = void 0), IsReadableStream(this) ? IsReadableStreamLocked(this) ? promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader")) : ReadableStreamCancel(this, reason) : promiseRejectedWith(streamBrandCheckException$1("cancel"));
          }, ReadableStream3.prototype.getReader = function(rawOptions) {
            if (rawOptions === void 0 && (rawOptions = void 0), !IsReadableStream(this))
              throw streamBrandCheckException$1("getReader");
            var options = convertReaderOptions(rawOptions, "First parameter");
            return options.mode === void 0 ? AcquireReadableStreamDefaultReader(this) : AcquireReadableStreamBYOBReader(this);
          }, ReadableStream3.prototype.pipeThrough = function(rawTransform, rawOptions) {
            if (rawOptions === void 0 && (rawOptions = {}), !IsReadableStream(this))
              throw streamBrandCheckException$1("pipeThrough");
            assertRequiredArgument(rawTransform, 1, "pipeThrough");
            var transform = convertReadableWritablePair(rawTransform, "First parameter"), options = convertPipeOptions(rawOptions, "Second parameter");
            if (IsReadableStreamLocked(this))
              throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
            if (IsWritableStreamLocked(transform.writable))
              throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
            var promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
            return setPromiseIsHandledToTrue(promise), transform.readable;
          }, ReadableStream3.prototype.pipeTo = function(destination, rawOptions) {
            if (rawOptions === void 0 && (rawOptions = {}), !IsReadableStream(this))
              return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
            if (destination === void 0)
              return promiseRejectedWith("Parameter 1 is required in 'pipeTo'.");
            if (!IsWritableStream(destination))
              return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));
            var options;
            try {
              options = convertPipeOptions(rawOptions, "Second parameter");
            } catch (e) {
              return promiseRejectedWith(e);
            }
            return IsReadableStreamLocked(this) ? promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream")) : IsWritableStreamLocked(destination) ? promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream")) : ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
          }, ReadableStream3.prototype.tee = function() {
            if (!IsReadableStream(this))
              throw streamBrandCheckException$1("tee");
            var branches = ReadableStreamTee(this);
            return CreateArrayFromList(branches);
          }, ReadableStream3.prototype.values = function(rawOptions) {
            if (rawOptions === void 0 && (rawOptions = void 0), !IsReadableStream(this))
              throw streamBrandCheckException$1("values");
            var options = convertIteratorOptions(rawOptions, "First parameter");
            return AcquireReadableStreamAsyncIterator(this, options.preventCancel);
          }, ReadableStream3;
        }()
      );
      Object.defineProperties(ReadableStream2.prototype, {
        cancel: { enumerable: !0 },
        getReader: { enumerable: !0 },
        pipeThrough: { enumerable: !0 },
        pipeTo: { enumerable: !0 },
        tee: { enumerable: !0 },
        values: { enumerable: !0 },
        locked: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.toStringTag, {
        value: "ReadableStream",
        configurable: !0
      }), typeof SymbolPolyfill.asyncIterator == "symbol" && Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.asyncIterator, {
        value: ReadableStream2.prototype.values,
        writable: !0,
        configurable: !0
      });
      function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
        highWaterMark === void 0 && (highWaterMark = 1), sizeAlgorithm === void 0 && (sizeAlgorithm = function() {
          return 1;
        });
        var stream4 = Object.create(ReadableStream2.prototype);
        InitializeReadableStream(stream4);
        var controller = Object.create(ReadableStreamDefaultController.prototype);
        return SetUpReadableStreamDefaultController(stream4, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm), stream4;
      }
      function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
        var stream4 = Object.create(ReadableStream2.prototype);
        InitializeReadableStream(stream4);
        var controller = Object.create(ReadableByteStreamController.prototype);
        return SetUpReadableByteStreamController(stream4, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, void 0), stream4;
      }
      function InitializeReadableStream(stream4) {
        stream4._state = "readable", stream4._reader = void 0, stream4._storedError = void 0, stream4._disturbed = !1;
      }
      function IsReadableStream(x) {
        return !typeIsObject(x) || !Object.prototype.hasOwnProperty.call(x, "_readableStreamController") ? !1 : x instanceof ReadableStream2;
      }
      function IsReadableStreamLocked(stream4) {
        return stream4._reader !== void 0;
      }
      function ReadableStreamCancel(stream4, reason) {
        if (stream4._disturbed = !0, stream4._state === "closed")
          return promiseResolvedWith(void 0);
        if (stream4._state === "errored")
          return promiseRejectedWith(stream4._storedError);
        ReadableStreamClose(stream4);
        var reader = stream4._reader;
        reader !== void 0 && IsReadableStreamBYOBReader(reader) && (reader._readIntoRequests.forEach(function(readIntoRequest) {
          readIntoRequest._closeSteps(void 0);
        }), reader._readIntoRequests = new SimpleQueue());
        var sourceCancelPromise = stream4._readableStreamController[CancelSteps](reason);
        return transformPromiseWith(sourceCancelPromise, noop2);
      }
      function ReadableStreamClose(stream4) {
        stream4._state = "closed";
        var reader = stream4._reader;
        reader !== void 0 && (defaultReaderClosedPromiseResolve(reader), IsReadableStreamDefaultReader(reader) && (reader._readRequests.forEach(function(readRequest) {
          readRequest._closeSteps();
        }), reader._readRequests = new SimpleQueue()));
      }
      function ReadableStreamError(stream4, e) {
        stream4._state = "errored", stream4._storedError = e;
        var reader = stream4._reader;
        reader !== void 0 && (defaultReaderClosedPromiseReject(reader, e), IsReadableStreamDefaultReader(reader) ? (reader._readRequests.forEach(function(readRequest) {
          readRequest._errorSteps(e);
        }), reader._readRequests = new SimpleQueue()) : (reader._readIntoRequests.forEach(function(readIntoRequest) {
          readIntoRequest._errorSteps(e);
        }), reader._readIntoRequests = new SimpleQueue()));
      }
      function streamBrandCheckException$1(name) {
        return new TypeError("ReadableStream.prototype." + name + " can only be used on a ReadableStream");
      }
      function convertQueuingStrategyInit(init, context) {
        assertDictionary(init, context);
        var highWaterMark = init == null ? void 0 : init.highWaterMark;
        return assertRequiredField(highWaterMark, "highWaterMark", "QueuingStrategyInit"), {
          highWaterMark: convertUnrestrictedDouble(highWaterMark)
        };
      }
      var byteLengthSizeFunction = function(chunk) {
        return chunk.byteLength;
      };
      try {
        Object.defineProperty(byteLengthSizeFunction, "name", {
          value: "size",
          configurable: !0
        });
      } catch {
      }
      var ByteLengthQueuingStrategy = (
        /** @class */
        function() {
          function ByteLengthQueuingStrategy2(options) {
            assertRequiredArgument(options, 1, "ByteLengthQueuingStrategy"), options = convertQueuingStrategyInit(options, "First parameter"), this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;
          }
          return Object.defineProperty(ByteLengthQueuingStrategy2.prototype, "highWaterMark", {
            /**
             * Returns the high water mark provided to the constructor.
             */
            get: function() {
              if (!IsByteLengthQueuingStrategy(this))
                throw byteLengthBrandCheckException("highWaterMark");
              return this._byteLengthQueuingStrategyHighWaterMark;
            },
            enumerable: !1,
            configurable: !0
          }), Object.defineProperty(ByteLengthQueuingStrategy2.prototype, "size", {
            /**
             * Measures the size of `chunk` by returning the value of its `byteLength` property.
             */
            get: function() {
              if (!IsByteLengthQueuingStrategy(this))
                throw byteLengthBrandCheckException("size");
              return byteLengthSizeFunction;
            },
            enumerable: !1,
            configurable: !0
          }), ByteLengthQueuingStrategy2;
        }()
      );
      Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
        highWaterMark: { enumerable: !0 },
        size: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
        value: "ByteLengthQueuingStrategy",
        configurable: !0
      });
      function byteLengthBrandCheckException(name) {
        return new TypeError("ByteLengthQueuingStrategy.prototype." + name + " can only be used on a ByteLengthQueuingStrategy");
      }
      function IsByteLengthQueuingStrategy(x) {
        return !typeIsObject(x) || !Object.prototype.hasOwnProperty.call(x, "_byteLengthQueuingStrategyHighWaterMark") ? !1 : x instanceof ByteLengthQueuingStrategy;
      }
      var countSizeFunction = function() {
        return 1;
      };
      try {
        Object.defineProperty(countSizeFunction, "name", {
          value: "size",
          configurable: !0
        });
      } catch {
      }
      var CountQueuingStrategy = (
        /** @class */
        function() {
          function CountQueuingStrategy2(options) {
            assertRequiredArgument(options, 1, "CountQueuingStrategy"), options = convertQueuingStrategyInit(options, "First parameter"), this._countQueuingStrategyHighWaterMark = options.highWaterMark;
          }
          return Object.defineProperty(CountQueuingStrategy2.prototype, "highWaterMark", {
            /**
             * Returns the high water mark provided to the constructor.
             */
            get: function() {
              if (!IsCountQueuingStrategy(this))
                throw countBrandCheckException("highWaterMark");
              return this._countQueuingStrategyHighWaterMark;
            },
            enumerable: !1,
            configurable: !0
          }), Object.defineProperty(CountQueuingStrategy2.prototype, "size", {
            /**
             * Measures the size of `chunk` by always returning 1.
             * This ensures that the total queue size is a count of the number of chunks in the queue.
             */
            get: function() {
              if (!IsCountQueuingStrategy(this))
                throw countBrandCheckException("size");
              return countSizeFunction;
            },
            enumerable: !1,
            configurable: !0
          }), CountQueuingStrategy2;
        }()
      );
      Object.defineProperties(CountQueuingStrategy.prototype, {
        highWaterMark: { enumerable: !0 },
        size: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
        value: "CountQueuingStrategy",
        configurable: !0
      });
      function countBrandCheckException(name) {
        return new TypeError("CountQueuingStrategy.prototype." + name + " can only be used on a CountQueuingStrategy");
      }
      function IsCountQueuingStrategy(x) {
        return !typeIsObject(x) || !Object.prototype.hasOwnProperty.call(x, "_countQueuingStrategyHighWaterMark") ? !1 : x instanceof CountQueuingStrategy;
      }
      function convertTransformer(original, context) {
        assertDictionary(original, context);
        var flush = original == null ? void 0 : original.flush, readableType = original == null ? void 0 : original.readableType, start = original == null ? void 0 : original.start, transform = original == null ? void 0 : original.transform, writableType = original == null ? void 0 : original.writableType;
        return {
          flush: flush === void 0 ? void 0 : convertTransformerFlushCallback(flush, original, context + " has member 'flush' that"),
          readableType,
          start: start === void 0 ? void 0 : convertTransformerStartCallback(start, original, context + " has member 'start' that"),
          transform: transform === void 0 ? void 0 : convertTransformerTransformCallback(transform, original, context + " has member 'transform' that"),
          writableType
        };
      }
      function convertTransformerFlushCallback(fn, original, context) {
        return assertFunction(fn, context), function(controller) {
          return promiseCall(fn, original, [controller]);
        };
      }
      function convertTransformerStartCallback(fn, original, context) {
        return assertFunction(fn, context), function(controller) {
          return reflectCall(fn, original, [controller]);
        };
      }
      function convertTransformerTransformCallback(fn, original, context) {
        return assertFunction(fn, context), function(chunk, controller) {
          return promiseCall(fn, original, [chunk, controller]);
        };
      }
      var TransformStream = (
        /** @class */
        function() {
          function TransformStream2(rawTransformer, rawWritableStrategy, rawReadableStrategy) {
            rawTransformer === void 0 && (rawTransformer = {}), rawWritableStrategy === void 0 && (rawWritableStrategy = {}), rawReadableStrategy === void 0 && (rawReadableStrategy = {}), rawTransformer === void 0 && (rawTransformer = null);
            var writableStrategy = convertQueuingStrategy(rawWritableStrategy, "Second parameter"), readableStrategy = convertQueuingStrategy(rawReadableStrategy, "Third parameter"), transformer = convertTransformer(rawTransformer, "First parameter");
            if (transformer.readableType !== void 0)
              throw new RangeError("Invalid readableType specified");
            if (transformer.writableType !== void 0)
              throw new RangeError("Invalid writableType specified");
            var readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0), readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy), writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1), writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy), startPromise_resolve, startPromise = newPromise(function(resolve) {
              startPromise_resolve = resolve;
            });
            InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm), SetUpTransformStreamDefaultControllerFromTransformer(this, transformer), transformer.start !== void 0 ? startPromise_resolve(transformer.start(this._transformStreamController)) : startPromise_resolve(void 0);
          }
          return Object.defineProperty(TransformStream2.prototype, "readable", {
            /**
             * The readable side of the transform stream.
             */
            get: function() {
              if (!IsTransformStream(this))
                throw streamBrandCheckException("readable");
              return this._readable;
            },
            enumerable: !1,
            configurable: !0
          }), Object.defineProperty(TransformStream2.prototype, "writable", {
            /**
             * The writable side of the transform stream.
             */
            get: function() {
              if (!IsTransformStream(this))
                throw streamBrandCheckException("writable");
              return this._writable;
            },
            enumerable: !1,
            configurable: !0
          }), TransformStream2;
        }()
      );
      Object.defineProperties(TransformStream.prototype, {
        readable: { enumerable: !0 },
        writable: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {
        value: "TransformStream",
        configurable: !0
      });
      function InitializeTransformStream(stream4, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
        function startAlgorithm() {
          return startPromise;
        }
        function writeAlgorithm(chunk) {
          return TransformStreamDefaultSinkWriteAlgorithm(stream4, chunk);
        }
        function abortAlgorithm(reason) {
          return TransformStreamDefaultSinkAbortAlgorithm(stream4, reason);
        }
        function closeAlgorithm() {
          return TransformStreamDefaultSinkCloseAlgorithm(stream4);
        }
        stream4._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
        function pullAlgorithm() {
          return TransformStreamDefaultSourcePullAlgorithm(stream4);
        }
        function cancelAlgorithm(reason) {
          return TransformStreamErrorWritableAndUnblockWrite(stream4, reason), promiseResolvedWith(void 0);
        }
        stream4._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm), stream4._backpressure = void 0, stream4._backpressureChangePromise = void 0, stream4._backpressureChangePromise_resolve = void 0, TransformStreamSetBackpressure(stream4, !0), stream4._transformStreamController = void 0;
      }
      function IsTransformStream(x) {
        return !typeIsObject(x) || !Object.prototype.hasOwnProperty.call(x, "_transformStreamController") ? !1 : x instanceof TransformStream;
      }
      function TransformStreamError(stream4, e) {
        ReadableStreamDefaultControllerError(stream4._readable._readableStreamController, e), TransformStreamErrorWritableAndUnblockWrite(stream4, e);
      }
      function TransformStreamErrorWritableAndUnblockWrite(stream4, e) {
        TransformStreamDefaultControllerClearAlgorithms(stream4._transformStreamController), WritableStreamDefaultControllerErrorIfNeeded(stream4._writable._writableStreamController, e), stream4._backpressure && TransformStreamSetBackpressure(stream4, !1);
      }
      function TransformStreamSetBackpressure(stream4, backpressure) {
        stream4._backpressureChangePromise !== void 0 && stream4._backpressureChangePromise_resolve(), stream4._backpressureChangePromise = newPromise(function(resolve) {
          stream4._backpressureChangePromise_resolve = resolve;
        }), stream4._backpressure = backpressure;
      }
      var TransformStreamDefaultController = (
        /** @class */
        function() {
          function TransformStreamDefaultController2() {
            throw new TypeError("Illegal constructor");
          }
          return Object.defineProperty(TransformStreamDefaultController2.prototype, "desiredSize", {
            /**
             * Returns the desired size to fill the readable sides internal queue. It can be negative, if the queue is over-full.
             */
            get: function() {
              if (!IsTransformStreamDefaultController(this))
                throw defaultControllerBrandCheckException("desiredSize");
              var readableController = this._controlledTransformStream._readable._readableStreamController;
              return ReadableStreamDefaultControllerGetDesiredSize(readableController);
            },
            enumerable: !1,
            configurable: !0
          }), TransformStreamDefaultController2.prototype.enqueue = function(chunk) {
            if (chunk === void 0 && (chunk = void 0), !IsTransformStreamDefaultController(this))
              throw defaultControllerBrandCheckException("enqueue");
            TransformStreamDefaultControllerEnqueue(this, chunk);
          }, TransformStreamDefaultController2.prototype.error = function(reason) {
            if (reason === void 0 && (reason = void 0), !IsTransformStreamDefaultController(this))
              throw defaultControllerBrandCheckException("error");
            TransformStreamDefaultControllerError(this, reason);
          }, TransformStreamDefaultController2.prototype.terminate = function() {
            if (!IsTransformStreamDefaultController(this))
              throw defaultControllerBrandCheckException("terminate");
            TransformStreamDefaultControllerTerminate(this);
          }, TransformStreamDefaultController2;
        }()
      );
      Object.defineProperties(TransformStreamDefaultController.prototype, {
        enqueue: { enumerable: !0 },
        error: { enumerable: !0 },
        terminate: { enumerable: !0 },
        desiredSize: { enumerable: !0 }
      }), typeof SymbolPolyfill.toStringTag == "symbol" && Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
        value: "TransformStreamDefaultController",
        configurable: !0
      });
      function IsTransformStreamDefaultController(x) {
        return !typeIsObject(x) || !Object.prototype.hasOwnProperty.call(x, "_controlledTransformStream") ? !1 : x instanceof TransformStreamDefaultController;
      }
      function SetUpTransformStreamDefaultController(stream4, controller, transformAlgorithm, flushAlgorithm) {
        controller._controlledTransformStream = stream4, stream4._transformStreamController = controller, controller._transformAlgorithm = transformAlgorithm, controller._flushAlgorithm = flushAlgorithm;
      }
      function SetUpTransformStreamDefaultControllerFromTransformer(stream4, transformer) {
        var controller = Object.create(TransformStreamDefaultController.prototype), transformAlgorithm = function(chunk) {
          try {
            return TransformStreamDefaultControllerEnqueue(controller, chunk), promiseResolvedWith(void 0);
          } catch (transformResultE) {
            return promiseRejectedWith(transformResultE);
          }
        }, flushAlgorithm = function() {
          return promiseResolvedWith(void 0);
        };
        transformer.transform !== void 0 && (transformAlgorithm = function(chunk) {
          return transformer.transform(chunk, controller);
        }), transformer.flush !== void 0 && (flushAlgorithm = function() {
          return transformer.flush(controller);
        }), SetUpTransformStreamDefaultController(stream4, controller, transformAlgorithm, flushAlgorithm);
      }
      function TransformStreamDefaultControllerClearAlgorithms(controller) {
        controller._transformAlgorithm = void 0, controller._flushAlgorithm = void 0;
      }
      function TransformStreamDefaultControllerEnqueue(controller, chunk) {
        var stream4 = controller._controlledTransformStream, readableController = stream4._readable._readableStreamController;
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController))
          throw new TypeError("Readable side is not in a state that permits enqueue");
        try {
          ReadableStreamDefaultControllerEnqueue(readableController, chunk);
        } catch (e) {
          throw TransformStreamErrorWritableAndUnblockWrite(stream4, e), stream4._readable._storedError;
        }
        var backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
        backpressure !== stream4._backpressure && TransformStreamSetBackpressure(stream4, !0);
      }
      function TransformStreamDefaultControllerError(controller, e) {
        TransformStreamError(controller._controlledTransformStream, e);
      }
      function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
        var transformPromise = controller._transformAlgorithm(chunk);
        return transformPromiseWith(transformPromise, void 0, function(r) {
          throw TransformStreamError(controller._controlledTransformStream, r), r;
        });
      }
      function TransformStreamDefaultControllerTerminate(controller) {
        var stream4 = controller._controlledTransformStream, readableController = stream4._readable._readableStreamController;
        ReadableStreamDefaultControllerClose(readableController);
        var error = new TypeError("TransformStream terminated");
        TransformStreamErrorWritableAndUnblockWrite(stream4, error);
      }
      function TransformStreamDefaultSinkWriteAlgorithm(stream4, chunk) {
        var controller = stream4._transformStreamController;
        if (stream4._backpressure) {
          var backpressureChangePromise = stream4._backpressureChangePromise;
          return transformPromiseWith(backpressureChangePromise, function() {
            var writable = stream4._writable, state = writable._state;
            if (state === "erroring")
              throw writable._storedError;
            return TransformStreamDefaultControllerPerformTransform(controller, chunk);
          });
        }
        return TransformStreamDefaultControllerPerformTransform(controller, chunk);
      }
      function TransformStreamDefaultSinkAbortAlgorithm(stream4, reason) {
        return TransformStreamError(stream4, reason), promiseResolvedWith(void 0);
      }
      function TransformStreamDefaultSinkCloseAlgorithm(stream4) {
        var readable = stream4._readable, controller = stream4._transformStreamController, flushPromise = controller._flushAlgorithm();
        return TransformStreamDefaultControllerClearAlgorithms(controller), transformPromiseWith(flushPromise, function() {
          if (readable._state === "errored")
            throw readable._storedError;
          ReadableStreamDefaultControllerClose(readable._readableStreamController);
        }, function(r) {
          throw TransformStreamError(stream4, r), readable._storedError;
        });
      }
      function TransformStreamDefaultSourcePullAlgorithm(stream4) {
        return TransformStreamSetBackpressure(stream4, !1), stream4._backpressureChangePromise;
      }
      function defaultControllerBrandCheckException(name) {
        return new TypeError("TransformStreamDefaultController.prototype." + name + " can only be used on a TransformStreamDefaultController");
      }
      function streamBrandCheckException(name) {
        return new TypeError("TransformStream.prototype." + name + " can only be used on a TransformStream");
      }
      exports2.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy, exports2.CountQueuingStrategy = CountQueuingStrategy, exports2.ReadableByteStreamController = ReadableByteStreamController, exports2.ReadableStream = ReadableStream2, exports2.ReadableStreamBYOBReader = ReadableStreamBYOBReader, exports2.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest, exports2.ReadableStreamDefaultController = ReadableStreamDefaultController, exports2.ReadableStreamDefaultReader = ReadableStreamDefaultReader, exports2.TransformStream = TransformStream, exports2.TransformStreamDefaultController = TransformStreamDefaultController, exports2.WritableStream = WritableStream, exports2.WritableStreamDefaultController = WritableStreamDefaultController, exports2.WritableStreamDefaultWriter = WritableStreamDefaultWriter, Object.defineProperty(exports2, "__esModule", { value: !0 });
    });
  }
});

// node_modules/@remix-run/web-stream/src/stream.cjs
var require_stream = __commonJS({
  "node_modules/@remix-run/web-stream/src/stream.cjs"(exports, module2) {
    module2.exports = require_ponyfill();
  }
});

// node_modules/@remix-run/web-blob/dist/src/blob.cjs
var require_blob = __commonJS({
  "node_modules/@remix-run/web-blob/dist/src/blob.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var webEncoding = require_lib(), webStream = require_stream(), WebBlob = class Blob3 {
      /**
       * @param {BlobPart[]} [init]
       * @param {BlobPropertyBag} [options]
       */
      constructor(init = [], options = {}) {
        let parts = [], size = 0;
        for (let part of init)
          if (typeof part == "string") {
            let bytes = new webEncoding.TextEncoder().encode(part);
            parts.push(bytes), size += bytes.byteLength;
          } else if (part instanceof WebBlob)
            size += part.size, parts.push(...part._parts);
          else if (part instanceof ArrayBuffer)
            parts.push(new Uint8Array(part)), size += part.byteLength;
          else if (part instanceof Uint8Array)
            parts.push(part), size += part.byteLength;
          else if (ArrayBuffer.isView(part)) {
            let { buffer, byteOffset, byteLength } = part;
            parts.push(new Uint8Array(buffer, byteOffset, byteLength)), size += byteLength;
          } else {
            let bytes = new webEncoding.TextEncoder().encode(String(part));
            parts.push(bytes), size += bytes.byteLength;
          }
        this._size = size, this._type = readType(options.type), this._parts = parts, Object.defineProperties(this, {
          _size: { enumerable: !1 },
          _type: { enumerable: !1 },
          _parts: { enumerable: !1 }
        });
      }
      /**
       * A string indicating the MIME type of the data contained in the Blob.
       * If the type is unknown, this string is empty.
       * @type {string}
       */
      get type() {
        return this._type;
      }
      /**
       * The size, in bytes, of the data contained in the Blob object.
       * @type {number}
       */
      get size() {
        return this._size;
      }
      /**
       * Returns a new Blob object containing the data in the specified range of
       * bytes of the blob on which it's called.
       * @param {number} [start=0] - An index into the Blob indicating the first
       * byte to include in the new Blob. If you specify a negative value, it's
       * treated as an offset from the end of the Blob toward the beginning. For
       * example, `-10` would be the 10th from last byte in the Blob. The default
       * value is `0`. If you specify a value for start that is larger than the
       * size of the source Blob, the returned Blob has size 0 and contains no
       * data.
       * @param {number} [end] - An index into the `Blob` indicating the first byte
       *  that will *not* be included in the new `Blob` (i.e. the byte exactly at
       * this index is not included). If you specify a negative value, it's treated
       * as an offset from the end of the Blob toward the beginning. For example,
       * `-10` would be the 10th from last byte in the `Blob`. The default value is
       * size.
       * @param {string} [type] - The content type to assign to the new Blob;
       * this will be the value of its type property. The default value is an empty
       * string.
       * @returns {Blob}
       */
      slice(start = 0, end = this.size, type = "") {
        let { size, _parts } = this, offset = start < 0 ? Math.max(size + start, 0) : Math.min(start, size), limit = end < 0 ? Math.max(size + end, 0) : Math.min(end, size), span = Math.max(limit - offset, 0), blob = new Blob3([], { type });
        if (span === 0)
          return blob;
        let blobSize = 0, blobParts = [];
        for (let part of _parts) {
          let { byteLength } = part;
          if (offset > 0 && byteLength <= offset)
            offset -= byteLength, limit -= byteLength;
          else {
            let chunk = part.subarray(offset, Math.min(byteLength, limit));
            if (blobParts.push(chunk), blobSize += chunk.byteLength, offset = 0, blobSize >= span)
              break;
          }
        }
        return blob._parts = blobParts, blob._size = blobSize, blob;
      }
      /**
       * Returns a promise that resolves with an ArrayBuffer containing the entire
       * contents of the Blob as binary data.
       * @returns {Promise<ArrayBuffer>}
       */
      // eslint-disable-next-line require-await
      async arrayBuffer() {
        let buffer = new ArrayBuffer(this.size), bytes = new Uint8Array(buffer), offset = 0;
        for (let part of this._parts)
          bytes.set(part, offset), offset += part.byteLength;
        return buffer;
      }
      /**
       * Returns a promise that resolves with a USVString containing the entire
       * contents of the Blob interpreted as UTF-8 text.
       * @returns {Promise<string>}
       */
      // eslint-disable-next-line require-await
      async text() {
        let decoder = new webEncoding.TextDecoder(), text = "";
        for (let part of this._parts)
          text += decoder.decode(part);
        return text;
      }
      /**
       * @returns {BlobStream}
       */
      stream() {
        return new BlobStream(this._parts);
      }
      /**
       * @returns {string}
       */
      toString() {
        return "[object Blob]";
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
    }, Blob2 = WebBlob, BlobStream = class extends webStream.ReadableStream {
      /**
       * @param {Uint8Array[]} chunks
       */
      constructor(chunks) {
        super(new BlobStreamController(chunks.values()), { type: "bytes" }), this._chunks = chunks;
      }
      /**
       * @param {Object} [_options]
       * @property {boolean} [_options.preventCancel]
       * @returns {AsyncIterator<Uint8Array>}
       */
      async *[Symbol.asyncIterator](_options) {
        let reader = this.getReader();
        yield* this._chunks, reader.releaseLock();
      }
    }, BlobStreamController = class {
      /**
       * @param {Iterator<Uint8Array>} chunks
       */
      constructor(chunks) {
        this.chunks = chunks;
      }
      /**
       * @param {ReadableStreamDefaultController} controller
       */
      start(controller) {
        this.work(controller), this.isWorking = !1, this.isCancelled = !1;
      }
      /**
       *
       * @param {ReadableStreamDefaultController} controller
       */
      async work(controller) {
        let { chunks } = this;
        for (this.isWorking = !0; !this.isCancelled && (controller.desiredSize || 0) > 0; ) {
          let next = null;
          try {
            next = chunks.next();
          } catch (error) {
            controller.error(error);
            break;
          }
          next && (!next.done && !this.isCancelled ? controller.enqueue(next.value) : controller.close());
        }
        this.isWorking = !1;
      }
      /**
       * @param {ReadableStreamDefaultController} controller
       */
      pull(controller) {
        this.isWorking || this.work(controller);
      }
      cancel() {
        this.isCancelled = !0;
      }
    }, readType = (input = "") => {
      let type = String(input).toLowerCase();
      return /[^\u0020-\u007E]/.test(type) ? "" : type;
    };
    Object.defineProperty(exports, "TextDecoder", {
      enumerable: !0,
      get: function() {
        return webEncoding.TextDecoder;
      }
    });
    Object.defineProperty(exports, "TextEncoder", {
      enumerable: !0,
      get: function() {
        return webEncoding.TextEncoder;
      }
    });
    Object.defineProperty(exports, "ReadableStream", {
      enumerable: !0,
      get: function() {
        return webStream.ReadableStream;
      }
    });
    exports.Blob = Blob2;
  }
});

// node_modules/@remix-run/web-blob/dist/src/lib.node.cjs
var require_lib_node = __commonJS({
  "node_modules/@remix-run/web-blob/dist/src/lib.node.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var webEncoding = require_lib(), webStream = require_stream(), blob = require_blob(), Blob2 = globalThis.Blob || // Disable node native blob until impractical perf issue is fixed
    // @see https://github.com/nodejs/node/issues/42108
    // NodeBlob ||
    blob.Blob;
    Object.defineProperty(exports, "TextDecoder", {
      enumerable: !0,
      get: function() {
        return webEncoding.TextDecoder;
      }
    });
    Object.defineProperty(exports, "TextEncoder", {
      enumerable: !0,
      get: function() {
        return webEncoding.TextEncoder;
      }
    });
    Object.defineProperty(exports, "ReadableStream", {
      enumerable: !0,
      get: function() {
        return webStream.ReadableStream;
      }
    });
    exports.Blob = Blob2;
  }
});

// node_modules/@remix-run/web-form-data/dist/src/form-data.cjs
var require_form_data = __commonJS({
  "node_modules/@remix-run/web-form-data/dist/src/form-data.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var FormData3 = class {
      /**
       * @param {HTMLFormElement} [form]
       */
      constructor(form) {
        if (this._entries = [], Object.defineProperty(this, "_entries", { enumerable: !1 }), isHTMLFormElement(form))
          for (let element of form.elements)
            if (isSelectElement(element))
              for (let option of element.options)
                option.selected && this.append(element.name, option.value);
            else
              isInputElement(element) && (element.checked || !["radio", "checkbox"].includes(element.type)) && element.name && this.append(element.name, element.value);
      }
      get [Symbol.toStringTag]() {
        return "FormData";
      }
      /**
       * Appends a new value onto an existing key inside a FormData object, or adds
       * the key if it does not already exist.
       *
       * The difference between `set` and `append` is that if the specified key
       * already exists, `set` will overwrite all existing values with the new one,
       * whereas `append` will append the new value onto the end of the existing
       * set of values.
       *
       * @param {string} name
       * @param {string|Blob|File} value - The name of the field whose data is
       * contained in value.
       * @param {string} [filename] - The filename reported to the server, when a
       * value is a `Blob` or a `File`. The default filename for a `Blob` objects is
       * `"blob"`. The default filename for a `File` is the it's name.
       */
      append(name, value = panic(
        new TypeError("FormData.append: requires at least 2 arguments")
      ), filename) {
        this._entries.push([name, toEntryValue(value, filename)]);
      }
      /**
       * Deletes a key and all its values from a FormData object.
       *
       * @param {string} name
       */
      delete(name = panic(new TypeError("FormData.delete: requires string argument"))) {
        let entries = this._entries, index = 0;
        for (; index < entries.length; ) {
          let [entryName] = (
            /** @type {[string, FormDataEntryValue]}*/
            entries[index]
          );
          entryName === name ? entries.splice(index, 1) : index++;
        }
      }
      /**
       * Returns the first value associated with a given key from within a
       * FormData object.
       *
       * @param {string} name
       * @returns {FormDataEntryValue|null}
       */
      get(name = panic(new TypeError("FormData.get: requires string argument"))) {
        for (let [entryName, value] of this._entries)
          if (entryName === name)
            return value;
        return null;
      }
      /**
       * Returns an array of all the values associated with a given key from within
       * a FormData.
       *
       * @param {string} name
       * @returns {FormDataEntryValue[]}
       */
      getAll(name = panic(new TypeError("FormData.getAll: requires string argument"))) {
        let values = [];
        for (let [entryName, value] of this._entries)
          entryName === name && values.push(value);
        return values;
      }
      /**
       * Returns a boolean stating whether a FormData object contains a certain key.
       *
       * @param {string} name
       */
      has(name = panic(new TypeError("FormData.has: requires string argument"))) {
        for (let [entryName] of this._entries)
          if (entryName === name)
            return !0;
        return !1;
      }
      /**
       * Sets a new value for an existing key inside a FormData object, or adds the
       * key/value if it does not already exist.
       *
       * @param {string} name
       * @param {string|Blob|File} value
       * @param {string} [filename]
       */
      set(name, value = panic(new TypeError("FormData.set: requires at least 2 arguments")), filename) {
        let index = 0, { _entries: entries } = this, entryValue = toEntryValue(value, filename), wasSet = !1;
        for (; index < entries.length; ) {
          let entry2 = (
            /** @type {[string, FormDataEntryValue]}*/
            entries[index]
          );
          entry2[0] === name ? wasSet ? entries.splice(index, 1) : (wasSet = !0, entry2[1] = entryValue, index++) : index++;
        }
        wasSet || entries.push([name, entryValue]);
      }
      /**
       * Method returns an iterator allowing to go through all key/value pairs
       * contained in this object.
       */
      entries() {
        return this._entries.values();
      }
      /**
       * Returns an iterator allowing to go through all keys of the key/value pairs
       * contained in this object.
       *
       * @returns {IterableIterator<string>}
       */
      *keys() {
        for (let [name] of this._entries)
          yield name;
      }
      /**
       * Returns an iterator allowing to go through all values contained in this
       * object.
       *
       * @returns {IterableIterator<FormDataEntryValue>}
       */
      *values() {
        for (let [_, value] of this._entries)
          yield value;
      }
      [Symbol.iterator]() {
        return this._entries.values();
      }
      /**
       * @param {(value: FormDataEntryValue, key: string, parent: globalThis.FormData) => void} fn
       * @param {any} [thisArg]
       * @returns {void}
       */
      forEach(fn, thisArg) {
        for (let [key, value] of this._entries)
          fn.call(thisArg, value, key, this);
      }
    }, isHTMLFormElement = (value) => Object.prototype.toString.call(value) === "[object HTMLFormElement]", toEntryValue = (value, filename) => {
      if (isFile2(value))
        return filename != null ? new BlobFile([value], filename, value) : value;
      if (isBlob2(value))
        return new BlobFile([value], filename ?? "blob");
      if (filename != null && filename != "")
        throw new TypeError(
          "filename is only supported when value is Blob or File"
        );
      return `${value}`;
    }, isFile2 = (value) => Object.prototype.toString.call(value) === "[object File]" && typeof value.name == "string", isBlob2 = (value) => Object.prototype.toString.call(value) === "[object Blob]", BlobFile = class {
      /**
       * @param {[Blob]} parts
       * @param {string} name
       * @param {FilePropertyBag} [options]
       */
      constructor([blob], name, { lastModified = Date.now() } = {}) {
        this.blob = blob, this.name = name, this.lastModified = lastModified;
      }
      get webkitRelativePath() {
        return "";
      }
      get size() {
        return this.blob.size;
      }
      get type() {
        return this.blob.type;
      }
      /**
       *
       * @param {number} [start]
       * @param {number} [end]
       * @param {string} [contentType]
       */
      slice(start, end, contentType) {
        return this.blob.slice(start, end, contentType);
      }
      stream() {
        return this.blob.stream();
      }
      text() {
        return this.blob.text();
      }
      arrayBuffer() {
        return this.blob.arrayBuffer();
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
    }, panic = (error) => {
      throw error;
    };
    function isSelectElement(element) {
      return element.tagName === "SELECT";
    }
    function isInputElement(element) {
      return element.tagName === "INPUT" || element.tagName === "TEXTAREA";
    }
    exports.FormData = FormData3;
  }
});

// node_modules/@remix-run/web-form-data/dist/src/lib.node.cjs
var require_lib_node2 = __commonJS({
  "node_modules/@remix-run/web-form-data/dist/src/lib.node.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var formData = require_form_data(), FormData3 = formData.FormData;
    exports.FormData = FormData3;
  }
});

// node_modules/@web3-storage/multipart-parser/cjs/src/utils.js
var require_utils = __commonJS({
  "node_modules/@web3-storage/multipart-parser/cjs/src/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    function stringToArray(s) {
      let utf8 = unescape(encodeURIComponent(s));
      return Uint8Array.from(utf8, (_, i) => utf8.charCodeAt(i));
    }
    function arrayToString(a) {
      let utf8 = String.fromCharCode.apply(null, a);
      return decodeURIComponent(escape(utf8));
    }
    function mergeArrays(...arrays) {
      let out = new Uint8Array(arrays.reduce((total, arr) => total + arr.length, 0)), offset = 0;
      for (let arr of arrays)
        out.set(arr, offset), offset += arr.length;
      return out;
    }
    function arraysEqual(a, b) {
      if (a.length !== b.length)
        return !1;
      for (let i = 0; i < a.length; i++)
        if (a[i] !== b[i])
          return !1;
      return !0;
    }
    exports.arrayToString = arrayToString;
    exports.arraysEqual = arraysEqual;
    exports.mergeArrays = mergeArrays;
    exports.stringToArray = stringToArray;
  }
});

// node_modules/@web3-storage/multipart-parser/cjs/src/search.js
var require_search = __commonJS({
  "node_modules/@web3-storage/multipart-parser/cjs/src/search.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var utils = require_utils();
    function coerce(a) {
      return a instanceof Uint8Array ? (index) => a[index] : a;
    }
    function jsmemcmp(buf1, pos1, buf2, pos2, len) {
      let fn1 = coerce(buf1), fn2 = coerce(buf2);
      for (let i = 0; i < len; ++i)
        if (fn1(pos1 + i) !== fn2(pos2 + i))
          return !1;
      return !0;
    }
    function createOccurenceTable(s) {
      let table = new Array(256).fill(s.length);
      if (s.length > 1)
        for (let i = 0; i < s.length - 1; i++)
          table[s[i]] = s.length - 1 - i;
      return table;
    }
    var MATCH = Symbol("Match"), StreamSearch = class {
      constructor(needle) {
        this._lookbehind = new Uint8Array(), typeof needle == "string" ? this._needle = needle = utils.stringToArray(needle) : this._needle = needle, this._lastChar = needle[needle.length - 1], this._occ = createOccurenceTable(needle);
      }
      feed(chunk) {
        let pos = 0, tokens, allTokens = [];
        for (; pos !== chunk.length; )
          [pos, ...tokens] = this._feed(chunk, pos), allTokens.push(...tokens);
        return allTokens;
      }
      end() {
        let tail = this._lookbehind;
        return this._lookbehind = new Uint8Array(), tail;
      }
      _feed(data, bufPos) {
        let tokens = [], pos = -this._lookbehind.length;
        if (pos < 0) {
          for (; pos < 0 && pos <= data.length - this._needle.length; ) {
            let ch = this._charAt(data, pos + this._needle.length - 1);
            if (ch === this._lastChar && this._memcmp(data, pos, this._needle.length - 1))
              return pos > -this._lookbehind.length && tokens.push(this._lookbehind.slice(0, this._lookbehind.length + pos)), tokens.push(MATCH), this._lookbehind = new Uint8Array(), [
                pos + this._needle.length,
                ...tokens
              ];
            pos += this._occ[ch];
          }
          if (pos < 0)
            for (; pos < 0 && !this._memcmp(data, pos, data.length - pos); )
              pos++;
          if (pos >= 0)
            tokens.push(this._lookbehind), this._lookbehind = new Uint8Array();
          else {
            let bytesToCutOff = this._lookbehind.length + pos;
            return bytesToCutOff > 0 && (tokens.push(this._lookbehind.slice(0, bytesToCutOff)), this._lookbehind = this._lookbehind.slice(bytesToCutOff)), this._lookbehind = Uint8Array.from(new Array(this._lookbehind.length + data.length), (_, i) => this._charAt(data, i - this._lookbehind.length)), [
              data.length,
              ...tokens
            ];
          }
        }
        for (pos += bufPos; pos <= data.length - this._needle.length; ) {
          let ch = data[pos + this._needle.length - 1];
          if (ch === this._lastChar && data[pos] === this._needle[0] && jsmemcmp(this._needle, 0, data, pos, this._needle.length - 1))
            return pos > bufPos && tokens.push(data.slice(bufPos, pos)), tokens.push(MATCH), [
              pos + this._needle.length,
              ...tokens
            ];
          pos += this._occ[ch];
        }
        if (pos < data.length) {
          for (; pos < data.length && (data[pos] !== this._needle[0] || !jsmemcmp(data, pos, this._needle, 0, data.length - pos)); )
            ++pos;
          pos < data.length && (this._lookbehind = data.slice(pos));
        }
        return pos > 0 && tokens.push(data.slice(bufPos, pos < data.length ? pos : data.length)), [
          data.length,
          ...tokens
        ];
      }
      _charAt(data, pos) {
        return pos < 0 ? this._lookbehind[this._lookbehind.length + pos] : data[pos];
      }
      _memcmp(data, pos, len) {
        return jsmemcmp(this._charAt.bind(this, data), pos, this._needle, 0, len);
      }
    }, ReadableStreamSearch = class {
      constructor(needle, _readableStream) {
        this._readableStream = _readableStream, this._search = new StreamSearch(needle);
      }
      async *[Symbol.asyncIterator]() {
        let reader = this._readableStream.getReader();
        try {
          for (; ; ) {
            let result = await reader.read();
            if (result.done)
              break;
            yield* this._search.feed(result.value);
          }
          let tail = this._search.end();
          tail.length && (yield tail);
        } finally {
          reader.releaseLock();
        }
      }
    }, EOQ = Symbol("End of Queue"), QueueableStreamSearch = class {
      constructor(needle) {
        this._chunksQueue = [], this._closed = !1, this._search = new StreamSearch(needle);
      }
      push(...chunks) {
        if (this._closed)
          throw new Error("cannot call push after close");
        this._chunksQueue.push(...chunks), this._notify && this._notify();
      }
      close() {
        if (this._closed)
          throw new Error("close was already called");
        this._closed = !0, this._chunksQueue.push(EOQ), this._notify && this._notify();
      }
      async *[Symbol.asyncIterator]() {
        for (; ; ) {
          let chunk;
          for (; !(chunk = this._chunksQueue.shift()); )
            await new Promise((resolve) => this._notify = resolve), this._notify = void 0;
          if (chunk === EOQ)
            break;
          yield* this._search.feed(chunk);
        }
        let tail = this._search.end();
        tail.length && (yield tail);
      }
    };
    function splitChunks(chunks, needle) {
      let search = new StreamSearch(needle), outchunks = [[]];
      for (let chunk of chunks)
        for (let token of search.feed(chunk))
          token === MATCH ? outchunks.push([]) : outchunks[outchunks.length - 1].push(token);
      let end = search.end();
      return outchunks[outchunks.length - 1].push(end), outchunks.map((chunks2) => utils.mergeArrays(...chunks2));
    }
    function split(buf, needle) {
      return splitChunks([buf], needle);
    }
    async function* chunksIterator(iter) {
      let chunks = [];
      for await (let value of iter)
        value === MATCH ? (yield chunks, chunks = []) : chunks.push(value);
      yield chunks;
    }
    async function* stringIterator(iter) {
      for await (let chunk of chunksIterator(iter))
        yield chunk.map(utils.arrayToString).join("");
    }
    async function allStrings(iter) {
      let segments = [];
      for await (let value of stringIterator(iter))
        segments.push(value);
      return segments;
    }
    async function* arrayIterator(iter) {
      for await (let chunk of chunksIterator(iter))
        yield utils.mergeArrays(...chunk);
    }
    exports.MATCH = MATCH;
    exports.QueueableStreamSearch = QueueableStreamSearch;
    exports.ReadableStreamSearch = ReadableStreamSearch;
    exports.StreamSearch = StreamSearch;
    exports.allStrings = allStrings;
    exports.arrayIterator = arrayIterator;
    exports.chunksIterator = chunksIterator;
    exports.split = split;
    exports.splitChunks = splitChunks;
    exports.stringIterator = stringIterator;
  }
});

// node_modules/@web3-storage/multipart-parser/cjs/src/index.js
var require_src2 = __commonJS({
  "node_modules/@web3-storage/multipart-parser/cjs/src/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var search = require_search(), utils = require_utils(), mergeArrays2 = Function.prototype.apply.bind(utils.mergeArrays, void 0), dash = utils.stringToArray("--"), CRLF2 = utils.stringToArray(`\r
`);
    function parseContentDisposition(header) {
      let parts = header.split(";").map((part) => part.trim());
      if (parts.shift() !== "form-data")
        throw new Error('malformed content-disposition header: missing "form-data" in `' + JSON.stringify(parts) + "`");
      let out = {};
      for (let part of parts) {
        let kv = part.split("=", 2);
        if (kv.length !== 2)
          throw new Error("malformed content-disposition header: key-value pair not found - " + part + " in `" + header + "`");
        let [name, value] = kv;
        if (value[0] === '"' && value[value.length - 1] === '"')
          out[name] = value.slice(1, -1).replace(/\\"/g, '"');
        else if (value[0] !== '"' && value[value.length - 1] !== '"')
          out[name] = value;
        else if (value[0] === '"' && value[value.length - 1] !== '"' || value[0] !== '"' && value[value.length - 1] === '"')
          throw new Error("malformed content-disposition header: mismatched quotations in `" + header + "`");
      }
      if (!out.name)
        throw new Error("malformed content-disposition header: missing field name in `" + header + "`");
      return out;
    }
    function parsePartHeaders(lines) {
      let entries = [], disposition = !1, line;
      for (; typeof (line = lines.shift()) < "u"; ) {
        let colon = line.indexOf(":");
        if (colon === -1)
          throw new Error("malformed multipart-form header: missing colon");
        let header = line.slice(0, colon).trim().toLowerCase(), value = line.slice(colon + 1).trim();
        switch (header) {
          case "content-disposition":
            disposition = !0, entries.push(...Object.entries(parseContentDisposition(value)));
            break;
          case "content-type":
            entries.push([
              "contentType",
              value
            ]);
        }
      }
      if (!disposition)
        throw new Error("malformed multipart-form header: missing content-disposition");
      return Object.fromEntries(entries);
    }
    async function readHeaderLines(it, needle) {
      let firstChunk = !0, lastTokenWasMatch = !1, headerLines = [[]], crlfSearch = new search.StreamSearch(CRLF2);
      for (; ; ) {
        let result = await it.next();
        if (result.done)
          throw new Error("malformed multipart-form data: unexpected end of stream");
        if (firstChunk && result.value !== search.MATCH && utils.arraysEqual(result.value.slice(0, 2), dash))
          return [
            void 0,
            new Uint8Array()
          ];
        let chunk;
        if (result.value !== search.MATCH)
          chunk = result.value;
        else if (!lastTokenWasMatch)
          chunk = needle;
        else
          throw new Error("malformed multipart-form data: unexpected boundary");
        if (!chunk.length)
          continue;
        firstChunk && (firstChunk = !1);
        let tokens = crlfSearch.feed(chunk);
        for (let [i, token] of tokens.entries()) {
          let isMatch = token === search.MATCH;
          if (!(!isMatch && !token.length)) {
            if (lastTokenWasMatch && isMatch)
              return tokens.push(crlfSearch.end()), [
                headerLines.filter((chunks) => chunks.length).map(mergeArrays2).map(utils.arrayToString),
                utils.mergeArrays(...tokens.slice(i + 1).map((token2) => token2 === search.MATCH ? CRLF2 : token2))
              ];
            (lastTokenWasMatch = isMatch) ? headerLines.push([]) : headerLines[headerLines.length - 1].push(token);
          }
        }
      }
    }
    async function* streamMultipart(body, boundary) {
      let needle = utils.mergeArrays(dash, utils.stringToArray(boundary)), it = new search.ReadableStreamSearch(needle, body)[Symbol.asyncIterator]();
      for (; ; ) {
        let result = await it.next();
        if (result.done)
          return;
        if (result.value === search.MATCH)
          break;
      }
      let crlfSearch = new search.StreamSearch(CRLF2);
      for (; ; ) {
        let feedChunk = function(chunk) {
          let chunks = [];
          for (let token of crlfSearch.feed(chunk))
            trailingCRLF && chunks.push(CRLF2), (trailingCRLF = token === search.MATCH) || chunks.push(token);
          return utils.mergeArrays(...chunks);
        }, [headerLines, tail] = await readHeaderLines(it, needle);
        if (!headerLines)
          return;
        async function nextToken() {
          let result = await it.next();
          if (result.done)
            throw new Error("malformed multipart-form data: unexpected end of stream");
          return result;
        }
        let trailingCRLF = !1, done = !1;
        async function nextChunk() {
          let result = await nextToken(), chunk;
          if (result.value !== search.MATCH)
            chunk = result.value;
          else if (!trailingCRLF)
            chunk = CRLF2;
          else
            return done = !0, { value: crlfSearch.end() };
          return { value: feedChunk(chunk) };
        }
        let bufferedChunks = [{ value: feedChunk(tail) }];
        for (yield {
          ...parsePartHeaders(headerLines),
          data: {
            [Symbol.asyncIterator]() {
              return this;
            },
            async next() {
              for (; ; ) {
                let result = bufferedChunks.shift();
                if (!result)
                  break;
                if (result.value.length > 0)
                  return result;
              }
              for (; ; ) {
                if (done)
                  return {
                    done,
                    value: void 0
                  };
                let result = await nextChunk();
                if (result.value.length > 0)
                  return result;
              }
            }
          }
        }; !done; )
          bufferedChunks.push(await nextChunk());
      }
    }
    async function* iterateMultipart(body, boundary) {
      for await (let part of streamMultipart(body, boundary)) {
        let chunks = [];
        for await (let chunk of part.data)
          chunks.push(chunk);
        yield {
          ...part,
          data: utils.mergeArrays(...chunks)
        };
      }
    }
    exports.iterateMultipart = iterateMultipart;
    exports.streamMultipart = streamMultipart;
  }
});

// node_modules/@remix-run/web-fetch/dist/lib.node.cjs
var require_lib_node3 = __commonJS({
  "node_modules/@remix-run/web-fetch/dist/lib.node.cjs"(exports, module2) {
    "use strict";
    var http2 = require("http"), https2 = require("https"), zlib2 = require("zlib"), fs = require("fs"), mime = require_mrmime(), dataUriToBuffer = require_src(), Stream = require("stream"), util2 = require("util"), webBlob = require_lib_node(), webFormData = require_lib_node2(), crypto = require("crypto"), multipartParser = require_src2(), url2 = require("url"), abortController = require_abort_controller(), FetchBaseError = class extends Error {
      /**
       * @param {string} message 
       * @param {string} type 
       */
      constructor(message, type) {
        super(message), Error.captureStackTrace(this, this.constructor), this.type = type;
      }
      get name() {
        return this.constructor.name;
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
    }, FetchError = class extends FetchBaseError {
      /**
       * @param  {string} message -      Error message for human
       * @param  {string} type -        Error type for machine
       * @param  {SystemError} [systemError] - For Node.js system error
       */
      constructor(message, type, systemError) {
        super(message, type), systemError && (this.code = this.errno = systemError.code, this.erroredSysCall = systemError.syscall);
      }
    }, NAME = Symbol.toStringTag, isURLSearchParameters = (object) => typeof object == "object" && typeof object.append == "function" && typeof object.delete == "function" && typeof object.get == "function" && typeof object.getAll == "function" && typeof object.has == "function" && typeof object.set == "function" && typeof object.sort == "function" && object[NAME] === "URLSearchParams", isBlob2 = (object) => typeof object == "object" && typeof object.arrayBuffer == "function" && typeof object.type == "string" && typeof object.stream == "function" && typeof object.constructor == "function" && /^(Blob|File)$/.test(object[NAME]);
    function isFormData2(object) {
      return typeof object == "object" && typeof object.append == "function" && typeof object.set == "function" && typeof object.get == "function" && typeof object.getAll == "function" && typeof object.delete == "function" && typeof object.keys == "function" && typeof object.values == "function" && typeof object.entries == "function" && typeof object.constructor == "function" && object[NAME] === "FormData";
    }
    var isMultipartFormDataStream = (value) => value instanceof Stream && typeof value.getBoundary == "function" && typeof value.hasKnownLength == "function" && typeof value.getLengthSync == "function", isAbortSignal = (object) => typeof object == "object" && (object[NAME] === "AbortSignal" || object[NAME] === "EventTarget"), isReadableStream = (value) => typeof value == "object" && typeof value.getReader == "function" && typeof value.cancel == "function" && typeof value.tee == "function", isIterable = (value) => value && Symbol.iterator in value, carriage = `\r
`, dashes = "-".repeat(2), carriageLength = Buffer.byteLength(carriage), getFooter = (boundary) => `${dashes}${boundary}${dashes}${carriage.repeat(2)}`;
    function getHeader(boundary, name, field) {
      let header = "";
      if (header += `${dashes}${boundary}${carriage}`, header += `Content-Disposition: form-data; name="${name}"`, isBlob2(field)) {
        let { name: name2 = "blob", type } = (
          /** @type {Blob & {name?:string}} */
          field
        );
        header += `; filename="${name2}"${carriage}`, header += `Content-Type: ${type || "application/octet-stream"}`;
      }
      return `${header}${carriage.repeat(2)}`;
    }
    var getBoundary = () => crypto.randomBytes(8).toString("hex");
    async function* formDataIterator(form, boundary) {
      let encoder2 = new TextEncoder();
      for (let [name, value] of form)
        yield encoder2.encode(getHeader(boundary, name, value)), isBlob2(value) ? yield* value.stream() : yield encoder2.encode(value), yield encoder2.encode(carriage);
      yield encoder2.encode(getFooter(boundary));
    }
    function getFormDataLength(form, boundary) {
      let length = 0;
      for (let [name, value] of form)
        length += Buffer.byteLength(getHeader(boundary, name, value)), isBlob2(value) ? length += value.size : length += Buffer.byteLength(String(value)), length += carriageLength;
      return length += Buffer.byteLength(getFooter(boundary)), length;
    }
    var toFormData3 = async (source) => {
      let { body, headers } = source, contentType = (headers == null ? void 0 : headers.get("Content-Type")) || "";
      if (contentType.startsWith("application/x-www-form-urlencoded") && body != null) {
        let form = new webFormData.FormData(), bodyText = await source.text();
        return new URLSearchParams(bodyText).forEach((v, k) => form.append(k, v)), form;
      }
      let [type, boundary] = contentType.split(/\s*;\s*boundary=/);
      if (type === "multipart/form-data" && boundary != null && body != null) {
        let form = new webFormData.FormData(), parts = multipartParser.iterateMultipart(body, boundary);
        for await (let { name, data, filename, contentType: contentType2 } of parts)
          filename ? form.append(name, new File([data], filename, { type: contentType2 })) : form.append(name, new TextDecoder().decode(data), filename);
        return form;
      } else
        throw new TypeError("Could not parse content as FormData.");
    }, encoder = new util2.TextEncoder(), decoder = new util2.TextDecoder(), encode3 = (text) => encoder.encode(text), decode = (bytes) => decoder.decode(bytes), { readableHighWaterMark } = new Stream.Readable(), INTERNALS$2 = Symbol("Body internals"), Body = class {
      /**
       * @param {BodyInit|Stream|null} body
       * @param {{size?:number}} options
       */
      constructor(body, {
        size = 0
      } = {}) {
        let state = {
          /** @type {null|ReadableStream<Uint8Array>} */
          body: null,
          /** @type {string|null} */
          type: null,
          /** @type {number|null} */
          size: null,
          /** @type {null|string} */
          boundary: null,
          disturbed: !1,
          /** @type {null|Error} */
          error: null
        };
        if (this[INTERNALS$2] = state, body === null)
          state.body = null, state.size = 0;
        else if (isURLSearchParameters(body)) {
          let bytes = encode3(body.toString());
          state.body = fromBytes(bytes), state.size = bytes.byteLength, state.type = "application/x-www-form-urlencoded;charset=UTF-8";
        } else if (isBlob2(body))
          state.size = body.size, state.type = body.type || null, state.body = body.stream();
        else if (body instanceof Uint8Array)
          state.body = fromBytes(body), state.size = body.byteLength;
        else if (util2.types.isAnyArrayBuffer(body)) {
          let bytes = new Uint8Array(body);
          state.body = fromBytes(bytes), state.size = bytes.byteLength;
        } else if (ArrayBuffer.isView(body)) {
          let bytes = new Uint8Array(body.buffer, body.byteOffset, body.byteLength);
          state.body = fromBytes(bytes), state.size = bytes.byteLength;
        } else if (isReadableStream(body))
          state.body = body;
        else if (isFormData2(body)) {
          let boundary = `NodeFetchFormDataBoundary${getBoundary()}`;
          state.type = `multipart/form-data; boundary=${boundary}`, state.size = getFormDataLength(body, boundary), state.body = fromAsyncIterable(formDataIterator(body, boundary));
        } else if (isMultipartFormDataStream(body))
          state.type = `multipart/form-data; boundary=${body.getBoundary()}`, state.size = body.hasKnownLength() ? body.getLengthSync() : null, state.body = fromStream(body);
        else if (body instanceof Stream)
          state.body = fromStream(body);
        else {
          let bytes = encode3(String(body));
          state.type = "text/plain;charset=UTF-8", state.size = bytes.byteLength, state.body = fromBytes(bytes);
        }
        this.size = size;
      }
      /** @type {Headers} */
      /* c8 ignore next 3 */
      get headers() {
        throw new TypeError("'get headers' called on an object that does not implements interface.");
      }
      get body() {
        return this[INTERNALS$2].body;
      }
      get bodyUsed() {
        return this[INTERNALS$2].disturbed;
      }
      /**
       * Decode response as ArrayBuffer
       *
       * @return {Promise<ArrayBuffer>}
       */
      async arrayBuffer() {
        let { buffer, byteOffset, byteLength } = await consumeBody(this);
        return buffer.slice(byteOffset, byteOffset + byteLength);
      }
      /**
       * Return raw response as Blob
       *
       * @return Promise
       */
      async blob() {
        let ct = this.headers && this.headers.get("content-type") || this[INTERNALS$2].body && this[INTERNALS$2].type || "", buf = await consumeBody(this);
        return new webBlob.Blob([buf], {
          type: ct
        });
      }
      /**
       * Decode response as json
       *
       * @return  Promise
       */
      async json() {
        return JSON.parse(await this.text());
      }
      /**
       * Decode response as text
       *
       * @return  Promise
       */
      async text() {
        let buffer = await consumeBody(this);
        return decode(buffer);
      }
      /**
       * @returns {Promise<FormData>}
       */
      async formData() {
        return toFormData3(this);
      }
    };
    Object.defineProperties(Body.prototype, {
      body: { enumerable: !0 },
      bodyUsed: { enumerable: !0 },
      arrayBuffer: { enumerable: !0 },
      blob: { enumerable: !0 },
      json: { enumerable: !0 },
      text: { enumerable: !0 },
      formData: { enumerable: !0 }
    });
    async function consumeBody(data) {
      let state = data[INTERNALS$2];
      if (state.disturbed)
        throw new TypeError(`body used already for: ${data.url}`);
      if (state.disturbed = !0, state.error)
        throw state.error;
      let { body } = state;
      if (body === null)
        return new Uint8Array(0);
      let [buffer, chunks, limit] = data.size > 0 ? [new Uint8Array(data.size), [], data.size] : [null, [], 1 / 0], offset = 0, source = streamIterator(body);
      try {
        for await (let chunk of source) {
          let bytes = chunk instanceof Uint8Array ? chunk : Buffer.from(chunk);
          if (offset + bytes.byteLength > limit) {
            let error = new FetchError(`content size at ${data.url} over limit: ${limit}`, "max-size");
            throw source.throw(error), error;
          } else
            buffer ? buffer.set(bytes, offset) : chunks.push(bytes);
          offset += bytes.byteLength;
        }
        if (buffer) {
          if (offset < buffer.byteLength)
            throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`, "premature-close");
          return buffer;
        } else
          return writeBytes(new Uint8Array(offset), chunks);
      } catch (error) {
        if (error instanceof FetchBaseError)
          throw error;
        if (error && error.name === "AbortError")
          throw error;
        {
          let e = (
            /** @type {import('./errors/fetch-error').SystemError} */
            error
          );
          throw new FetchError(`Invalid response body while trying to fetch ${data.url}: ${e.message}`, "system", e);
        }
      }
    }
    var clone = (instance) => {
      let { body } = instance;
      if (instance.bodyUsed)
        throw new Error("cannot clone body after it is used");
      if (!body)
        return null;
      let [left, right] = body.tee();
      return instance[INTERNALS$2].body = left, right;
    }, extractContentType = (source) => source[INTERNALS$2].type, getTotalBytes = (source) => source[INTERNALS$2].size, writeToStream = (dest, { body }) => {
      body === null ? dest.end() : Stream.Readable.from(streamIterator(body)).pipe(dest);
    }, StreamIterableIterator = class {
      /**
       * @param {ReadableStream<T>} stream
       */
      constructor(stream4) {
        this.stream = stream4, this.reader = null;
      }
      /**
       * @returns {AsyncGenerator<T, void, void>}
       */
      [Symbol.asyncIterator]() {
        return this;
      }
      getReader() {
        if (this.reader)
          return this.reader;
        let reader = this.stream.getReader();
        return this.reader = reader, reader;
      }
      /**
       * @returns {Promise<IteratorResult<T, void>>}
       */
      next() {
        return (
          /** @type {Promise<IteratorResult<T, void>>} */
          this.getReader().read()
        );
      }
      /**
       * @returns {Promise<IteratorResult<T, void>>}
       */
      async return() {
        return this.reader && await this.reader.cancel(), { done: !0, value: void 0 };
      }
      /**
       * 
       * @param {any} error 
       * @returns {Promise<IteratorResult<T, void>>}
       */
      async throw(error) {
        return await this.getReader().cancel(error), { done: !0, value: void 0 };
      }
    }, streamIterator = (stream4) => new StreamIterableIterator(stream4), writeBytes = (buffer, chunks) => {
      let offset = 0;
      for (let chunk of chunks)
        buffer.set(chunk, offset), offset += chunk.byteLength;
      return buffer;
    }, fromBytes = (bytes) => new webBlob.ReadableStream({
      start(controller) {
        controller.enqueue(bytes), controller.close();
      }
    }), fromAsyncIterable = (content) => new webBlob.ReadableStream(new AsyncIterablePump(content)), AsyncIterablePump = class {
      /**
       * @param {AsyncIterable<Uint8Array>} source
       */
      constructor(source) {
        this.source = source[Symbol.asyncIterator]();
      }
      /**
       * @param {ReadableStreamController<Uint8Array>} controller
       */
      async pull(controller) {
        try {
          for (; controller.desiredSize || 0 > 0; ) {
            let next = await this.source.next();
            if (next.done) {
              controller.close();
              break;
            } else
              controller.enqueue(next.value);
          }
        } catch (error) {
          controller.error(error);
        }
      }
      /**
       * @param {any} [reason]
       */
      cancel(reason) {
        reason ? typeof this.source.throw == "function" ? this.source.throw(reason) : typeof this.source.return == "function" && this.source.return() : typeof this.source.return == "function" && this.source.return();
      }
    }, fromStream = (source) => {
      let pump = new StreamPump(source);
      return new webBlob.ReadableStream(pump, pump);
    }, StreamPump = class {
      /**
       * @param {Stream & {
       * 	readableHighWaterMark?: number
       * 	readable?:boolean,
       * 	resume?: () => void,
       * 	pause?: () => void
       * 	destroy?: (error?:Error) => void
       * }} stream
       */
      constructor(stream4) {
        this.highWaterMark = stream4.readableHighWaterMark || readableHighWaterMark, this.accumalatedSize = 0, this.stream = stream4, this.enqueue = this.enqueue.bind(this), this.error = this.error.bind(this), this.close = this.close.bind(this);
      }
      /**
       * @param {Uint8Array} [chunk]
       */
      size(chunk) {
        return (chunk == null ? void 0 : chunk.byteLength) || 0;
      }
      /**
       * @param {ReadableStreamController<Uint8Array>} controller
       */
      start(controller) {
        this.controller = controller, this.stream.on("data", this.enqueue), this.stream.once("error", this.error), this.stream.once("end", this.close), this.stream.once("close", this.close);
      }
      pull() {
        this.resume();
      }
      /**
       * @param {any} [reason]
       */
      cancel(reason) {
        this.stream.destroy && this.stream.destroy(reason), this.stream.off("data", this.enqueue), this.stream.off("error", this.error), this.stream.off("end", this.close), this.stream.off("close", this.close);
      }
      /**
       * @param {Uint8Array|string} chunk
       */
      enqueue(chunk) {
        if (this.controller)
          try {
            let bytes = chunk instanceof Uint8Array ? chunk : Buffer.from(chunk), available = (this.controller.desiredSize || 0) - bytes.byteLength;
            this.controller.enqueue(bytes), available <= 0 && this.pause();
          } catch {
            this.controller.error(new Error("Could not create Buffer, chunk must be of type string or an instance of Buffer, ArrayBuffer, or Array or an Array-like Object")), this.cancel();
          }
      }
      pause() {
        this.stream.pause && this.stream.pause();
      }
      resume() {
        this.stream.readable && this.stream.resume && this.stream.resume();
      }
      close() {
        this.controller && (this.controller.close(), delete this.controller);
      }
      /**
       * @param {Error} error 
       */
      error(error) {
        this.controller && (this.controller.error(error), delete this.controller);
      }
    }, validators3 = (
      /** @type {{validateHeaderName?:(name:string) => any, validateHeaderValue?:(name:string, value:string) => any}} */
      http2
    ), validateHeaderName = typeof validators3.validateHeaderName == "function" ? validators3.validateHeaderName : (
      /**
       * @param {string} name
       */
      (name) => {
        if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
          let err = new TypeError(`Header name must be a valid HTTP token [${name}]`);
          throw Object.defineProperty(err, "code", { value: "ERR_INVALID_HTTP_TOKEN" }), err;
        }
      }
    ), validateHeaderValue = typeof validators3.validateHeaderValue == "function" ? validators3.validateHeaderValue : (
      /**
       * @param {string} name
       * @param {string} value
       */
      (name, value) => {
        if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
          let err = new TypeError(`Invalid character in header content ["${name}"]`);
          throw Object.defineProperty(err, "code", { value: "ERR_INVALID_CHAR" }), err;
        }
      }
    ), Headers2 = class extends URLSearchParams {
      /**
       * Headers class
       *
       * @constructor
       * @param {HeadersInit} [init] - Response headers
       */
      constructor(init) {
        let result = [];
        if (init instanceof Headers2) {
          let raw = init.raw();
          for (let [name, values] of Object.entries(raw))
            result.push(...values.map((value) => [name, value]));
        } else if (init != null)
          if (isIterable(init))
            result = [...init].map((pair) => {
              if (typeof pair != "object" || util2.types.isBoxedPrimitive(pair))
                throw new TypeError("Each header pair must be an iterable object");
              return [...pair];
            }).map((pair) => {
              if (pair.length !== 2)
                throw new TypeError("Each header pair must be a name/value tuple");
              return [...pair];
            });
          else if (typeof init == "object" && init !== null)
            result.push(...Object.entries(init));
          else
            throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
        return result = result.length > 0 ? result.map(([name, value]) => (validateHeaderName(name), validateHeaderValue(name, String(value)), [String(name).toLowerCase(), String(value)])) : [], super(result), new Proxy(this, {
          get(target, p, receiver) {
            switch (p) {
              case "append":
              case "set":
                return (name, value) => (validateHeaderName(name), validateHeaderValue(name, String(value)), URLSearchParams.prototype[p].call(
                  target,
                  String(name).toLowerCase(),
                  String(value)
                ));
              case "delete":
              case "has":
              case "getAll":
                return (name) => (validateHeaderName(name), URLSearchParams.prototype[p].call(
                  target,
                  String(name).toLowerCase()
                ));
              case "keys":
                return () => (target.sort(), new Set(URLSearchParams.prototype.keys.call(target)).keys());
              default:
                return Reflect.get(target, p, receiver);
            }
          }
          /* c8 ignore next */
        });
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
      toString() {
        return Object.prototype.toString.call(this);
      }
      /**
       *
       * @param {string} name
       */
      get(name) {
        let values = this.getAll(name);
        if (values.length === 0)
          return null;
        let value = values.join(", ");
        return /^content-encoding$/i.test(name) && (value = value.toLowerCase()), value;
      }
      /**
       * @param {(value: string, key: string, parent: this) => void} callback
       * @param {any} thisArg
       * @returns {void}
       */
      forEach(callback, thisArg = void 0) {
        for (let name of this.keys())
          Reflect.apply(callback, thisArg, [this.get(name), name, this]);
      }
      /**
       * @returns {IterableIterator<string>}
       */
      *values() {
        for (let name of this.keys())
          yield (
            /** @type {string} */
            this.get(name)
          );
      }
      /**
       * @returns {IterableIterator<[string, string]>}
       */
      *entries() {
        for (let name of this.keys())
          yield [
            name,
            /** @type {string} */
            this.get(name)
          ];
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      /**
       * Node-fetch non-spec method
       * returning all headers and their values as array
       * @returns {Record<string, string[]>}
       */
      raw() {
        return [...this.keys()].reduce(
          (result, key) => (result[key] = this.getAll(key), result),
          /** @type {Record<string, string[]>} */
          {}
        );
      }
      /**
       * For better console.log(headers) and also to convert Headers into Node.js Request compatible format
       */
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return [...this.keys()].reduce(
          (result, key) => {
            let values = this.getAll(key);
            return key === "host" ? result[key] = values[0] : result[key] = values.length > 1 ? values : values[0], result;
          },
          /** @type {Record<string, string|string[]>} */
          {}
        );
      }
    };
    Object.defineProperties(
      Headers2.prototype,
      ["get", "entries", "forEach", "values"].reduce(
        (result, property) => (result[property] = { enumerable: !0 }, result),
        /** @type {Record<string, {enumerable:true}>} */
        {}
      )
    );
    function fromRawHeaders(headers = []) {
      return new Headers2(
        headers.reduce(
          (result, value, index, array) => (index % 2 === 0 && result.push(array.slice(index, index + 2)), result),
          /** @type {string[][]} */
          []
        ).filter(([name, value]) => {
          try {
            return validateHeaderName(name), validateHeaderValue(name, String(value)), !0;
          } catch {
            return !1;
          }
        })
      );
    }
    var redirectStatus = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]), isRedirect = (code) => redirectStatus.has(code), INTERNALS$1 = Symbol("Response internals"), Response3 = class extends Body {
      /**
       * @param {BodyInit|import('stream').Stream|null} [body] - Readable stream
       * @param {ResponseInit & Ext} [options] - Response options
       */
      constructor(body = null, options = {}) {
        super(body, options);
        let status = options.status || 200, headers = new Headers2(options.headers);
        if (body !== null && !headers.has("Content-Type")) {
          let contentType = extractContentType(this);
          contentType && headers.append("Content-Type", contentType);
        }
        this[INTERNALS$1] = {
          url: options.url,
          status,
          statusText: options.statusText || "",
          headers,
          counter: options.counter || 0,
          highWaterMark: options.highWaterMark
        };
      }
      /**
       * @type {ResponseType}
       */
      get type() {
        return "default";
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      /**
       * Convenience property representing if the request ended normally
       */
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      /**
       * @type {Headers}
       */
      get headers() {
        return this[INTERNALS$1].headers;
      }
      get highWaterMark() {
        return this[INTERNALS$1].highWaterMark;
      }
      /**
       * Clone this response
       *
       * @returns {Response}
       */
      clone() {
        return new Response3(clone(this), {
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          size: this.size
        });
      }
      /**
       * @param {string} url    The URL that the new response is to originate from.
       * @param {number} status An optional status code for the response (e.g., 302.)
       * @returns {Response}    A Response object.
       */
      static redirect(url3, status = 302) {
        if (!isRedirect(status))
          throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
        return new Response3(null, {
          headers: {
            location: new URL(url3).toString()
          },
          status
        });
      }
      get [Symbol.toStringTag]() {
        return "Response";
      }
    };
    Object.defineProperties(Response3.prototype, {
      url: { enumerable: !0 },
      status: { enumerable: !0 },
      ok: { enumerable: !0 },
      redirected: { enumerable: !0 },
      statusText: { enumerable: !0 },
      headers: { enumerable: !0 },
      clone: { enumerable: !0 }
    });
    var getSearch = (parsedURL) => {
      if (parsedURL.search)
        return parsedURL.search;
      let lastOffset = parsedURL.href.length - 1, hash = parsedURL.hash || (parsedURL.href[lastOffset] === "#" ? "#" : "");
      return parsedURL.href[lastOffset - hash.length] === "?" ? "?" : "";
    }, INTERNALS = Symbol("Request internals"), forbiddenMethods = /* @__PURE__ */ new Set(["CONNECT", "TRACE", "TRACK"]), normalizedMethods = /* @__PURE__ */ new Set(["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"]), isRequest = (object) => typeof object == "object" && typeof object[INTERNALS] == "object", Request2 = class extends Body {
      /**
       * @param {string|Request|URL} info  Url or Request instance
       * @param {RequestInit & RequestExtraOptions} init   Custom options
       */
      constructor(info, init = {}) {
        let parsedURL, settings;
        isRequest(info) ? (parsedURL = new URL(info.url), settings = info) : (parsedURL = new URL(info), settings = {});
        let method = init.method || settings.method || "GET";
        if (forbiddenMethods.has(method.toUpperCase()))
          throw new TypeError(`Failed to construct 'Request': '${method}' HTTP method is unsupported.`);
        normalizedMethods.has(method.toUpperCase()) && (method = method.toUpperCase());
        let inputBody = init.body != null ? init.body : isRequest(info) && info.body !== null ? clone(info) : null;
        if (inputBody != null && (method === "GET" || method === "HEAD"))
          throw new TypeError("Request with GET/HEAD method cannot have body");
        super(inputBody, {
          size: init.size || settings.size || 0
        });
        let input = settings, headers = (
          /** @type {globalThis.Headers} */
          new Headers2(init.headers || input.headers || {})
        );
        if (inputBody !== null && !headers.has("Content-Type")) {
          let contentType = extractContentType(this);
          contentType && headers.append("Content-Type", contentType);
        }
        let signal = "signal" in init ? init.signal : isRequest(input) ? input.signal : null;
        if (signal != null && !isAbortSignal(signal))
          throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget");
        if (!signal) {
          let AbortControllerConstructor = typeof AbortController < "u" ? AbortController : abortController.AbortController;
          signal = new AbortControllerConstructor().signal;
        }
        this[INTERNALS] = {
          method,
          redirect: init.redirect || input.redirect || "follow",
          headers,
          credentials: init.credentials || "same-origin",
          parsedURL,
          signal: signal || null
        }, this.keepalive, this.follow = init.follow === void 0 ? input.follow === void 0 ? 20 : input.follow : init.follow, this.compress = init.compress === void 0 ? input.compress === void 0 ? !0 : input.compress : init.compress, this.counter = init.counter || input.counter || 0, this.agent = init.agent || input.agent, this.highWaterMark = init.highWaterMark || input.highWaterMark || 16384, this.insecureHTTPParser = init.insecureHTTPParser || input.insecureHTTPParser || !1;
      }
      /**
       * @type {RequestCache}
       */
      get cache() {
        return "default";
      }
      /**
       * @type {RequestCredentials}
       */
      get credentials() {
        return this[INTERNALS].credentials;
      }
      /**
       * @type {RequestDestination}
       */
      get destination() {
        return "";
      }
      get integrity() {
        return "";
      }
      /** @type {RequestMode} */
      get mode() {
        return "cors";
      }
      /** @type {string} */
      get referrer() {
        return "";
      }
      /** @type {ReferrerPolicy} */
      get referrerPolicy() {
        return "";
      }
      get method() {
        return this[INTERNALS].method;
      }
      /**
       * @type {string}
       */
      get url() {
        return url2.format(this[INTERNALS].parsedURL);
      }
      /**
       * @type {globalThis.Headers}
       */
      get headers() {
        return this[INTERNALS].headers;
      }
      get redirect() {
        return this[INTERNALS].redirect;
      }
      /**
       * @returns {AbortSignal}
       */
      get signal() {
        return this[INTERNALS].signal;
      }
      /**
       * Clone this request
       *
       * @return  {globalThis.Request}
       */
      clone() {
        return new Request2(this);
      }
      get [Symbol.toStringTag]() {
        return "Request";
      }
    };
    Object.defineProperties(Request2.prototype, {
      method: { enumerable: !0 },
      url: { enumerable: !0 },
      headers: { enumerable: !0 },
      redirect: { enumerable: !0 },
      clone: { enumerable: !0 },
      signal: { enumerable: !0 }
    });
    var getNodeRequestOptions = (request) => {
      let { parsedURL } = request[INTERNALS], headers = new Headers2(request[INTERNALS].headers);
      headers.has("Accept") || headers.set("Accept", "*/*");
      let contentLengthValue = null;
      if (request.body === null && /^(post|put)$/i.test(request.method) && (contentLengthValue = "0"), request.body !== null) {
        let totalBytes = getTotalBytes(request);
        typeof totalBytes == "number" && !Number.isNaN(totalBytes) && (contentLengthValue = String(totalBytes));
      }
      contentLengthValue && headers.set("Content-Length", contentLengthValue), headers.has("User-Agent") || headers.set("User-Agent", "node-fetch"), request.compress && !headers.has("Accept-Encoding") && headers.set("Accept-Encoding", "gzip,deflate,br");
      let { agent } = request;
      typeof agent == "function" && (agent = agent(parsedURL)), !headers.has("Connection") && !agent && headers.set("Connection", "close");
      let search = getSearch(parsedURL);
      return {
        path: parsedURL.pathname + search,
        pathname: parsedURL.pathname,
        hostname: parsedURL.hostname,
        protocol: parsedURL.protocol,
        port: parsedURL.port,
        hash: parsedURL.hash,
        search: parsedURL.search,
        // @ts-ignore - it does not has a query
        query: parsedURL.query,
        href: parsedURL.href,
        method: request.method,
        // @ts-ignore - not sure what this supposed to do
        headers: headers[Symbol.for("nodejs.util.inspect.custom")](),
        insecureHTTPParser: request.insecureHTTPParser,
        agent
      };
    }, AbortError = class extends FetchBaseError {
      /**
       * @param {string} message 
       * @param {string} [type]
       */
      constructor(message, type = "aborted") {
        super(message, type);
      }
    }, supportedSchemas = /* @__PURE__ */ new Set(["data:", "http:", "https:", "file:"]);
    async function fetch2(url3, options_ = {}) {
      return new Promise((resolve, reject) => {
        let request = new Request2(url3, options_), options = getNodeRequestOptions(request);
        if (!supportedSchemas.has(options.protocol))
          throw new TypeError(`node-fetch cannot load ${url3}. URL scheme "${options.protocol.replace(/:$/, "")}" is not supported.`);
        if (options.protocol === "data:") {
          let data = dataUriToBuffer(request.url.toString()), response2 = new Response3(data, { headers: { "Content-Type": data.typeFull } });
          resolve(response2);
          return;
        }
        if (options.protocol === "file:") {
          let stream4 = fs.createReadStream(new URL(request.url)), type = mime.lookup(request.url) || "application/octet-stream", response2 = new Response3(stream4, { headers: { "Content-Type": type } });
          resolve(response2);
          return;
        }
        let send = (options.protocol === "https:" ? https2 : http2).request, { signal } = request, response = null, response_ = null, abort = () => {
          let error = new AbortError("The operation was aborted.");
          reject(error), request.body && request.body.cancel(error), response_ && response_.emit("error", error);
        };
        if (signal && signal.aborted) {
          abort();
          return;
        }
        let abortAndFinalize = () => {
          abort(), finalize();
        }, request_ = send(options);
        signal && signal.addEventListener("abort", abortAndFinalize);
        let finalize = () => {
          request_.abort(), signal && signal.removeEventListener("abort", abortAndFinalize);
        };
        request_.on("error", (err) => {
          reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err)), finalize();
        }), fixResponseChunkedTransferBadEnding(request_, (err) => {
          signal && signal.aborted || response_ == null || response_.emit("error", err);
        }), parseInt(process.version.substring(1)) < 14 && request_.on("socket", (s) => {
          s.prependListener("close", (hadError) => {
            let hasDataListener = s.listenerCount("data") > 0;
            if (response && hasDataListener && !hadError && !(signal && signal.aborted)) {
              let err = Object.assign(new Error("Premature close"), {
                code: "ERR_STREAM_PREMATURE_CLOSE"
              });
              response_ == null || response_.emit("error", err);
            }
          });
        }), request_.on("response", (incoming) => {
          response_ = incoming, request_.setTimeout(0);
          let headers = fromRawHeaders(response_.rawHeaders);
          if (isRedirect(Number(response_.statusCode))) {
            let location = headers.get("Location"), locationURL = location === null ? null : new URL(location, request.url);
            switch (request.redirect) {
              case "error":
                reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect")), finalize();
                return;
              case "manual":
                locationURL !== null && headers.set("Location", locationURL.toString());
                break;
              case "follow": {
                if (locationURL === null)
                  break;
                if (request.counter >= request.follow) {
                  reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect")), finalize();
                  return;
                }
                let requestOptions = {
                  headers: new Headers2(request.headers),
                  follow: request.follow,
                  counter: request.counter + 1,
                  agent: request.agent,
                  compress: request.compress,
                  method: request.method,
                  // Note: We can not use `request.body` because send would have
                  // consumed it already.
                  body: options_.body,
                  signal,
                  size: request.size
                }, isStreamBody = requestOptions.body instanceof webBlob.ReadableStream || requestOptions.body instanceof Stream.Readable;
                if (response_.statusCode !== 303 && isStreamBody) {
                  reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect")), finalize();
                  return;
                }
                (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === "POST") && (requestOptions.method = "GET", requestOptions.body = void 0, requestOptions.headers.delete("content-length")), fetch2(new Request2(locationURL.href, requestOptions)).then(resolve, reject), finalize();
                return;
              }
              default:
                return reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));
            }
          }
          signal && response_.once("end", () => {
            signal.removeEventListener("abort", abortAndFinalize);
          });
          let body = Stream.pipeline(response_, new Stream.PassThrough(), reject);
          process.version < "v12.10" && response_.on("aborted", abortAndFinalize);
          let responseOptions = {
            url: request.url,
            status: response_.statusCode,
            statusText: response_.statusMessage,
            headers,
            size: request.size,
            counter: request.counter,
            highWaterMark: request.highWaterMark
          }, codings = headers.get("Content-Encoding");
          if (!request.compress || request.method === "HEAD" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
            response = new Response3(body, responseOptions), resolve(response);
            return;
          }
          let zlibOptions2 = {
            flush: zlib2.Z_SYNC_FLUSH,
            finishFlush: zlib2.Z_SYNC_FLUSH
          };
          if (codings === "gzip" || codings === "x-gzip") {
            body = Stream.pipeline(body, zlib2.createGunzip(zlibOptions2), reject), response = new Response3(fromAsyncIterable(body), responseOptions), resolve(response);
            return;
          }
          if (codings === "deflate" || codings === "x-deflate") {
            Stream.pipeline(response_, new Stream.PassThrough(), reject).once("data", (chunk) => {
              (chunk[0] & 15) === 8 ? body = Stream.pipeline(body, zlib2.createInflate(), reject) : body = Stream.pipeline(body, zlib2.createInflateRaw(), reject), response = new Response3(fromAsyncIterable(body), responseOptions), resolve(response);
            });
            return;
          }
          if (codings === "br") {
            body = Stream.pipeline(body, zlib2.createBrotliDecompress(), reject), response = new Response3(fromAsyncIterable(body), responseOptions), resolve(response);
            return;
          }
          response = new Response3(fromAsyncIterable(body), responseOptions), resolve(response);
        }), writeToStream(request_, request);
      });
    }
    function fixResponseChunkedTransferBadEnding(request, errorCallback) {
      let LAST_CHUNK = Buffer.from(`0\r
\r
`), isChunkedTransfer = !1, properLastChunkReceived = !1, previousChunk;
      request.on("response", (response) => {
        let { headers } = response;
        isChunkedTransfer = headers["transfer-encoding"] === "chunked" && !headers["content-length"];
      }), request.on("socket", (socket) => {
        let onSocketClose = () => {
          if (isChunkedTransfer && !properLastChunkReceived) {
            let error = Object.assign(new Error("Premature close"), {
              code: "ERR_STREAM_PREMATURE_CLOSE"
            });
            errorCallback(error);
          }
        }, onData = (buf) => {
          properLastChunkReceived = Buffer.compare(buf.slice(-5), LAST_CHUNK) === 0, !properLastChunkReceived && previousChunk && (properLastChunkReceived = Buffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 && Buffer.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0), previousChunk = buf;
        };
        socket.prependListener("close", onSocketClose), socket.on("data", onData), request.on("close", () => {
          socket.removeListener("close", onSocketClose), socket.removeListener("data", onData);
        });
      });
    }
    Object.defineProperty(exports, "Blob", {
      enumerable: !0,
      get: function() {
        return webBlob.Blob;
      }
    });
    Object.defineProperty(exports, "ReadableStream", {
      enumerable: !0,
      get: function() {
        return webBlob.ReadableStream;
      }
    });
    Object.defineProperty(exports, "FormData", {
      enumerable: !0,
      get: function() {
        return webFormData.FormData;
      }
    });
    exports.Headers = Headers2;
    exports.Request = Request2;
    exports.Response = Response3;
    exports.default = fetch2;
    exports.fetch = fetch2;
    exports = module2.exports = Object.assign(fetch2, exports);
  }
});

// node_modules/@remix-run/web-file/dist/src/file.cjs
var require_file = __commonJS({
  "node_modules/@remix-run/web-file/dist/src/file.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var webBlob = require_lib_node(), File2 = class extends webBlob.Blob {
      /**
       *
       * @param {BlobPart[]} init
       * @param {string} name - A USVString representing the file name or the path
       * to the file.
       * @param {FilePropertyBag} [options]
       */
      constructor(init, name = panic(new TypeError("File constructor requires name argument")), options = {}) {
        super(init, options), this._name = name, this._lastModified = options.lastModified || Date.now();
      }
      /**
       * The name of the file referenced by the File object.
       * @type {string}
       */
      get name() {
        return this._name;
      }
      /**
       * The path the URL of the File is relative to.
       * @type {string}
       */
      get webkitRelativePath() {
        return "";
      }
      /**
       * Returns the last modified time of the file, in millisecond since the UNIX
       * epoch (January 1st, 1970 at Midnight).
       * @returns {number}
       */
      get lastModified() {
        return this._lastModified;
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
    }, panic = (error) => {
      throw error;
    };
    exports.File = File2;
  }
});

// node_modules/@remix-run/web-file/dist/src/lib.node.cjs
var require_lib_node4 = __commonJS({
  "node_modules/@remix-run/web-file/dist/src/lib.node.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var webBlob = require_lib_node(), file = require_file(), File2 = file.File;
    Object.defineProperty(exports, "Blob", {
      enumerable: !0,
      get: function() {
        return webBlob.Blob;
      }
    });
    exports.File = File2;
  }
});

// node_modules/@remix-run/node/dist/fetch.js
var require_fetch = __commonJS({
  "node_modules/@remix-run/node/dist/fetch.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var webFetch = require_lib_node3(), webFile = require_lib_node4(), NodeRequest = class extends webFetch.Request {
      constructor(info, init) {
        super(info, init);
      }
      get headers() {
        return super.headers;
      }
      clone() {
        return super.clone();
      }
    }, NodeResponse = class extends webFetch.Response {
      get headers() {
        return super.headers;
      }
      clone() {
        return super.clone();
      }
    }, fetch2 = (info, init) => (init = {
      // Disable compression handling so people can return the result of a fetch
      // directly in the loader without messing with the Content-Encoding header.
      compress: !1,
      ...init
    }, webFetch.fetch(info, init));
    Object.defineProperty(exports, "FormData", {
      enumerable: !0,
      get: function() {
        return webFetch.FormData;
      }
    });
    Object.defineProperty(exports, "Headers", {
      enumerable: !0,
      get: function() {
        return webFetch.Headers;
      }
    });
    Object.defineProperty(exports, "Blob", {
      enumerable: !0,
      get: function() {
        return webFile.Blob;
      }
    });
    Object.defineProperty(exports, "File", {
      enumerable: !0,
      get: function() {
        return webFile.File;
      }
    });
    exports.Request = NodeRequest;
    exports.Response = NodeResponse;
    exports.fetch = fetch2;
  }
});

// node_modules/@remix-run/node/dist/base64.js
var require_base642 = __commonJS({
  "node_modules/@remix-run/node/dist/base64.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    function atob2(a) {
      return Buffer.from(a, "base64").toString("binary");
    }
    function btoa2(b) {
      return Buffer.from(b, "binary").toString("base64");
    }
    exports.atob = atob2;
    exports.btoa = btoa2;
  }
});

// node_modules/@remix-run/node/dist/globals.js
var require_globals = __commonJS({
  "node_modules/@remix-run/node/dist/globals.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var webStream = require_stream(), abortController = require_abort_controller(), base64 = require_base642(), fetch2 = require_fetch(), webFile = require_lib_node4(), webFetch = require_lib_node3();
    function installGlobals() {
      global.atob = base64.atob, global.btoa = base64.btoa, global.Blob = webFile.Blob, global.File = webFile.File, global.Headers = webFetch.Headers, global.Request = fetch2.Request, global.Response = fetch2.Response, global.fetch = fetch2.fetch, global.FormData = webFetch.FormData, global.ReadableStream = webStream.ReadableStream, global.WritableStream = webStream.WritableStream, global.AbortController = global.AbortController || abortController.AbortController;
    }
    exports.installGlobals = installGlobals;
  }
});

// node_modules/cookie/index.js
var require_cookie = __commonJS({
  "node_modules/cookie/index.js"(exports) {
    "use strict";
    exports.parse = parse;
    exports.serialize = serialize;
    var decode = decodeURIComponent, encode3 = encodeURIComponent, fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
    function parse(str, options) {
      if (typeof str != "string")
        throw new TypeError("argument str must be a string");
      for (var obj = {}, opt = options || {}, pairs = str.split(";"), dec = opt.decode || decode, i = 0; i < pairs.length; i++) {
        var pair = pairs[i], index = pair.indexOf("=");
        if (!(index < 0)) {
          var key = pair.substring(0, index).trim();
          if (obj[key] == null) {
            var val = pair.substring(index + 1, pair.length).trim();
            val[0] === '"' && (val = val.slice(1, -1)), obj[key] = tryDecode(val, dec);
          }
        }
      }
      return obj;
    }
    function serialize(name, val, options) {
      var opt = options || {}, enc = opt.encode || encode3;
      if (typeof enc != "function")
        throw new TypeError("option encode is invalid");
      if (!fieldContentRegExp.test(name))
        throw new TypeError("argument name is invalid");
      var value = enc(val);
      if (value && !fieldContentRegExp.test(value))
        throw new TypeError("argument val is invalid");
      var str = name + "=" + value;
      if (opt.maxAge != null) {
        var maxAge = opt.maxAge - 0;
        if (isNaN(maxAge) || !isFinite(maxAge))
          throw new TypeError("option maxAge is invalid");
        str += "; Max-Age=" + Math.floor(maxAge);
      }
      if (opt.domain) {
        if (!fieldContentRegExp.test(opt.domain))
          throw new TypeError("option domain is invalid");
        str += "; Domain=" + opt.domain;
      }
      if (opt.path) {
        if (!fieldContentRegExp.test(opt.path))
          throw new TypeError("option path is invalid");
        str += "; Path=" + opt.path;
      }
      if (opt.expires) {
        if (typeof opt.expires.toUTCString != "function")
          throw new TypeError("option expires is invalid");
        str += "; Expires=" + opt.expires.toUTCString();
      }
      if (opt.httpOnly && (str += "; HttpOnly"), opt.secure && (str += "; Secure"), opt.sameSite) {
        var sameSite = typeof opt.sameSite == "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
        switch (sameSite) {
          case !0:
            str += "; SameSite=Strict";
            break;
          case "lax":
            str += "; SameSite=Lax";
            break;
          case "strict":
            str += "; SameSite=Strict";
            break;
          case "none":
            str += "; SameSite=None";
            break;
          default:
            throw new TypeError("option sameSite is invalid");
        }
      }
      return str;
    }
    function tryDecode(str, decode2) {
      try {
        return decode2(str);
      } catch {
        return str;
      }
    }
  }
});

// node_modules/@remix-run/server-runtime/dist/warnings.js
var require_warnings = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/warnings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var alreadyWarned = {};
    function warnOnce(condition, message) {
      !condition && !alreadyWarned[message] && (alreadyWarned[message] = !0, console.warn(message));
    }
    exports.warnOnce = warnOnce;
  }
});

// node_modules/@remix-run/server-runtime/dist/cookies.js
var require_cookies = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/cookies.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var cookie = require_cookie(), warnings = require_warnings(), createCookieFactory = ({
      sign,
      unsign
    }) => (name, cookieOptions = {}) => {
      let {
        secrets = [],
        ...options
      } = {
        path: "/",
        sameSite: "lax",
        ...cookieOptions
      };
      return warnOnceAboutExpiresCookie(name, options.expires), {
        get name() {
          return name;
        },
        get isSigned() {
          return secrets.length > 0;
        },
        get expires() {
          return typeof options.maxAge < "u" ? new Date(Date.now() + options.maxAge * 1e3) : options.expires;
        },
        async parse(cookieHeader, parseOptions) {
          if (!cookieHeader)
            return null;
          let cookies = cookie.parse(cookieHeader, {
            ...options,
            ...parseOptions
          });
          return name in cookies ? cookies[name] === "" ? "" : await decodeCookieValue(unsign, cookies[name], secrets) : null;
        },
        async serialize(value, serializeOptions) {
          return cookie.serialize(name, value === "" ? "" : await encodeCookieValue(sign, value, secrets), {
            ...options,
            ...serializeOptions
          });
        }
      };
    }, isCookie = (object) => object != null && typeof object.name == "string" && typeof object.isSigned == "boolean" && typeof object.parse == "function" && typeof object.serialize == "function";
    async function encodeCookieValue(sign, value, secrets) {
      let encoded = encodeData(value);
      return secrets.length > 0 && (encoded = await sign(encoded, secrets[0])), encoded;
    }
    async function decodeCookieValue(unsign, value, secrets) {
      if (secrets.length > 0) {
        for (let secret of secrets) {
          let unsignedValue = await unsign(value, secret);
          if (unsignedValue !== !1)
            return decodeData(unsignedValue);
        }
        return null;
      }
      return decodeData(value);
    }
    function encodeData(value) {
      return btoa(myUnescape(encodeURIComponent(JSON.stringify(value))));
    }
    function decodeData(value) {
      try {
        return JSON.parse(decodeURIComponent(myEscape(atob(value))));
      } catch {
        return {};
      }
    }
    function myEscape(value) {
      let str = value.toString(), result = "", index = 0, chr, code;
      for (; index < str.length; )
        chr = str.charAt(index++), /[\w*+\-./@]/.exec(chr) ? result += chr : (code = chr.charCodeAt(0), code < 256 ? result += "%" + hex(code, 2) : result += "%u" + hex(code, 4).toUpperCase());
      return result;
    }
    function hex(code, length) {
      let result = code.toString(16);
      for (; result.length < length; )
        result = "0" + result;
      return result;
    }
    function myUnescape(value) {
      let str = value.toString(), result = "", index = 0, chr, part;
      for (; index < str.length; ) {
        if (chr = str.charAt(index++), chr === "%") {
          if (str.charAt(index) === "u") {
            if (part = str.slice(index + 1, index + 5), /^[\da-f]{4}$/i.exec(part)) {
              result += String.fromCharCode(parseInt(part, 16)), index += 5;
              continue;
            }
          } else if (part = str.slice(index, index + 2), /^[\da-f]{2}$/i.exec(part)) {
            result += String.fromCharCode(parseInt(part, 16)), index += 2;
            continue;
          }
        }
        result += chr;
      }
      return result;
    }
    function warnOnceAboutExpiresCookie(name, expires) {
      warnings.warnOnce(!expires, `The "${name}" cookie has an "expires" property set. This will cause the expires value to not be updated when the session is committed. Instead, you should set the expires value when serializing the cookie. You can use \`commitSession(session, { expires })\` if using a session storage object, or \`cookie.serialize("value", { expires })\` if you're using the cookie directly.`);
    }
    exports.createCookieFactory = createCookieFactory;
    exports.isCookie = isCookie;
  }
});

// node_modules/@remix-run/server-runtime/dist/formData.js
var require_formData = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/formData.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var multipartParser = require_src2();
    function composeUploadHandlers(...handlers) {
      return async (part) => {
        for (let handler of handlers) {
          let value = await handler(part);
          if (typeof value < "u" && value !== null)
            return value;
        }
      };
    }
    async function parseMultipartFormData(request, uploadHandler) {
      let contentType = request.headers.get("Content-Type") || "", [type, boundary] = contentType.split(/\s*;\s*boundary=/);
      if (!request.body || !boundary || type !== "multipart/form-data")
        throw new TypeError("Could not parse content as FormData.");
      let formData = new FormData(), parts = multipartParser.streamMultipart(request.body, boundary);
      for await (let part of parts) {
        if (part.done)
          break;
        typeof part.filename == "string" && (part.filename = part.filename.split(/[/\\]/).pop());
        let value = await uploadHandler(part);
        typeof value < "u" && value !== null && formData.append(part.name, value);
      }
      return formData;
    }
    exports.composeUploadHandlers = composeUploadHandlers;
    exports.parseMultipartFormData = parseMultipartFormData;
  }
});

// node_modules/@remix-run/router/dist/router.cjs.js
var require_router_cjs = __commonJS({
  "node_modules/@remix-run/router/dist/router.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    function _extends() {
      return _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source)
            Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
        }
        return target;
      }, _extends.apply(this, arguments);
    }
    exports.Action = void 0;
    (function(Action) {
      Action.Pop = "POP", Action.Push = "PUSH", Action.Replace = "REPLACE";
    })(exports.Action || (exports.Action = {}));
    var PopStateEventType = "popstate";
    function createMemoryHistory(options) {
      options === void 0 && (options = {});
      let {
        initialEntries = ["/"],
        initialIndex,
        v5Compat = !1
      } = options, entries;
      entries = initialEntries.map((entry2, index2) => createMemoryLocation(entry2, typeof entry2 == "string" ? null : entry2.state, index2 === 0 ? "default" : void 0));
      let index = clampIndex(initialIndex ?? entries.length - 1), action = exports.Action.Pop, listener = null;
      function clampIndex(n) {
        return Math.min(Math.max(n, 0), entries.length - 1);
      }
      function getCurrentLocation() {
        return entries[index];
      }
      function createMemoryLocation(to, state, key) {
        state === void 0 && (state = null);
        let location = createLocation(entries ? getCurrentLocation().pathname : "/", to, state, key);
        return warning(location.pathname.charAt(0) === "/", "relative pathnames are not supported in memory history: " + JSON.stringify(to)), location;
      }
      function createHref(to) {
        return typeof to == "string" ? to : createPath(to);
      }
      return {
        get index() {
          return index;
        },
        get action() {
          return action;
        },
        get location() {
          return getCurrentLocation();
        },
        createHref,
        createURL(to) {
          return new URL(createHref(to), "http://localhost");
        },
        encodeLocation(to) {
          let path = typeof to == "string" ? parsePath(to) : to;
          return {
            pathname: path.pathname || "",
            search: path.search || "",
            hash: path.hash || ""
          };
        },
        push(to, state) {
          action = exports.Action.Push;
          let nextLocation = createMemoryLocation(to, state);
          index += 1, entries.splice(index, entries.length, nextLocation), v5Compat && listener && listener({
            action,
            location: nextLocation,
            delta: 1
          });
        },
        replace(to, state) {
          action = exports.Action.Replace;
          let nextLocation = createMemoryLocation(to, state);
          entries[index] = nextLocation, v5Compat && listener && listener({
            action,
            location: nextLocation,
            delta: 0
          });
        },
        go(delta) {
          action = exports.Action.Pop;
          let nextIndex = clampIndex(index + delta), nextLocation = entries[nextIndex];
          index = nextIndex, listener && listener({
            action,
            location: nextLocation,
            delta
          });
        },
        listen(fn) {
          return listener = fn, () => {
            listener = null;
          };
        }
      };
    }
    function createBrowserHistory(options) {
      options === void 0 && (options = {});
      function createBrowserLocation(window2, globalHistory) {
        let {
          pathname,
          search,
          hash
        } = window2.location;
        return createLocation(
          "",
          {
            pathname,
            search,
            hash
          },
          // state defaults to `null` because `window.history.state` does
          globalHistory.state && globalHistory.state.usr || null,
          globalHistory.state && globalHistory.state.key || "default"
        );
      }
      function createBrowserHref(window2, to) {
        return typeof to == "string" ? to : createPath(to);
      }
      return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);
    }
    function createHashHistory(options) {
      options === void 0 && (options = {});
      function createHashLocation(window2, globalHistory) {
        let {
          pathname = "/",
          search = "",
          hash = ""
        } = parsePath(window2.location.hash.substr(1));
        return createLocation(
          "",
          {
            pathname,
            search,
            hash
          },
          // state defaults to `null` because `window.history.state` does
          globalHistory.state && globalHistory.state.usr || null,
          globalHistory.state && globalHistory.state.key || "default"
        );
      }
      function createHashHref(window2, to) {
        let base = window2.document.querySelector("base"), href = "";
        if (base && base.getAttribute("href")) {
          let url2 = window2.location.href, hashIndex = url2.indexOf("#");
          href = hashIndex === -1 ? url2 : url2.slice(0, hashIndex);
        }
        return href + "#" + (typeof to == "string" ? to : createPath(to));
      }
      function validateHashLocation(location, to) {
        warning(location.pathname.charAt(0) === "/", "relative pathnames are not supported in hash history.push(" + JSON.stringify(to) + ")");
      }
      return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);
    }
    function invariant(value, message) {
      if (value === !1 || value === null || typeof value > "u")
        throw new Error(message);
    }
    function warning(cond, message) {
      if (!cond) {
        typeof console < "u" && console.warn(message);
        try {
          throw new Error(message);
        } catch {
        }
      }
    }
    function createKey() {
      return Math.random().toString(36).substr(2, 8);
    }
    function getHistoryState(location, index) {
      return {
        usr: location.state,
        key: location.key,
        idx: index
      };
    }
    function createLocation(current, to, state, key) {
      return state === void 0 && (state = null), _extends({
        pathname: typeof current == "string" ? current : current.pathname,
        search: "",
        hash: ""
      }, typeof to == "string" ? parsePath(to) : to, {
        state,
        // TODO: This could be cleaned up.  push/replace should probably just take
        // full Locations now and avoid the need to run through this flow at all
        // But that's a pretty big refactor to the current test suite so going to
        // keep as is for the time being and just let any incoming keys take precedence
        key: to && to.key || key || createKey()
      });
    }
    function createPath(_ref) {
      let {
        pathname = "/",
        search = "",
        hash = ""
      } = _ref;
      return search && search !== "?" && (pathname += search.charAt(0) === "?" ? search : "?" + search), hash && hash !== "#" && (pathname += hash.charAt(0) === "#" ? hash : "#" + hash), pathname;
    }
    function parsePath(path) {
      let parsedPath = {};
      if (path) {
        let hashIndex = path.indexOf("#");
        hashIndex >= 0 && (parsedPath.hash = path.substr(hashIndex), path = path.substr(0, hashIndex));
        let searchIndex = path.indexOf("?");
        searchIndex >= 0 && (parsedPath.search = path.substr(searchIndex), path = path.substr(0, searchIndex)), path && (parsedPath.pathname = path);
      }
      return parsedPath;
    }
    function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
      options === void 0 && (options = {});
      let {
        window: window2 = document.defaultView,
        v5Compat = !1
      } = options, globalHistory = window2.history, action = exports.Action.Pop, listener = null, index = getIndex();
      index == null && (index = 0, globalHistory.replaceState(_extends({}, globalHistory.state, {
        idx: index
      }), ""));
      function getIndex() {
        return (globalHistory.state || {
          idx: null
        }).idx;
      }
      function handlePop() {
        action = exports.Action.Pop;
        let nextIndex = getIndex(), delta = nextIndex == null ? null : nextIndex - index;
        index = nextIndex, listener && listener({
          action,
          location: history.location,
          delta
        });
      }
      function push(to, state) {
        action = exports.Action.Push;
        let location = createLocation(history.location, to, state);
        validateLocation && validateLocation(location, to), index = getIndex() + 1;
        let historyState = getHistoryState(location, index), url2 = history.createHref(location);
        try {
          globalHistory.pushState(historyState, "", url2);
        } catch {
          window2.location.assign(url2);
        }
        v5Compat && listener && listener({
          action,
          location: history.location,
          delta: 1
        });
      }
      function replace(to, state) {
        action = exports.Action.Replace;
        let location = createLocation(history.location, to, state);
        validateLocation && validateLocation(location, to), index = getIndex();
        let historyState = getHistoryState(location, index), url2 = history.createHref(location);
        globalHistory.replaceState(historyState, "", url2), v5Compat && listener && listener({
          action,
          location: history.location,
          delta: 0
        });
      }
      function createURL(to) {
        let base = window2.location.origin !== "null" ? window2.location.origin : window2.location.href, href = typeof to == "string" ? to : createPath(to);
        return invariant(base, "No window.location.(origin|href) available to create URL for href: " + href), new URL(href, base);
      }
      let history = {
        get action() {
          return action;
        },
        get location() {
          return getLocation(window2, globalHistory);
        },
        listen(fn) {
          if (listener)
            throw new Error("A history only accepts one active listener");
          return window2.addEventListener(PopStateEventType, handlePop), listener = fn, () => {
            window2.removeEventListener(PopStateEventType, handlePop), listener = null;
          };
        },
        createHref(to) {
          return createHref(window2, to);
        },
        createURL,
        encodeLocation(to) {
          let url2 = createURL(to);
          return {
            pathname: url2.pathname,
            search: url2.search,
            hash: url2.hash
          };
        },
        push,
        replace,
        go(n) {
          return globalHistory.go(n);
        }
      };
      return history;
    }
    var ResultType;
    (function(ResultType2) {
      ResultType2.data = "data", ResultType2.deferred = "deferred", ResultType2.redirect = "redirect", ResultType2.error = "error";
    })(ResultType || (ResultType = {}));
    var immutableRouteKeys = /* @__PURE__ */ new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]);
    function isIndexRoute(route) {
      return route.index === !0;
    }
    function convertRoutesToDataRoutes(routes2, mapRouteProperties, parentPath, manifest) {
      return parentPath === void 0 && (parentPath = []), manifest === void 0 && (manifest = {}), routes2.map((route, index) => {
        let treePath = [...parentPath, index], id = typeof route.id == "string" ? route.id : treePath.join("-");
        if (invariant(route.index !== !0 || !route.children, "Cannot specify children on an index route"), invariant(!manifest[id], 'Found a route id collision on id "' + id + `".  Route id's must be globally unique within Data Router usages`), isIndexRoute(route)) {
          let indexRoute = _extends({}, route, mapRouteProperties(route), {
            id
          });
          return manifest[id] = indexRoute, indexRoute;
        } else {
          let pathOrLayoutRoute = _extends({}, route, mapRouteProperties(route), {
            id,
            children: void 0
          });
          return manifest[id] = pathOrLayoutRoute, route.children && (pathOrLayoutRoute.children = convertRoutesToDataRoutes(route.children, mapRouteProperties, treePath, manifest)), pathOrLayoutRoute;
        }
      });
    }
    function matchRoutes(routes2, locationArg, basename) {
      basename === void 0 && (basename = "/");
      let location = typeof locationArg == "string" ? parsePath(locationArg) : locationArg, pathname = stripBasename(location.pathname || "/", basename);
      if (pathname == null)
        return null;
      let branches = flattenRoutes(routes2);
      rankRouteBranches(branches);
      let matches = null;
      for (let i = 0; matches == null && i < branches.length; ++i)
        matches = matchRouteBranch(
          branches[i],
          // Incoming pathnames are generally encoded from either window.location
          // or from router.navigate, but we want to match against the unencoded
          // paths in the route definitions.  Memory router locations won't be
          // encoded here but there also shouldn't be anything to decode so this
          // should be a safe operation.  This avoids needing matchRoutes to be
          // history-aware.
          safelyDecodeURI(pathname)
        );
      return matches;
    }
    function flattenRoutes(routes2, branches, parentsMeta, parentPath) {
      branches === void 0 && (branches = []), parentsMeta === void 0 && (parentsMeta = []), parentPath === void 0 && (parentPath = "");
      let flattenRoute = (route, index, relativePath) => {
        let meta = {
          relativePath: relativePath === void 0 ? route.path || "" : relativePath,
          caseSensitive: route.caseSensitive === !0,
          childrenIndex: index,
          route
        };
        meta.relativePath.startsWith("/") && (invariant(meta.relativePath.startsWith(parentPath), 'Absolute route path "' + meta.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."), meta.relativePath = meta.relativePath.slice(parentPath.length));
        let path = joinPaths([parentPath, meta.relativePath]), routesMeta = parentsMeta.concat(meta);
        route.children && route.children.length > 0 && (invariant(
          // Our types know better, but runtime JS may not!
          // @ts-expect-error
          route.index !== !0,
          "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path + '".')
        ), flattenRoutes(route.children, branches, routesMeta, path)), !(route.path == null && !route.index) && branches.push({
          path,
          score: computeScore(path, route.index),
          routesMeta
        });
      };
      return routes2.forEach((route, index) => {
        var _route$path;
        if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?")))
          flattenRoute(route, index);
        else
          for (let exploded of explodeOptionalSegments(route.path))
            flattenRoute(route, index, exploded);
      }), branches;
    }
    function explodeOptionalSegments(path) {
      let segments = path.split("/");
      if (segments.length === 0)
        return [];
      let [first, ...rest] = segments, isOptional = first.endsWith("?"), required = first.replace(/\?$/, "");
      if (rest.length === 0)
        return isOptional ? [required, ""] : [required];
      let restExploded = explodeOptionalSegments(rest.join("/")), result = [];
      return result.push(...restExploded.map((subpath) => subpath === "" ? required : [required, subpath].join("/"))), isOptional && result.push(...restExploded), result.map((exploded) => path.startsWith("/") && exploded === "" ? "/" : exploded);
    }
    function rankRouteBranches(branches) {
      branches.sort((a, b) => a.score !== b.score ? b.score - a.score : compareIndexes(a.routesMeta.map((meta) => meta.childrenIndex), b.routesMeta.map((meta) => meta.childrenIndex)));
    }
    var paramRe = /^:\w+$/, dynamicSegmentValue = 3, indexRouteValue = 2, emptySegmentValue = 1, staticSegmentValue = 10, splatPenalty = -2, isSplat = (s) => s === "*";
    function computeScore(path, index) {
      let segments = path.split("/"), initialScore = segments.length;
      return segments.some(isSplat) && (initialScore += splatPenalty), index && (initialScore += indexRouteValue), segments.filter((s) => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
    }
    function compareIndexes(a, b) {
      return a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]) ? (
        // If two routes are siblings, we should try to match the earlier sibling
        // first. This allows people to have fine-grained control over the matching
        // behavior by simply putting routes with identical paths in the order they
        // want them tried.
        a[a.length - 1] - b[b.length - 1]
      ) : (
        // Otherwise, it doesn't really make sense to rank non-siblings by index,
        // so they sort equally.
        0
      );
    }
    function matchRouteBranch(branch, pathname) {
      let {
        routesMeta
      } = branch, matchedParams = {}, matchedPathname = "/", matches = [];
      for (let i = 0; i < routesMeta.length; ++i) {
        let meta = routesMeta[i], end = i === routesMeta.length - 1, remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/", match = matchPath({
          path: meta.relativePath,
          caseSensitive: meta.caseSensitive,
          end
        }, remainingPathname);
        if (!match)
          return null;
        Object.assign(matchedParams, match.params);
        let route = meta.route;
        matches.push({
          // TODO: Can this as be avoided?
          params: matchedParams,
          pathname: joinPaths([matchedPathname, match.pathname]),
          pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),
          route
        }), match.pathnameBase !== "/" && (matchedPathname = joinPaths([matchedPathname, match.pathnameBase]));
      }
      return matches;
    }
    function generatePath(originalPath, params) {
      params === void 0 && (params = {});
      let path = originalPath;
      path.endsWith("*") && path !== "*" && !path.endsWith("/*") && (warning(!1, 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".')), path = path.replace(/\*$/, "/*"));
      let prefix = path.startsWith("/") ? "/" : "", segments = path.split(/\/+/).map((segment, index, array) => {
        if (index === array.length - 1 && segment === "*")
          return params["*"];
        let keyMatch = segment.match(/^:(\w+)(\??)$/);
        if (keyMatch) {
          let [, key, optional] = keyMatch, param = params[key];
          return optional === "?" ? param ?? "" : (param == null && invariant(!1, 'Missing ":' + key + '" param'), param);
        }
        return segment.replace(/\?$/g, "");
      }).filter((segment) => !!segment);
      return prefix + segments.join("/");
    }
    function matchPath(pattern, pathname) {
      typeof pattern == "string" && (pattern = {
        path: pattern,
        caseSensitive: !1,
        end: !0
      });
      let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end), match = pathname.match(matcher);
      if (!match)
        return null;
      let matchedPathname = match[0], pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1"), captureGroups = match.slice(1);
      return {
        params: paramNames.reduce((memo, paramName, index) => {
          if (paramName === "*") {
            let splatValue = captureGroups[index] || "";
            pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
          }
          return memo[paramName] = safelyDecodeURIComponent(captureGroups[index] || "", paramName), memo;
        }, {}),
        pathname: matchedPathname,
        pathnameBase,
        pattern
      };
    }
    function compilePath(path, caseSensitive, end) {
      caseSensitive === void 0 && (caseSensitive = !1), end === void 0 && (end = !0), warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".'));
      let paramNames = [], regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/\/:(\w+)/g, (_, paramName) => (paramNames.push(paramName), "/([^\\/]+)"));
      return path.endsWith("*") ? (paramNames.push("*"), regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : end ? regexpSource += "\\/*$" : path !== "" && path !== "/" && (regexpSource += "(?:(?=\\/|$))"), [new RegExp(regexpSource, caseSensitive ? void 0 : "i"), paramNames];
    }
    function safelyDecodeURI(value) {
      try {
        return decodeURI(value);
      } catch (error) {
        return warning(!1, 'The URL path "' + value + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + error + ").")), value;
      }
    }
    function safelyDecodeURIComponent(value, paramName) {
      try {
        return decodeURIComponent(value);
      } catch (error) {
        return warning(!1, 'The value for the URL param "' + paramName + '" will not be decoded because' + (' the string "' + value + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + error + ").")), value;
      }
    }
    function stripBasename(pathname, basename) {
      if (basename === "/")
        return pathname;
      if (!pathname.toLowerCase().startsWith(basename.toLowerCase()))
        return null;
      let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length, nextChar = pathname.charAt(startIndex);
      return nextChar && nextChar !== "/" ? null : pathname.slice(startIndex) || "/";
    }
    function resolvePath(to, fromPathname) {
      fromPathname === void 0 && (fromPathname = "/");
      let {
        pathname: toPathname,
        search = "",
        hash = ""
      } = typeof to == "string" ? parsePath(to) : to;
      return {
        pathname: toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname,
        search: normalizeSearch(search),
        hash: normalizeHash(hash)
      };
    }
    function resolvePathname(relativePath, fromPathname) {
      let segments = fromPathname.replace(/\/+$/, "").split("/");
      return relativePath.split("/").forEach((segment) => {
        segment === ".." ? segments.length > 1 && segments.pop() : segment !== "." && segments.push(segment);
      }), segments.length > 1 ? segments.join("/") : "/";
    }
    function getInvalidPathError(char, field, dest, path) {
      return "Cannot include a '" + char + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
    }
    function getPathContributingMatches(matches) {
      return matches.filter((match, index) => index === 0 || match.route.path && match.route.path.length > 0);
    }
    function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
      isPathRelative === void 0 && (isPathRelative = !1);
      let to;
      typeof toArg == "string" ? to = parsePath(toArg) : (to = _extends({}, toArg), invariant(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to)), invariant(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to)), invariant(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to)));
      let isEmptyPath = toArg === "" || to.pathname === "", toPathname = isEmptyPath ? "/" : to.pathname, from;
      if (isPathRelative || toPathname == null)
        from = locationPathname;
      else {
        let routePathnameIndex = routePathnames.length - 1;
        if (toPathname.startsWith("..")) {
          let toSegments = toPathname.split("/");
          for (; toSegments[0] === ".."; )
            toSegments.shift(), routePathnameIndex -= 1;
          to.pathname = toSegments.join("/");
        }
        from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
      }
      let path = resolvePath(to, from), hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/"), hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
      return !path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash) && (path.pathname += "/"), path;
    }
    function getToPathname(to) {
      return to === "" || to.pathname === "" ? "/" : typeof to == "string" ? parsePath(to).pathname : to.pathname;
    }
    var joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/"), normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/"), normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search, normalizeHash = (hash) => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash, json = function(data, init) {
      init === void 0 && (init = {});
      let responseInit = typeof init == "number" ? {
        status: init
      } : init, headers = new Headers(responseInit.headers);
      return headers.has("Content-Type") || headers.set("Content-Type", "application/json; charset=utf-8"), new Response(JSON.stringify(data), _extends({}, responseInit, {
        headers
      }));
    }, AbortedDeferredError = class extends Error {
    }, DeferredData = class {
      constructor(data, responseInit) {
        this.pendingKeysSet = /* @__PURE__ */ new Set(), this.subscribers = /* @__PURE__ */ new Set(), this.deferredKeys = [], invariant(data && typeof data == "object" && !Array.isArray(data), "defer() only accepts plain objects");
        let reject;
        this.abortPromise = new Promise((_, r) => reject = r), this.controller = new AbortController();
        let onAbort = () => reject(new AbortedDeferredError("Deferred data aborted"));
        this.unlistenAbortSignal = () => this.controller.signal.removeEventListener("abort", onAbort), this.controller.signal.addEventListener("abort", onAbort), this.data = Object.entries(data).reduce((acc, _ref) => {
          let [key, value] = _ref;
          return Object.assign(acc, {
            [key]: this.trackPromise(key, value)
          });
        }, {}), this.done && this.unlistenAbortSignal(), this.init = responseInit;
      }
      trackPromise(key, value) {
        if (!(value instanceof Promise))
          return value;
        this.deferredKeys.push(key), this.pendingKeysSet.add(key);
        let promise = Promise.race([value, this.abortPromise]).then((data) => this.onSettle(promise, key, null, data), (error) => this.onSettle(promise, key, error));
        return promise.catch(() => {
        }), Object.defineProperty(promise, "_tracked", {
          get: () => !0
        }), promise;
      }
      onSettle(promise, key, error, data) {
        return this.controller.signal.aborted && error instanceof AbortedDeferredError ? (this.unlistenAbortSignal(), Object.defineProperty(promise, "_error", {
          get: () => error
        }), Promise.reject(error)) : (this.pendingKeysSet.delete(key), this.done && this.unlistenAbortSignal(), error ? (Object.defineProperty(promise, "_error", {
          get: () => error
        }), this.emit(!1, key), Promise.reject(error)) : (Object.defineProperty(promise, "_data", {
          get: () => data
        }), this.emit(!1, key), data));
      }
      emit(aborted, settledKey) {
        this.subscribers.forEach((subscriber) => subscriber(aborted, settledKey));
      }
      subscribe(fn) {
        return this.subscribers.add(fn), () => this.subscribers.delete(fn);
      }
      cancel() {
        this.controller.abort(), this.pendingKeysSet.forEach((v, k) => this.pendingKeysSet.delete(k)), this.emit(!0);
      }
      async resolveData(signal) {
        let aborted = !1;
        if (!this.done) {
          let onAbort = () => this.cancel();
          signal.addEventListener("abort", onAbort), aborted = await new Promise((resolve) => {
            this.subscribe((aborted2) => {
              signal.removeEventListener("abort", onAbort), (aborted2 || this.done) && resolve(aborted2);
            });
          });
        }
        return aborted;
      }
      get done() {
        return this.pendingKeysSet.size === 0;
      }
      get unwrappedData() {
        return invariant(this.data !== null && this.done, "Can only unwrap data on initialized and settled deferreds"), Object.entries(this.data).reduce((acc, _ref2) => {
          let [key, value] = _ref2;
          return Object.assign(acc, {
            [key]: unwrapTrackedPromise(value)
          });
        }, {});
      }
      get pendingKeys() {
        return Array.from(this.pendingKeysSet);
      }
    };
    function isTrackedPromise(value) {
      return value instanceof Promise && value._tracked === !0;
    }
    function unwrapTrackedPromise(value) {
      if (!isTrackedPromise(value))
        return value;
      if (value._error)
        throw value._error;
      return value._data;
    }
    var defer = function(data, init) {
      init === void 0 && (init = {});
      let responseInit = typeof init == "number" ? {
        status: init
      } : init;
      return new DeferredData(data, responseInit);
    }, redirect = function(url2, init) {
      init === void 0 && (init = 302);
      let responseInit = init;
      typeof responseInit == "number" ? responseInit = {
        status: responseInit
      } : typeof responseInit.status > "u" && (responseInit.status = 302);
      let headers = new Headers(responseInit.headers);
      return headers.set("Location", url2), new Response(null, _extends({}, responseInit, {
        headers
      }));
    }, ErrorResponse = class {
      constructor(status, statusText, data, internal) {
        internal === void 0 && (internal = !1), this.status = status, this.statusText = statusText || "", this.internal = internal, data instanceof Error ? (this.data = data.toString(), this.error = data) : this.data = data;
      }
    };
    function isRouteErrorResponse(error) {
      return error != null && typeof error.status == "number" && typeof error.statusText == "string" && typeof error.internal == "boolean" && "data" in error;
    }
    var validMutationMethodsArr = ["post", "put", "patch", "delete"], validMutationMethods = new Set(validMutationMethodsArr), validRequestMethodsArr = ["get", ...validMutationMethodsArr], validRequestMethods = new Set(validRequestMethodsArr), redirectStatusCodes = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]), redirectPreserveMethodStatusCodes = /* @__PURE__ */ new Set([307, 308]), IDLE_NAVIGATION = {
      state: "idle",
      location: void 0,
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0
    }, IDLE_FETCHER = {
      state: "idle",
      data: void 0,
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0
    }, IDLE_BLOCKER = {
      state: "unblocked",
      proceed: void 0,
      reset: void 0,
      location: void 0
    }, ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, isBrowser = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", isServer = !isBrowser, defaultMapRouteProperties = (route) => ({
      hasErrorBoundary: Boolean(route.hasErrorBoundary)
    });
    function createRouter(init) {
      invariant(init.routes.length > 0, "You must provide a non-empty routes array to createRouter");
      let mapRouteProperties;
      if (init.mapRouteProperties)
        mapRouteProperties = init.mapRouteProperties;
      else if (init.detectErrorBoundary) {
        let detectErrorBoundary = init.detectErrorBoundary;
        mapRouteProperties = (route) => ({
          hasErrorBoundary: detectErrorBoundary(route)
        });
      } else
        mapRouteProperties = defaultMapRouteProperties;
      let manifest = {}, dataRoutes = convertRoutesToDataRoutes(init.routes, mapRouteProperties, void 0, manifest), inFlightDataRoutes, basename = init.basename || "/", future2 = _extends({
        v7_normalizeFormMethod: !1,
        v7_prependBasename: !1
      }, init.future), unlistenHistory = null, subscribers = /* @__PURE__ */ new Set(), savedScrollPositions = null, getScrollRestorationKey = null, getScrollPosition = null, initialScrollRestored = init.hydrationData != null, initialMatches = matchRoutes(dataRoutes, init.history.location, basename), initialErrors = null;
      if (initialMatches == null) {
        let error = getInternalRouterError(404, {
          pathname: init.history.location.pathname
        }), {
          matches,
          route
        } = getShortCircuitMatches(dataRoutes);
        initialMatches = matches, initialErrors = {
          [route.id]: error
        };
      }
      let initialized = (
        // All initialMatches need to be loaded before we're ready.  If we have lazy
        // functions around still then we'll need to run them in initialize()
        !initialMatches.some((m) => m.route.lazy) && // And we have to either have no loaders or have been provided hydrationData
        (!initialMatches.some((m) => m.route.loader) || init.hydrationData != null)
      ), router, state = {
        historyAction: init.history.action,
        location: init.history.location,
        matches: initialMatches,
        initialized,
        navigation: IDLE_NAVIGATION,
        // Don't restore on initial updateState() if we were SSR'd
        restoreScrollPosition: init.hydrationData != null ? !1 : null,
        preventScrollReset: !1,
        revalidation: "idle",
        loaderData: init.hydrationData && init.hydrationData.loaderData || {},
        actionData: init.hydrationData && init.hydrationData.actionData || null,
        errors: init.hydrationData && init.hydrationData.errors || initialErrors,
        fetchers: /* @__PURE__ */ new Map(),
        blockers: /* @__PURE__ */ new Map()
      }, pendingAction = exports.Action.Pop, pendingPreventScrollReset = !1, pendingNavigationController, isUninterruptedRevalidation = !1, isRevalidationRequired = !1, cancelledDeferredRoutes = [], cancelledFetcherLoads = [], fetchControllers = /* @__PURE__ */ new Map(), incrementingLoadId = 0, pendingNavigationLoadId = -1, fetchReloadIds = /* @__PURE__ */ new Map(), fetchRedirectIds = /* @__PURE__ */ new Set(), fetchLoadMatches = /* @__PURE__ */ new Map(), activeDeferreds = /* @__PURE__ */ new Map(), blockerFunctions = /* @__PURE__ */ new Map(), ignoreNextHistoryUpdate = !1;
      function initialize() {
        return unlistenHistory = init.history.listen((_ref) => {
          let {
            action: historyAction,
            location,
            delta
          } = _ref;
          if (ignoreNextHistoryUpdate) {
            ignoreNextHistoryUpdate = !1;
            return;
          }
          warning(blockerFunctions.size === 0 || delta != null, "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.");
          let blockerKey = shouldBlockNavigation({
            currentLocation: state.location,
            nextLocation: location,
            historyAction
          });
          if (blockerKey && delta != null) {
            ignoreNextHistoryUpdate = !0, init.history.go(delta * -1), updateBlocker(blockerKey, {
              state: "blocked",
              location,
              proceed() {
                updateBlocker(blockerKey, {
                  state: "proceeding",
                  proceed: void 0,
                  reset: void 0,
                  location
                }), init.history.go(delta);
              },
              reset() {
                deleteBlocker(blockerKey), updateState({
                  blockers: new Map(router.state.blockers)
                });
              }
            });
            return;
          }
          return startNavigation(historyAction, location);
        }), state.initialized || startNavigation(exports.Action.Pop, state.location), router;
      }
      function dispose() {
        unlistenHistory && unlistenHistory(), subscribers.clear(), pendingNavigationController && pendingNavigationController.abort(), state.fetchers.forEach((_, key) => deleteFetcher(key)), state.blockers.forEach((_, key) => deleteBlocker(key));
      }
      function subscribe(fn) {
        return subscribers.add(fn), () => subscribers.delete(fn);
      }
      function updateState(newState) {
        state = _extends({}, state, newState), subscribers.forEach((subscriber) => subscriber(state));
      }
      function completeNavigation(location, newState) {
        var _location$state, _location$state2;
        let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === "loading" && ((_location$state = location.state) == null ? void 0 : _location$state._isRedirect) !== !0, actionData;
        newState.actionData ? Object.keys(newState.actionData).length > 0 ? actionData = newState.actionData : actionData = null : isActionReload ? actionData = state.actionData : actionData = null;
        let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData;
        for (let [key] of blockerFunctions)
          deleteBlocker(key);
        let preventScrollReset = pendingPreventScrollReset === !0 || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && ((_location$state2 = location.state) == null ? void 0 : _location$state2._isRedirect) !== !0;
        inFlightDataRoutes && (dataRoutes = inFlightDataRoutes, inFlightDataRoutes = void 0), updateState(_extends({}, newState, {
          // matches, errors, fetchers go through as-is
          actionData,
          loaderData,
          historyAction: pendingAction,
          location,
          initialized: !0,
          navigation: IDLE_NAVIGATION,
          revalidation: "idle",
          restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),
          preventScrollReset,
          blockers: new Map(state.blockers)
        })), isUninterruptedRevalidation || pendingAction === exports.Action.Pop || (pendingAction === exports.Action.Push ? init.history.push(location, location.state) : pendingAction === exports.Action.Replace && init.history.replace(location, location.state)), pendingAction = exports.Action.Pop, pendingPreventScrollReset = !1, isUninterruptedRevalidation = !1, isRevalidationRequired = !1, cancelledDeferredRoutes = [], cancelledFetcherLoads = [];
      }
      async function navigate(to, opts) {
        if (typeof to == "number") {
          init.history.go(to);
          return;
        }
        let normalizedPath = normalizeTo(state.location, state.matches, basename, future2.v7_prependBasename, to, opts == null ? void 0 : opts.fromRouteId, opts == null ? void 0 : opts.relative), {
          path,
          submission,
          error
        } = normalizeNavigateOptions(future2.v7_normalizeFormMethod, !1, normalizedPath, opts), currentLocation = state.location, nextLocation = createLocation(state.location, path, opts && opts.state);
        nextLocation = _extends({}, nextLocation, init.history.encodeLocation(nextLocation));
        let userReplace = opts && opts.replace != null ? opts.replace : void 0, historyAction = exports.Action.Push;
        userReplace === !0 ? historyAction = exports.Action.Replace : userReplace === !1 || submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search && (historyAction = exports.Action.Replace);
        let preventScrollReset = opts && "preventScrollReset" in opts ? opts.preventScrollReset === !0 : void 0, blockerKey = shouldBlockNavigation({
          currentLocation,
          nextLocation,
          historyAction
        });
        if (blockerKey) {
          updateBlocker(blockerKey, {
            state: "blocked",
            location: nextLocation,
            proceed() {
              updateBlocker(blockerKey, {
                state: "proceeding",
                proceed: void 0,
                reset: void 0,
                location: nextLocation
              }), navigate(to, opts);
            },
            reset() {
              deleteBlocker(blockerKey), updateState({
                blockers: new Map(state.blockers)
              });
            }
          });
          return;
        }
        return await startNavigation(historyAction, nextLocation, {
          submission,
          // Send through the formData serialization error if we have one so we can
          // render at the right error boundary after we match routes
          pendingError: error,
          preventScrollReset,
          replace: opts && opts.replace
        });
      }
      function revalidate() {
        if (interruptActiveLoads(), updateState({
          revalidation: "loading"
        }), state.navigation.state !== "submitting") {
          if (state.navigation.state === "idle") {
            startNavigation(state.historyAction, state.location, {
              startUninterruptedRevalidation: !0
            });
            return;
          }
          startNavigation(pendingAction || state.historyAction, state.navigation.location, {
            overrideNavigation: state.navigation
          });
        }
      }
      async function startNavigation(historyAction, location, opts) {
        pendingNavigationController && pendingNavigationController.abort(), pendingNavigationController = null, pendingAction = historyAction, isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === !0, saveScrollPosition(state.location, state.matches), pendingPreventScrollReset = (opts && opts.preventScrollReset) === !0;
        let routesToUse = inFlightDataRoutes || dataRoutes, loadingNavigation = opts && opts.overrideNavigation, matches = matchRoutes(routesToUse, location, basename);
        if (!matches) {
          let error = getInternalRouterError(404, {
            pathname: location.pathname
          }), {
            matches: notFoundMatches,
            route
          } = getShortCircuitMatches(routesToUse);
          cancelActiveDeferreds(), completeNavigation(location, {
            matches: notFoundMatches,
            loaderData: {},
            errors: {
              [route.id]: error
            }
          });
          return;
        }
        if (state.initialized && isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {
          completeNavigation(location, {
            matches
          });
          return;
        }
        pendingNavigationController = new AbortController();
        let request = createClientSideRequest(init.history, location, pendingNavigationController.signal, opts && opts.submission), pendingActionData, pendingError;
        if (opts && opts.pendingError)
          pendingError = {
            [findNearestBoundary(matches).route.id]: opts.pendingError
          };
        else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {
          let actionOutput = await handleAction(request, location, opts.submission, matches, {
            replace: opts.replace
          });
          if (actionOutput.shortCircuited)
            return;
          pendingActionData = actionOutput.pendingActionData, pendingError = actionOutput.pendingActionError, loadingNavigation = _extends({
            state: "loading",
            location
          }, opts.submission), request = new Request(request.url, {
            signal: request.signal
          });
        }
        let {
          shortCircuited,
          loaderData,
          errors
        } = await handleLoaders(request, location, matches, loadingNavigation, opts && opts.submission, opts && opts.fetcherSubmission, opts && opts.replace, pendingActionData, pendingError);
        shortCircuited || (pendingNavigationController = null, completeNavigation(location, _extends({
          matches
        }, pendingActionData ? {
          actionData: pendingActionData
        } : {}, {
          loaderData,
          errors
        })));
      }
      async function handleAction(request, location, submission, matches, opts) {
        interruptActiveLoads();
        let navigation = _extends({
          state: "submitting",
          location
        }, submission);
        updateState({
          navigation
        });
        let result, actionMatch = getTargetMatch(matches, location);
        if (!actionMatch.route.action && !actionMatch.route.lazy)
          result = {
            type: ResultType.error,
            error: getInternalRouterError(405, {
              method: request.method,
              pathname: location.pathname,
              routeId: actionMatch.route.id
            })
          };
        else if (result = await callLoaderOrAction("action", request, actionMatch, matches, manifest, mapRouteProperties, basename), request.signal.aborted)
          return {
            shortCircuited: !0
          };
        if (isRedirectResult(result)) {
          let replace;
          return opts && opts.replace != null ? replace = opts.replace : replace = result.location === state.location.pathname + state.location.search, await startRedirectNavigation(state, result, {
            submission,
            replace
          }), {
            shortCircuited: !0
          };
        }
        if (isErrorResult(result)) {
          let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);
          return (opts && opts.replace) !== !0 && (pendingAction = exports.Action.Push), {
            // Send back an empty object we can use to clear out any prior actionData
            pendingActionData: {},
            pendingActionError: {
              [boundaryMatch.route.id]: result.error
            }
          };
        }
        if (isDeferredResult(result))
          throw getInternalRouterError(400, {
            type: "defer-action"
          });
        return {
          pendingActionData: {
            [actionMatch.route.id]: result.data
          }
        };
      }
      async function handleLoaders(request, location, matches, overrideNavigation, submission, fetcherSubmission, replace, pendingActionData, pendingError) {
        let loadingNavigation = overrideNavigation;
        loadingNavigation || (loadingNavigation = _extends({
          state: "loading",
          location,
          formMethod: void 0,
          formAction: void 0,
          formEncType: void 0,
          formData: void 0
        }, submission));
        let activeSubmission = submission || fetcherSubmission ? submission || fetcherSubmission : loadingNavigation.formMethod && loadingNavigation.formAction && loadingNavigation.formData && loadingNavigation.formEncType ? {
          formMethod: loadingNavigation.formMethod,
          formAction: loadingNavigation.formAction,
          formData: loadingNavigation.formData,
          formEncType: loadingNavigation.formEncType
        } : void 0, routesToUse = inFlightDataRoutes || dataRoutes, [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, activeSubmission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, fetchLoadMatches, routesToUse, basename, pendingActionData, pendingError);
        if (cancelActiveDeferreds((routeId) => !(matches && matches.some((m) => m.route.id === routeId)) || matchesToLoad && matchesToLoad.some((m) => m.route.id === routeId)), matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {
          let updatedFetchers2 = markFetchRedirectsDone();
          return completeNavigation(location, _extends({
            matches,
            loaderData: {},
            // Commit pending error if we're short circuiting
            errors: pendingError || null
          }, pendingActionData ? {
            actionData: pendingActionData
          } : {}, updatedFetchers2 ? {
            fetchers: new Map(state.fetchers)
          } : {})), {
            shortCircuited: !0
          };
        }
        if (!isUninterruptedRevalidation) {
          revalidatingFetchers.forEach((rf) => {
            let fetcher = state.fetchers.get(rf.key), revalidatingFetcher = {
              state: "loading",
              data: fetcher && fetcher.data,
              formMethod: void 0,
              formAction: void 0,
              formEncType: void 0,
              formData: void 0,
              " _hasFetcherDoneAnything ": !0
            };
            state.fetchers.set(rf.key, revalidatingFetcher);
          });
          let actionData = pendingActionData || state.actionData;
          updateState(_extends({
            navigation: loadingNavigation
          }, actionData ? Object.keys(actionData).length === 0 ? {
            actionData: null
          } : {
            actionData
          } : {}, revalidatingFetchers.length > 0 ? {
            fetchers: new Map(state.fetchers)
          } : {}));
        }
        pendingNavigationLoadId = ++incrementingLoadId, revalidatingFetchers.forEach((rf) => {
          rf.controller && fetchControllers.set(rf.key, rf.controller);
        });
        let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((f) => abortFetcher(f.key));
        pendingNavigationController && pendingNavigationController.signal.addEventListener("abort", abortPendingFetchRevalidations);
        let {
          results,
          loaderResults,
          fetcherResults
        } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, request);
        if (request.signal.aborted)
          return {
            shortCircuited: !0
          };
        pendingNavigationController && pendingNavigationController.signal.removeEventListener("abort", abortPendingFetchRevalidations), revalidatingFetchers.forEach((rf) => fetchControllers.delete(rf.key));
        let redirect2 = findRedirect(results);
        if (redirect2)
          return await startRedirectNavigation(state, redirect2, {
            replace
          }), {
            shortCircuited: !0
          };
        let {
          loaderData,
          errors
        } = processLoaderData(state, matches, matchesToLoad, loaderResults, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds);
        activeDeferreds.forEach((deferredData, routeId) => {
          deferredData.subscribe((aborted) => {
            (aborted || deferredData.done) && activeDeferreds.delete(routeId);
          });
        });
        let updatedFetchers = markFetchRedirectsDone(), didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId), shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;
        return _extends({
          loaderData,
          errors
        }, shouldUpdateFetchers ? {
          fetchers: new Map(state.fetchers)
        } : {});
      }
      function getFetcher(key) {
        return state.fetchers.get(key) || IDLE_FETCHER;
      }
      function fetch2(key, routeId, href, opts) {
        if (isServer)
          throw new Error("router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback.");
        fetchControllers.has(key) && abortFetcher(key);
        let routesToUse = inFlightDataRoutes || dataRoutes, normalizedPath = normalizeTo(state.location, state.matches, basename, future2.v7_prependBasename, href, routeId, opts == null ? void 0 : opts.relative), matches = matchRoutes(routesToUse, normalizedPath, basename);
        if (!matches) {
          setFetcherError(key, routeId, getInternalRouterError(404, {
            pathname: normalizedPath
          }));
          return;
        }
        let {
          path,
          submission
        } = normalizeNavigateOptions(future2.v7_normalizeFormMethod, !0, normalizedPath, opts), match = getTargetMatch(matches, path);
        if (pendingPreventScrollReset = (opts && opts.preventScrollReset) === !0, submission && isMutationMethod(submission.formMethod)) {
          handleFetcherAction(key, routeId, path, match, matches, submission);
          return;
        }
        fetchLoadMatches.set(key, {
          routeId,
          path
        }), handleFetcherLoader(key, routeId, path, match, matches, submission);
      }
      async function handleFetcherAction(key, routeId, path, match, requestMatches, submission) {
        if (interruptActiveLoads(), fetchLoadMatches.delete(key), !match.route.action && !match.route.lazy) {
          let error = getInternalRouterError(405, {
            method: submission.formMethod,
            pathname: path,
            routeId
          });
          setFetcherError(key, routeId, error);
          return;
        }
        let existingFetcher = state.fetchers.get(key), fetcher = _extends({
          state: "submitting"
        }, submission, {
          data: existingFetcher && existingFetcher.data,
          " _hasFetcherDoneAnything ": !0
        });
        state.fetchers.set(key, fetcher), updateState({
          fetchers: new Map(state.fetchers)
        });
        let abortController = new AbortController(), fetchRequest = createClientSideRequest(init.history, path, abortController.signal, submission);
        fetchControllers.set(key, abortController);
        let actionResult = await callLoaderOrAction("action", fetchRequest, match, requestMatches, manifest, mapRouteProperties, basename);
        if (fetchRequest.signal.aborted) {
          fetchControllers.get(key) === abortController && fetchControllers.delete(key);
          return;
        }
        if (isRedirectResult(actionResult)) {
          fetchControllers.delete(key), fetchRedirectIds.add(key);
          let loadingFetcher = _extends({
            state: "loading"
          }, submission, {
            data: void 0,
            " _hasFetcherDoneAnything ": !0
          });
          return state.fetchers.set(key, loadingFetcher), updateState({
            fetchers: new Map(state.fetchers)
          }), startRedirectNavigation(state, actionResult, {
            submission,
            isFetchActionRedirect: !0
          });
        }
        if (isErrorResult(actionResult)) {
          setFetcherError(key, routeId, actionResult.error);
          return;
        }
        if (isDeferredResult(actionResult))
          throw getInternalRouterError(400, {
            type: "defer-action"
          });
        let nextLocation = state.navigation.location || state.location, revalidationRequest = createClientSideRequest(init.history, nextLocation, abortController.signal), routesToUse = inFlightDataRoutes || dataRoutes, matches = state.navigation.state !== "idle" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;
        invariant(matches, "Didn't find any matches after fetcher action");
        let loadId = ++incrementingLoadId;
        fetchReloadIds.set(key, loadId);
        let loadFetcher = _extends({
          state: "loading",
          data: actionResult.data
        }, submission, {
          " _hasFetcherDoneAnything ": !0
        });
        state.fetchers.set(key, loadFetcher);
        let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(
          init.history,
          state,
          matches,
          submission,
          nextLocation,
          isRevalidationRequired,
          cancelledDeferredRoutes,
          cancelledFetcherLoads,
          fetchLoadMatches,
          routesToUse,
          basename,
          {
            [match.route.id]: actionResult.data
          },
          void 0
          // No need to send through errors since we short circuit above
        );
        revalidatingFetchers.filter((rf) => rf.key !== key).forEach((rf) => {
          let staleKey = rf.key, existingFetcher2 = state.fetchers.get(staleKey), revalidatingFetcher = {
            state: "loading",
            data: existingFetcher2 && existingFetcher2.data,
            formMethod: void 0,
            formAction: void 0,
            formEncType: void 0,
            formData: void 0,
            " _hasFetcherDoneAnything ": !0
          };
          state.fetchers.set(staleKey, revalidatingFetcher), rf.controller && fetchControllers.set(staleKey, rf.controller);
        }), updateState({
          fetchers: new Map(state.fetchers)
        });
        let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((rf) => abortFetcher(rf.key));
        abortController.signal.addEventListener("abort", abortPendingFetchRevalidations);
        let {
          results,
          loaderResults,
          fetcherResults
        } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, revalidationRequest);
        if (abortController.signal.aborted)
          return;
        abortController.signal.removeEventListener("abort", abortPendingFetchRevalidations), fetchReloadIds.delete(key), fetchControllers.delete(key), revalidatingFetchers.forEach((r) => fetchControllers.delete(r.key));
        let redirect2 = findRedirect(results);
        if (redirect2)
          return startRedirectNavigation(state, redirect2);
        let {
          loaderData,
          errors
        } = processLoaderData(state, state.matches, matchesToLoad, loaderResults, void 0, revalidatingFetchers, fetcherResults, activeDeferreds), doneFetcher = {
          state: "idle",
          data: actionResult.data,
          formMethod: void 0,
          formAction: void 0,
          formEncType: void 0,
          formData: void 0,
          " _hasFetcherDoneAnything ": !0
        };
        state.fetchers.set(key, doneFetcher);
        let didAbortFetchLoads = abortStaleFetchLoads(loadId);
        state.navigation.state === "loading" && loadId > pendingNavigationLoadId ? (invariant(pendingAction, "Expected pending action"), pendingNavigationController && pendingNavigationController.abort(), completeNavigation(state.navigation.location, {
          matches,
          loaderData,
          errors,
          fetchers: new Map(state.fetchers)
        })) : (updateState(_extends({
          errors,
          loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors)
        }, didAbortFetchLoads ? {
          fetchers: new Map(state.fetchers)
        } : {})), isRevalidationRequired = !1);
      }
      async function handleFetcherLoader(key, routeId, path, match, matches, submission) {
        let existingFetcher = state.fetchers.get(key), loadingFetcher = _extends({
          state: "loading",
          formMethod: void 0,
          formAction: void 0,
          formEncType: void 0,
          formData: void 0
        }, submission, {
          data: existingFetcher && existingFetcher.data,
          " _hasFetcherDoneAnything ": !0
        });
        state.fetchers.set(key, loadingFetcher), updateState({
          fetchers: new Map(state.fetchers)
        });
        let abortController = new AbortController(), fetchRequest = createClientSideRequest(init.history, path, abortController.signal);
        fetchControllers.set(key, abortController);
        let result = await callLoaderOrAction("loader", fetchRequest, match, matches, manifest, mapRouteProperties, basename);
        if (isDeferredResult(result) && (result = await resolveDeferredData(result, fetchRequest.signal, !0) || result), fetchControllers.get(key) === abortController && fetchControllers.delete(key), fetchRequest.signal.aborted)
          return;
        if (isRedirectResult(result)) {
          fetchRedirectIds.add(key), await startRedirectNavigation(state, result);
          return;
        }
        if (isErrorResult(result)) {
          let boundaryMatch = findNearestBoundary(state.matches, routeId);
          state.fetchers.delete(key), updateState({
            fetchers: new Map(state.fetchers),
            errors: {
              [boundaryMatch.route.id]: result.error
            }
          });
          return;
        }
        invariant(!isDeferredResult(result), "Unhandled fetcher deferred data");
        let doneFetcher = {
          state: "idle",
          data: result.data,
          formMethod: void 0,
          formAction: void 0,
          formEncType: void 0,
          formData: void 0,
          " _hasFetcherDoneAnything ": !0
        };
        state.fetchers.set(key, doneFetcher), updateState({
          fetchers: new Map(state.fetchers)
        });
      }
      async function startRedirectNavigation(state2, redirect2, _temp) {
        var _window;
        let {
          submission,
          replace,
          isFetchActionRedirect
        } = _temp === void 0 ? {} : _temp;
        redirect2.revalidate && (isRevalidationRequired = !0);
        let redirectLocation = createLocation(
          state2.location,
          redirect2.location,
          // TODO: This can be removed once we get rid of useTransition in Remix v2
          _extends({
            _isRedirect: !0
          }, isFetchActionRedirect ? {
            _isFetchActionRedirect: !0
          } : {})
        );
        if (invariant(redirectLocation, "Expected a location on the redirect navigation"), ABSOLUTE_URL_REGEX.test(redirect2.location) && isBrowser && typeof ((_window = window) == null ? void 0 : _window.location) < "u") {
          let url2 = init.history.createURL(redirect2.location), isDifferentBasename = stripBasename(url2.pathname, basename) == null;
          if (window.location.origin !== url2.origin || isDifferentBasename) {
            replace ? window.location.replace(redirect2.location) : window.location.assign(redirect2.location);
            return;
          }
        }
        pendingNavigationController = null;
        let redirectHistoryAction = replace === !0 ? exports.Action.Replace : exports.Action.Push, {
          formMethod,
          formAction,
          formEncType,
          formData
        } = state2.navigation;
        !submission && formMethod && formAction && formData && formEncType && (submission = {
          formMethod,
          formAction,
          formEncType,
          formData
        }), redirectPreserveMethodStatusCodes.has(redirect2.status) && submission && isMutationMethod(submission.formMethod) ? await startNavigation(redirectHistoryAction, redirectLocation, {
          submission: _extends({}, submission, {
            formAction: redirect2.location
          }),
          // Preserve this flag across redirects
          preventScrollReset: pendingPreventScrollReset
        }) : isFetchActionRedirect ? await startNavigation(redirectHistoryAction, redirectLocation, {
          overrideNavigation: {
            state: "loading",
            location: redirectLocation,
            formMethod: void 0,
            formAction: void 0,
            formEncType: void 0,
            formData: void 0
          },
          fetcherSubmission: submission,
          // Preserve this flag across redirects
          preventScrollReset: pendingPreventScrollReset
        }) : await startNavigation(redirectHistoryAction, redirectLocation, {
          overrideNavigation: {
            state: "loading",
            location: redirectLocation,
            formMethod: submission ? submission.formMethod : void 0,
            formAction: submission ? submission.formAction : void 0,
            formEncType: submission ? submission.formEncType : void 0,
            formData: submission ? submission.formData : void 0
          },
          // Preserve this flag across redirects
          preventScrollReset: pendingPreventScrollReset
        });
      }
      async function callLoadersAndMaybeResolveData(currentMatches, matches, matchesToLoad, fetchersToLoad, request) {
        let results = await Promise.all([...matchesToLoad.map((match) => callLoaderOrAction("loader", request, match, matches, manifest, mapRouteProperties, basename)), ...fetchersToLoad.map((f) => f.matches && f.match && f.controller ? callLoaderOrAction("loader", createClientSideRequest(init.history, f.path, f.controller.signal), f.match, f.matches, manifest, mapRouteProperties, basename) : {
          type: ResultType.error,
          error: getInternalRouterError(404, {
            pathname: f.path
          })
        })]), loaderResults = results.slice(0, matchesToLoad.length), fetcherResults = results.slice(matchesToLoad.length);
        return await Promise.all([resolveDeferredResults(currentMatches, matchesToLoad, loaderResults, loaderResults.map(() => request.signal), !1, state.loaderData), resolveDeferredResults(currentMatches, fetchersToLoad.map((f) => f.match), fetcherResults, fetchersToLoad.map((f) => f.controller ? f.controller.signal : null), !0)]), {
          results,
          loaderResults,
          fetcherResults
        };
      }
      function interruptActiveLoads() {
        isRevalidationRequired = !0, cancelledDeferredRoutes.push(...cancelActiveDeferreds()), fetchLoadMatches.forEach((_, key) => {
          fetchControllers.has(key) && (cancelledFetcherLoads.push(key), abortFetcher(key));
        });
      }
      function setFetcherError(key, routeId, error) {
        let boundaryMatch = findNearestBoundary(state.matches, routeId);
        deleteFetcher(key), updateState({
          errors: {
            [boundaryMatch.route.id]: error
          },
          fetchers: new Map(state.fetchers)
        });
      }
      function deleteFetcher(key) {
        fetchControllers.has(key) && abortFetcher(key), fetchLoadMatches.delete(key), fetchReloadIds.delete(key), fetchRedirectIds.delete(key), state.fetchers.delete(key);
      }
      function abortFetcher(key) {
        let controller = fetchControllers.get(key);
        invariant(controller, "Expected fetch controller: " + key), controller.abort(), fetchControllers.delete(key);
      }
      function markFetchersDone(keys) {
        for (let key of keys) {
          let doneFetcher = {
            state: "idle",
            data: getFetcher(key).data,
            formMethod: void 0,
            formAction: void 0,
            formEncType: void 0,
            formData: void 0,
            " _hasFetcherDoneAnything ": !0
          };
          state.fetchers.set(key, doneFetcher);
        }
      }
      function markFetchRedirectsDone() {
        let doneKeys = [], updatedFetchers = !1;
        for (let key of fetchRedirectIds) {
          let fetcher = state.fetchers.get(key);
          invariant(fetcher, "Expected fetcher: " + key), fetcher.state === "loading" && (fetchRedirectIds.delete(key), doneKeys.push(key), updatedFetchers = !0);
        }
        return markFetchersDone(doneKeys), updatedFetchers;
      }
      function abortStaleFetchLoads(landedId) {
        let yeetedKeys = [];
        for (let [key, id] of fetchReloadIds)
          if (id < landedId) {
            let fetcher = state.fetchers.get(key);
            invariant(fetcher, "Expected fetcher: " + key), fetcher.state === "loading" && (abortFetcher(key), fetchReloadIds.delete(key), yeetedKeys.push(key));
          }
        return markFetchersDone(yeetedKeys), yeetedKeys.length > 0;
      }
      function getBlocker(key, fn) {
        let blocker = state.blockers.get(key) || IDLE_BLOCKER;
        return blockerFunctions.get(key) !== fn && blockerFunctions.set(key, fn), blocker;
      }
      function deleteBlocker(key) {
        state.blockers.delete(key), blockerFunctions.delete(key);
      }
      function updateBlocker(key, newBlocker) {
        let blocker = state.blockers.get(key) || IDLE_BLOCKER;
        invariant(blocker.state === "unblocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "proceeding" || blocker.state === "blocked" && newBlocker.state === "unblocked" || blocker.state === "proceeding" && newBlocker.state === "unblocked", "Invalid blocker state transition: " + blocker.state + " -> " + newBlocker.state), state.blockers.set(key, newBlocker), updateState({
          blockers: new Map(state.blockers)
        });
      }
      function shouldBlockNavigation(_ref2) {
        let {
          currentLocation,
          nextLocation,
          historyAction
        } = _ref2;
        if (blockerFunctions.size === 0)
          return;
        blockerFunctions.size > 1 && warning(!1, "A router only supports one blocker at a time");
        let entries = Array.from(blockerFunctions.entries()), [blockerKey, blockerFunction] = entries[entries.length - 1], blocker = state.blockers.get(blockerKey);
        if (!(blocker && blocker.state === "proceeding") && blockerFunction({
          currentLocation,
          nextLocation,
          historyAction
        }))
          return blockerKey;
      }
      function cancelActiveDeferreds(predicate) {
        let cancelledRouteIds = [];
        return activeDeferreds.forEach((dfd, routeId) => {
          (!predicate || predicate(routeId)) && (dfd.cancel(), cancelledRouteIds.push(routeId), activeDeferreds.delete(routeId));
        }), cancelledRouteIds;
      }
      function enableScrollRestoration(positions, getPosition, getKey) {
        if (savedScrollPositions = positions, getScrollPosition = getPosition, getScrollRestorationKey = getKey || ((location) => location.key), !initialScrollRestored && state.navigation === IDLE_NAVIGATION) {
          initialScrollRestored = !0;
          let y = getSavedScrollPosition(state.location, state.matches);
          y != null && updateState({
            restoreScrollPosition: y
          });
        }
        return () => {
          savedScrollPositions = null, getScrollPosition = null, getScrollRestorationKey = null;
        };
      }
      function saveScrollPosition(location, matches) {
        if (savedScrollPositions && getScrollRestorationKey && getScrollPosition) {
          let userMatches = matches.map((m) => createUseMatchesMatch(m, state.loaderData)), key = getScrollRestorationKey(location, userMatches) || location.key;
          savedScrollPositions[key] = getScrollPosition();
        }
      }
      function getSavedScrollPosition(location, matches) {
        if (savedScrollPositions && getScrollRestorationKey && getScrollPosition) {
          let userMatches = matches.map((m) => createUseMatchesMatch(m, state.loaderData)), key = getScrollRestorationKey(location, userMatches) || location.key, y = savedScrollPositions[key];
          if (typeof y == "number")
            return y;
        }
        return null;
      }
      function _internalSetRoutes(newRoutes) {
        manifest = {}, inFlightDataRoutes = convertRoutesToDataRoutes(newRoutes, mapRouteProperties, void 0, manifest);
      }
      return router = {
        get basename() {
          return basename;
        },
        get state() {
          return state;
        },
        get routes() {
          return dataRoutes;
        },
        initialize,
        subscribe,
        enableScrollRestoration,
        navigate,
        fetch: fetch2,
        revalidate,
        // Passthrough to history-aware createHref used by useHref so we get proper
        // hash-aware URLs in DOM paths
        createHref: (to) => init.history.createHref(to),
        encodeLocation: (to) => init.history.encodeLocation(to),
        getFetcher,
        deleteFetcher,
        dispose,
        getBlocker,
        deleteBlocker,
        _internalFetchControllers: fetchControllers,
        _internalActiveDeferreds: activeDeferreds,
        // TODO: Remove setRoutes, it's temporary to avoid dealing with
        // updating the tree while validating the update algorithm.
        _internalSetRoutes
      }, router;
    }
    var UNSAFE_DEFERRED_SYMBOL = Symbol("deferred");
    function createStaticHandler(routes2, opts) {
      invariant(routes2.length > 0, "You must provide a non-empty routes array to createStaticHandler");
      let manifest = {}, basename = (opts ? opts.basename : null) || "/", mapRouteProperties;
      if (opts != null && opts.mapRouteProperties)
        mapRouteProperties = opts.mapRouteProperties;
      else if (opts != null && opts.detectErrorBoundary) {
        let detectErrorBoundary = opts.detectErrorBoundary;
        mapRouteProperties = (route) => ({
          hasErrorBoundary: detectErrorBoundary(route)
        });
      } else
        mapRouteProperties = defaultMapRouteProperties;
      let dataRoutes = convertRoutesToDataRoutes(routes2, mapRouteProperties, void 0, manifest);
      async function query(request, _temp2) {
        let {
          requestContext
        } = _temp2 === void 0 ? {} : _temp2, url2 = new URL(request.url), method = request.method, location = createLocation("", createPath(url2), null, "default"), matches = matchRoutes(dataRoutes, location, basename);
        if (!isValidMethod(method) && method !== "HEAD") {
          let error = getInternalRouterError(405, {
            method
          }), {
            matches: methodNotAllowedMatches,
            route
          } = getShortCircuitMatches(dataRoutes);
          return {
            basename,
            location,
            matches: methodNotAllowedMatches,
            loaderData: {},
            actionData: null,
            errors: {
              [route.id]: error
            },
            statusCode: error.status,
            loaderHeaders: {},
            actionHeaders: {},
            activeDeferreds: null
          };
        } else if (!matches) {
          let error = getInternalRouterError(404, {
            pathname: location.pathname
          }), {
            matches: notFoundMatches,
            route
          } = getShortCircuitMatches(dataRoutes);
          return {
            basename,
            location,
            matches: notFoundMatches,
            loaderData: {},
            actionData: null,
            errors: {
              [route.id]: error
            },
            statusCode: error.status,
            loaderHeaders: {},
            actionHeaders: {},
            activeDeferreds: null
          };
        }
        let result = await queryImpl(request, location, matches, requestContext);
        return isResponse(result) ? result : _extends({
          location,
          basename
        }, result);
      }
      async function queryRoute(request, _temp3) {
        let {
          routeId,
          requestContext
        } = _temp3 === void 0 ? {} : _temp3, url2 = new URL(request.url), method = request.method, location = createLocation("", createPath(url2), null, "default"), matches = matchRoutes(dataRoutes, location, basename);
        if (!isValidMethod(method) && method !== "HEAD" && method !== "OPTIONS")
          throw getInternalRouterError(405, {
            method
          });
        if (!matches)
          throw getInternalRouterError(404, {
            pathname: location.pathname
          });
        let match = routeId ? matches.find((m) => m.route.id === routeId) : getTargetMatch(matches, location);
        if (routeId && !match)
          throw getInternalRouterError(403, {
            pathname: location.pathname,
            routeId
          });
        if (!match)
          throw getInternalRouterError(404, {
            pathname: location.pathname
          });
        let result = await queryImpl(request, location, matches, requestContext, match);
        if (isResponse(result))
          return result;
        let error = result.errors ? Object.values(result.errors)[0] : void 0;
        if (error !== void 0)
          throw error;
        if (result.actionData)
          return Object.values(result.actionData)[0];
        if (result.loaderData) {
          var _result$activeDeferre;
          let data = Object.values(result.loaderData)[0];
          return (_result$activeDeferre = result.activeDeferreds) != null && _result$activeDeferre[match.route.id] && (data[UNSAFE_DEFERRED_SYMBOL] = result.activeDeferreds[match.route.id]), data;
        }
      }
      async function queryImpl(request, location, matches, requestContext, routeMatch) {
        invariant(request.signal, "query()/queryRoute() requests must contain an AbortController signal");
        try {
          if (isMutationMethod(request.method.toLowerCase()))
            return await submit(request, matches, routeMatch || getTargetMatch(matches, location), requestContext, routeMatch != null);
          let result = await loadRouteData(request, matches, requestContext, routeMatch);
          return isResponse(result) ? result : _extends({}, result, {
            actionData: null,
            actionHeaders: {}
          });
        } catch (e) {
          if (isQueryRouteResponse(e)) {
            if (e.type === ResultType.error && !isRedirectResponse(e.response))
              throw e.response;
            return e.response;
          }
          if (isRedirectResponse(e))
            return e;
          throw e;
        }
      }
      async function submit(request, matches, actionMatch, requestContext, isRouteRequest) {
        let result;
        if (!actionMatch.route.action && !actionMatch.route.lazy) {
          let error = getInternalRouterError(405, {
            method: request.method,
            pathname: new URL(request.url).pathname,
            routeId: actionMatch.route.id
          });
          if (isRouteRequest)
            throw error;
          result = {
            type: ResultType.error,
            error
          };
        } else if (result = await callLoaderOrAction("action", request, actionMatch, matches, manifest, mapRouteProperties, basename, !0, isRouteRequest, requestContext), request.signal.aborted) {
          let method = isRouteRequest ? "queryRoute" : "query";
          throw new Error(method + "() call aborted");
        }
        if (isRedirectResult(result))
          throw new Response(null, {
            status: result.status,
            headers: {
              Location: result.location
            }
          });
        if (isDeferredResult(result)) {
          let error = getInternalRouterError(400, {
            type: "defer-action"
          });
          if (isRouteRequest)
            throw error;
          result = {
            type: ResultType.error,
            error
          };
        }
        if (isRouteRequest) {
          if (isErrorResult(result))
            throw result.error;
          return {
            matches: [actionMatch],
            loaderData: {},
            actionData: {
              [actionMatch.route.id]: result.data
            },
            errors: null,
            // Note: statusCode + headers are unused here since queryRoute will
            // return the raw Response or value
            statusCode: 200,
            loaderHeaders: {},
            actionHeaders: {},
            activeDeferreds: null
          };
        }
        if (isErrorResult(result)) {
          let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id), context2 = await loadRouteData(request, matches, requestContext, void 0, {
            [boundaryMatch.route.id]: result.error
          });
          return _extends({}, context2, {
            statusCode: isRouteErrorResponse(result.error) ? result.error.status : 500,
            actionData: null,
            actionHeaders: _extends({}, result.headers ? {
              [actionMatch.route.id]: result.headers
            } : {})
          });
        }
        let loaderRequest = new Request(request.url, {
          headers: request.headers,
          redirect: request.redirect,
          signal: request.signal
        }), context = await loadRouteData(loaderRequest, matches, requestContext);
        return _extends({}, context, result.statusCode ? {
          statusCode: result.statusCode
        } : {}, {
          actionData: {
            [actionMatch.route.id]: result.data
          },
          actionHeaders: _extends({}, result.headers ? {
            [actionMatch.route.id]: result.headers
          } : {})
        });
      }
      async function loadRouteData(request, matches, requestContext, routeMatch, pendingActionError) {
        let isRouteRequest = routeMatch != null;
        if (isRouteRequest && !(routeMatch != null && routeMatch.route.loader) && !(routeMatch != null && routeMatch.route.lazy))
          throw getInternalRouterError(400, {
            method: request.method,
            pathname: new URL(request.url).pathname,
            routeId: routeMatch == null ? void 0 : routeMatch.route.id
          });
        let matchesToLoad = (routeMatch ? [routeMatch] : getLoaderMatchesUntilBoundary(matches, Object.keys(pendingActionError || {})[0])).filter((m) => m.route.loader || m.route.lazy);
        if (matchesToLoad.length === 0)
          return {
            matches,
            // Add a null for all matched routes for proper revalidation on the client
            loaderData: matches.reduce((acc, m) => Object.assign(acc, {
              [m.route.id]: null
            }), {}),
            errors: pendingActionError || null,
            statusCode: 200,
            loaderHeaders: {},
            activeDeferreds: null
          };
        let results = await Promise.all([...matchesToLoad.map((match) => callLoaderOrAction("loader", request, match, matches, manifest, mapRouteProperties, basename, !0, isRouteRequest, requestContext))]);
        if (request.signal.aborted) {
          let method = isRouteRequest ? "queryRoute" : "query";
          throw new Error(method + "() call aborted");
        }
        let activeDeferreds = /* @__PURE__ */ new Map(), context = processRouteLoaderData(matches, matchesToLoad, results, pendingActionError, activeDeferreds), executedLoaders = new Set(matchesToLoad.map((match) => match.route.id));
        return matches.forEach((match) => {
          executedLoaders.has(match.route.id) || (context.loaderData[match.route.id] = null);
        }), _extends({}, context, {
          matches,
          activeDeferreds: activeDeferreds.size > 0 ? Object.fromEntries(activeDeferreds.entries()) : null
        });
      }
      return {
        dataRoutes,
        query,
        queryRoute
      };
    }
    function getStaticContextFromError(routes2, context, error) {
      return _extends({}, context, {
        statusCode: 500,
        errors: {
          [context._deepestRenderedBoundaryId || routes2[0].id]: error
        }
      });
    }
    function isSubmissionNavigation(opts) {
      return opts != null && "formData" in opts;
    }
    function normalizeTo(location, matches, basename, prependBasename, to, fromRouteId, relative) {
      let contextualMatches, activeRouteMatch;
      if (fromRouteId != null && relative !== "path") {
        contextualMatches = [];
        for (let match of matches)
          if (contextualMatches.push(match), match.route.id === fromRouteId) {
            activeRouteMatch = match;
            break;
          }
      } else
        contextualMatches = matches, activeRouteMatch = matches[matches.length - 1];
      let path = resolveTo(to || ".", getPathContributingMatches(contextualMatches).map((m) => m.pathnameBase), stripBasename(location.pathname, basename) || location.pathname, relative === "path");
      return to == null && (path.search = location.search, path.hash = location.hash), (to == null || to === "" || to === ".") && activeRouteMatch && activeRouteMatch.route.index && !hasNakedIndexQuery(path.search) && (path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index"), prependBasename && basename !== "/" && (path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname])), createPath(path);
    }
    function normalizeNavigateOptions(normalizeFormMethod, isFetcher, path, opts) {
      if (!opts || !isSubmissionNavigation(opts))
        return {
          path
        };
      if (opts.formMethod && !isValidMethod(opts.formMethod))
        return {
          path,
          error: getInternalRouterError(405, {
            method: opts.formMethod
          })
        };
      let submission;
      if (opts.formData) {
        let formMethod = opts.formMethod || "get";
        if (submission = {
          formMethod: normalizeFormMethod ? formMethod.toUpperCase() : formMethod.toLowerCase(),
          formAction: stripHashFromPath(path),
          formEncType: opts && opts.formEncType || "application/x-www-form-urlencoded",
          formData: opts.formData
        }, isMutationMethod(submission.formMethod))
          return {
            path,
            submission
          };
      }
      let parsedPath = parsePath(path), searchParams = convertFormDataToSearchParams(opts.formData);
      return isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search) && searchParams.append("index", ""), parsedPath.search = "?" + searchParams, {
        path: createPath(parsedPath),
        submission
      };
    }
    function getLoaderMatchesUntilBoundary(matches, boundaryId) {
      let boundaryMatches = matches;
      if (boundaryId) {
        let index = matches.findIndex((m) => m.route.id === boundaryId);
        index >= 0 && (boundaryMatches = matches.slice(0, index));
      }
      return boundaryMatches;
    }
    function getMatchesToLoad(history, state, matches, submission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, fetchLoadMatches, routesToUse, basename, pendingActionData, pendingError) {
      let actionResult = pendingError ? Object.values(pendingError)[0] : pendingActionData ? Object.values(pendingActionData)[0] : void 0, currentUrl = history.createURL(state.location), nextUrl = history.createURL(location), boundaryId = pendingError ? Object.keys(pendingError)[0] : void 0, navigationMatches = getLoaderMatchesUntilBoundary(matches, boundaryId).filter((match, index) => {
        if (match.route.lazy)
          return !0;
        if (match.route.loader == null)
          return !1;
        if (isNewLoader(state.loaderData, state.matches[index], match) || cancelledDeferredRoutes.some((id) => id === match.route.id))
          return !0;
        let currentRouteMatch = state.matches[index], nextRouteMatch = match;
        return shouldRevalidateLoader(match, _extends({
          currentUrl,
          currentParams: currentRouteMatch.params,
          nextUrl,
          nextParams: nextRouteMatch.params
        }, submission, {
          actionResult,
          defaultShouldRevalidate: (
            // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate
            isRevalidationRequired || // Clicked the same link, resubmitted a GET form
            currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search || // Search params affect all loaders
            currentUrl.search !== nextUrl.search || isNewRouteInstance(currentRouteMatch, nextRouteMatch)
          )
        }));
      }), revalidatingFetchers = [];
      return fetchLoadMatches.forEach((f, key) => {
        if (!matches.some((m) => m.route.id === f.routeId))
          return;
        let fetcherMatches = matchRoutes(routesToUse, f.path, basename);
        if (!fetcherMatches) {
          revalidatingFetchers.push({
            key,
            routeId: f.routeId,
            path: f.path,
            matches: null,
            match: null,
            controller: null
          });
          return;
        }
        let fetcherMatch = getTargetMatch(fetcherMatches, f.path);
        if (cancelledFetcherLoads.includes(key)) {
          revalidatingFetchers.push({
            key,
            routeId: f.routeId,
            path: f.path,
            matches: fetcherMatches,
            match: fetcherMatch,
            controller: new AbortController()
          });
          return;
        }
        shouldRevalidateLoader(fetcherMatch, _extends({
          currentUrl,
          currentParams: state.matches[state.matches.length - 1].params,
          nextUrl,
          nextParams: matches[matches.length - 1].params
        }, submission, {
          actionResult,
          // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate
          defaultShouldRevalidate: isRevalidationRequired
        })) && revalidatingFetchers.push({
          key,
          routeId: f.routeId,
          path: f.path,
          matches: fetcherMatches,
          match: fetcherMatch,
          controller: new AbortController()
        });
      }), [navigationMatches, revalidatingFetchers];
    }
    function isNewLoader(currentLoaderData, currentMatch, match) {
      let isNew = (
        // [a] -> [a, b]
        !currentMatch || // [a, b] -> [a, c]
        match.route.id !== currentMatch.route.id
      ), isMissingData = currentLoaderData[match.route.id] === void 0;
      return isNew || isMissingData;
    }
    function isNewRouteInstance(currentMatch, match) {
      let currentPath = currentMatch.route.path;
      return (
        // param change for this match, /users/123 -> /users/456
        currentMatch.pathname !== match.pathname || // splat param changed, which is not present in match.path
        // e.g. /files/images/avatar.jpg -> files/finances.xls
        currentPath != null && currentPath.endsWith("*") && currentMatch.params["*"] !== match.params["*"]
      );
    }
    function shouldRevalidateLoader(loaderMatch, arg) {
      if (loaderMatch.route.shouldRevalidate) {
        let routeChoice = loaderMatch.route.shouldRevalidate(arg);
        if (typeof routeChoice == "boolean")
          return routeChoice;
      }
      return arg.defaultShouldRevalidate;
    }
    async function loadLazyRouteModule(route, mapRouteProperties, manifest) {
      if (!route.lazy)
        return;
      let lazyRoute = await route.lazy();
      if (!route.lazy)
        return;
      let routeToUpdate = manifest[route.id];
      invariant(routeToUpdate, "No route found in manifest");
      let routeUpdates = {};
      for (let lazyRouteProperty in lazyRoute) {
        let isPropertyStaticallyDefined = routeToUpdate[lazyRouteProperty] !== void 0 && // This property isn't static since it should always be updated based
        // on the route updates
        lazyRouteProperty !== "hasErrorBoundary";
        warning(!isPropertyStaticallyDefined, 'Route "' + routeToUpdate.id + '" has a static property "' + lazyRouteProperty + '" defined but its lazy function is also returning a value for this property. ' + ('The lazy route property "' + lazyRouteProperty + '" will be ignored.')), !isPropertyStaticallyDefined && !immutableRouteKeys.has(lazyRouteProperty) && (routeUpdates[lazyRouteProperty] = lazyRoute[lazyRouteProperty]);
      }
      Object.assign(routeToUpdate, routeUpdates), Object.assign(routeToUpdate, _extends({}, mapRouteProperties(routeToUpdate), {
        lazy: void 0
      }));
    }
    async function callLoaderOrAction(type, request, match, matches, manifest, mapRouteProperties, basename, isStaticRequest, isRouteRequest, requestContext) {
      isStaticRequest === void 0 && (isStaticRequest = !1), isRouteRequest === void 0 && (isRouteRequest = !1);
      let resultType, result, onReject, runHandler = (handler) => {
        let reject, abortPromise = new Promise((_, r) => reject = r);
        return onReject = () => reject(), request.signal.addEventListener("abort", onReject), Promise.race([handler({
          request,
          params: match.params,
          context: requestContext
        }), abortPromise]);
      };
      try {
        let handler = match.route[type];
        if (match.route.lazy)
          if (handler)
            result = (await Promise.all([runHandler(handler), loadLazyRouteModule(match.route, mapRouteProperties, manifest)]))[0];
          else if (await loadLazyRouteModule(match.route, mapRouteProperties, manifest), handler = match.route[type], handler)
            result = await runHandler(handler);
          else if (type === "action") {
            let url2 = new URL(request.url), pathname = url2.pathname + url2.search;
            throw getInternalRouterError(405, {
              method: request.method,
              pathname,
              routeId: match.route.id
            });
          } else
            return {
              type: ResultType.data,
              data: void 0
            };
        else if (handler)
          result = await runHandler(handler);
        else {
          let url2 = new URL(request.url), pathname = url2.pathname + url2.search;
          throw getInternalRouterError(404, {
            pathname
          });
        }
        invariant(result !== void 0, "You defined " + (type === "action" ? "an action" : "a loader") + " for route " + ('"' + match.route.id + "\" but didn't return anything from your `" + type + "` ") + "function. Please return a value or `null`.");
      } catch (e) {
        resultType = ResultType.error, result = e;
      } finally {
        onReject && request.signal.removeEventListener("abort", onReject);
      }
      if (isResponse(result)) {
        let status = result.status;
        if (redirectStatusCodes.has(status)) {
          let location = result.headers.get("Location");
          if (invariant(location, "Redirects returned/thrown from loaders/actions must have a Location header"), !ABSOLUTE_URL_REGEX.test(location))
            location = normalizeTo(new URL(request.url), matches.slice(0, matches.indexOf(match) + 1), basename, !0, location);
          else if (!isStaticRequest) {
            let currentUrl = new URL(request.url), url2 = location.startsWith("//") ? new URL(currentUrl.protocol + location) : new URL(location), isSameBasename = stripBasename(url2.pathname, basename) != null;
            url2.origin === currentUrl.origin && isSameBasename && (location = url2.pathname + url2.search + url2.hash);
          }
          if (isStaticRequest)
            throw result.headers.set("Location", location), result;
          return {
            type: ResultType.redirect,
            status,
            location,
            revalidate: result.headers.get("X-Remix-Revalidate") !== null
          };
        }
        if (isRouteRequest)
          throw {
            type: resultType || ResultType.data,
            response: result
          };
        let data, contentType = result.headers.get("Content-Type");
        return contentType && /\bapplication\/json\b/.test(contentType) ? data = await result.json() : data = await result.text(), resultType === ResultType.error ? {
          type: resultType,
          error: new ErrorResponse(status, result.statusText, data),
          headers: result.headers
        } : {
          type: ResultType.data,
          data,
          statusCode: result.status,
          headers: result.headers
        };
      }
      if (resultType === ResultType.error)
        return {
          type: resultType,
          error: result
        };
      if (isDeferredData(result)) {
        var _result$init, _result$init2;
        return {
          type: ResultType.deferred,
          deferredData: result,
          statusCode: (_result$init = result.init) == null ? void 0 : _result$init.status,
          headers: ((_result$init2 = result.init) == null ? void 0 : _result$init2.headers) && new Headers(result.init.headers)
        };
      }
      return {
        type: ResultType.data,
        data: result
      };
    }
    function createClientSideRequest(history, location, signal, submission) {
      let url2 = history.createURL(stripHashFromPath(location)).toString(), init = {
        signal
      };
      if (submission && isMutationMethod(submission.formMethod)) {
        let {
          formMethod,
          formEncType,
          formData
        } = submission;
        init.method = formMethod.toUpperCase(), init.body = formEncType === "application/x-www-form-urlencoded" ? convertFormDataToSearchParams(formData) : formData;
      }
      return new Request(url2, init);
    }
    function convertFormDataToSearchParams(formData) {
      let searchParams = new URLSearchParams();
      for (let [key, value] of formData.entries())
        searchParams.append(key, value instanceof File ? value.name : value);
      return searchParams;
    }
    function processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds) {
      let loaderData = {}, errors = null, statusCode, foundError = !1, loaderHeaders = {};
      return results.forEach((result, index) => {
        let id = matchesToLoad[index].route.id;
        if (invariant(!isRedirectResult(result), "Cannot handle redirect results in processLoaderData"), isErrorResult(result)) {
          let boundaryMatch = findNearestBoundary(matches, id), error = result.error;
          pendingError && (error = Object.values(pendingError)[0], pendingError = void 0), errors = errors || {}, errors[boundaryMatch.route.id] == null && (errors[boundaryMatch.route.id] = error), loaderData[id] = void 0, foundError || (foundError = !0, statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500), result.headers && (loaderHeaders[id] = result.headers);
        } else
          isDeferredResult(result) ? (activeDeferreds.set(id, result.deferredData), loaderData[id] = result.deferredData.data) : loaderData[id] = result.data, result.statusCode != null && result.statusCode !== 200 && !foundError && (statusCode = result.statusCode), result.headers && (loaderHeaders[id] = result.headers);
      }), pendingError && (errors = pendingError, loaderData[Object.keys(pendingError)[0]] = void 0), {
        loaderData,
        errors,
        statusCode: statusCode || 200,
        loaderHeaders
      };
    }
    function processLoaderData(state, matches, matchesToLoad, results, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds) {
      let {
        loaderData,
        errors
      } = processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds);
      for (let index = 0; index < revalidatingFetchers.length; index++) {
        let {
          key,
          match,
          controller
        } = revalidatingFetchers[index];
        invariant(fetcherResults !== void 0 && fetcherResults[index] !== void 0, "Did not find corresponding fetcher result");
        let result = fetcherResults[index];
        if (!(controller && controller.signal.aborted))
          if (isErrorResult(result)) {
            let boundaryMatch = findNearestBoundary(state.matches, match == null ? void 0 : match.route.id);
            errors && errors[boundaryMatch.route.id] || (errors = _extends({}, errors, {
              [boundaryMatch.route.id]: result.error
            })), state.fetchers.delete(key);
          } else if (isRedirectResult(result))
            invariant(!1, "Unhandled fetcher revalidation redirect");
          else if (isDeferredResult(result))
            invariant(!1, "Unhandled fetcher deferred data");
          else {
            let doneFetcher = {
              state: "idle",
              data: result.data,
              formMethod: void 0,
              formAction: void 0,
              formEncType: void 0,
              formData: void 0,
              " _hasFetcherDoneAnything ": !0
            };
            state.fetchers.set(key, doneFetcher);
          }
      }
      return {
        loaderData,
        errors
      };
    }
    function mergeLoaderData(loaderData, newLoaderData, matches, errors) {
      let mergedLoaderData = _extends({}, newLoaderData);
      for (let match of matches) {
        let id = match.route.id;
        if (newLoaderData.hasOwnProperty(id) ? newLoaderData[id] !== void 0 && (mergedLoaderData[id] = newLoaderData[id]) : loaderData[id] !== void 0 && match.route.loader && (mergedLoaderData[id] = loaderData[id]), errors && errors.hasOwnProperty(id))
          break;
      }
      return mergedLoaderData;
    }
    function findNearestBoundary(matches, routeId) {
      return (routeId ? matches.slice(0, matches.findIndex((m) => m.route.id === routeId) + 1) : [...matches]).reverse().find((m) => m.route.hasErrorBoundary === !0) || matches[0];
    }
    function getShortCircuitMatches(routes2) {
      let route = routes2.find((r) => r.index || !r.path || r.path === "/") || {
        id: "__shim-error-route__"
      };
      return {
        matches: [{
          params: {},
          pathname: "",
          pathnameBase: "",
          route
        }],
        route
      };
    }
    function getInternalRouterError(status, _temp4) {
      let {
        pathname,
        routeId,
        method,
        type
      } = _temp4 === void 0 ? {} : _temp4, statusText = "Unknown Server Error", errorMessage = "Unknown @remix-run/router error";
      return status === 400 ? (statusText = "Bad Request", method && pathname && routeId ? errorMessage = "You made a " + method + ' request to "' + pathname + '" but ' + ('did not provide a `loader` for route "' + routeId + '", ') + "so there is no way to handle the request." : type === "defer-action" && (errorMessage = "defer() is not supported in actions")) : status === 403 ? (statusText = "Forbidden", errorMessage = 'Route "' + routeId + '" does not match URL "' + pathname + '"') : status === 404 ? (statusText = "Not Found", errorMessage = 'No route matches URL "' + pathname + '"') : status === 405 && (statusText = "Method Not Allowed", method && pathname && routeId ? errorMessage = "You made a " + method.toUpperCase() + ' request to "' + pathname + '" but ' + ('did not provide an `action` for route "' + routeId + '", ') + "so there is no way to handle the request." : method && (errorMessage = 'Invalid request method "' + method.toUpperCase() + '"')), new ErrorResponse(status || 500, statusText, new Error(errorMessage), !0);
    }
    function findRedirect(results) {
      for (let i = results.length - 1; i >= 0; i--) {
        let result = results[i];
        if (isRedirectResult(result))
          return result;
      }
    }
    function stripHashFromPath(path) {
      let parsedPath = typeof path == "string" ? parsePath(path) : path;
      return createPath(_extends({}, parsedPath, {
        hash: ""
      }));
    }
    function isHashChangeOnly(a, b) {
      return a.pathname !== b.pathname || a.search !== b.search ? !1 : a.hash === "" ? b.hash !== "" : a.hash === b.hash ? !0 : b.hash !== "";
    }
    function isDeferredResult(result) {
      return result.type === ResultType.deferred;
    }
    function isErrorResult(result) {
      return result.type === ResultType.error;
    }
    function isRedirectResult(result) {
      return (result && result.type) === ResultType.redirect;
    }
    function isDeferredData(value) {
      let deferred = value;
      return deferred && typeof deferred == "object" && typeof deferred.data == "object" && typeof deferred.subscribe == "function" && typeof deferred.cancel == "function" && typeof deferred.resolveData == "function";
    }
    function isResponse(value) {
      return value != null && typeof value.status == "number" && typeof value.statusText == "string" && typeof value.headers == "object" && typeof value.body < "u";
    }
    function isRedirectResponse(result) {
      if (!isResponse(result))
        return !1;
      let status = result.status, location = result.headers.get("Location");
      return status >= 300 && status <= 399 && location != null;
    }
    function isQueryRouteResponse(obj) {
      return obj && isResponse(obj.response) && (obj.type === ResultType.data || ResultType.error);
    }
    function isValidMethod(method) {
      return validRequestMethods.has(method.toLowerCase());
    }
    function isMutationMethod(method) {
      return validMutationMethods.has(method.toLowerCase());
    }
    async function resolveDeferredResults(currentMatches, matchesToLoad, results, signals, isFetcher, currentLoaderData) {
      for (let index = 0; index < results.length; index++) {
        let result = results[index], match = matchesToLoad[index];
        if (!match)
          continue;
        let currentMatch = currentMatches.find((m) => m.route.id === match.route.id), isRevalidatingLoader = currentMatch != null && !isNewRouteInstance(currentMatch, match) && (currentLoaderData && currentLoaderData[match.route.id]) !== void 0;
        if (isDeferredResult(result) && (isFetcher || isRevalidatingLoader)) {
          let signal = signals[index];
          invariant(signal, "Expected an AbortSignal for revalidating fetcher deferred result"), await resolveDeferredData(result, signal, isFetcher).then((result2) => {
            result2 && (results[index] = result2 || results[index]);
          });
        }
      }
    }
    async function resolveDeferredData(result, signal, unwrap) {
      if (unwrap === void 0 && (unwrap = !1), !await result.deferredData.resolveData(signal)) {
        if (unwrap)
          try {
            return {
              type: ResultType.data,
              data: result.deferredData.unwrappedData
            };
          } catch (e) {
            return {
              type: ResultType.error,
              error: e
            };
          }
        return {
          type: ResultType.data,
          data: result.deferredData.data
        };
      }
    }
    function hasNakedIndexQuery(search) {
      return new URLSearchParams(search).getAll("index").some((v) => v === "");
    }
    function createUseMatchesMatch(match, loaderData) {
      let {
        route,
        pathname,
        params
      } = match;
      return {
        id: route.id,
        pathname,
        params,
        data: loaderData[route.id],
        handle: route.handle
      };
    }
    function getTargetMatch(matches, location) {
      let search = typeof location == "string" ? parsePath(location).search : location.search;
      if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || ""))
        return matches[matches.length - 1];
      let pathMatches = getPathContributingMatches(matches);
      return pathMatches[pathMatches.length - 1];
    }
    exports.AbortedDeferredError = AbortedDeferredError;
    exports.ErrorResponse = ErrorResponse;
    exports.IDLE_BLOCKER = IDLE_BLOCKER;
    exports.IDLE_FETCHER = IDLE_FETCHER;
    exports.IDLE_NAVIGATION = IDLE_NAVIGATION;
    exports.UNSAFE_DEFERRED_SYMBOL = UNSAFE_DEFERRED_SYMBOL;
    exports.UNSAFE_DeferredData = DeferredData;
    exports.UNSAFE_convertRoutesToDataRoutes = convertRoutesToDataRoutes;
    exports.UNSAFE_getPathContributingMatches = getPathContributingMatches;
    exports.UNSAFE_invariant = invariant;
    exports.UNSAFE_warning = warning;
    exports.createBrowserHistory = createBrowserHistory;
    exports.createHashHistory = createHashHistory;
    exports.createMemoryHistory = createMemoryHistory;
    exports.createPath = createPath;
    exports.createRouter = createRouter;
    exports.createStaticHandler = createStaticHandler;
    exports.defer = defer;
    exports.generatePath = generatePath;
    exports.getStaticContextFromError = getStaticContextFromError;
    exports.getToPathname = getToPathname;
    exports.isDeferredData = isDeferredData;
    exports.isRouteErrorResponse = isRouteErrorResponse;
    exports.joinPaths = joinPaths;
    exports.json = json;
    exports.matchPath = matchPath;
    exports.matchRoutes = matchRoutes;
    exports.normalizePathname = normalizePathname;
    exports.parsePath = parsePath;
    exports.redirect = redirect;
    exports.resolvePath = resolvePath;
    exports.resolveTo = resolveTo;
    exports.stripBasename = stripBasename;
  }
});

// node_modules/@remix-run/server-runtime/dist/mode.js
var require_mode = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/mode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var ServerMode = /* @__PURE__ */ function(ServerMode2) {
      return ServerMode2.Development = "development", ServerMode2.Production = "production", ServerMode2.Test = "test", ServerMode2;
    }({});
    function isServerMode(value) {
      return value === ServerMode.Development || value === ServerMode.Production || value === ServerMode.Test;
    }
    exports.ServerMode = ServerMode;
    exports.isServerMode = isServerMode;
  }
});

// node_modules/@remix-run/server-runtime/dist/errors.js
var require_errors = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var router = require_router_cjs(), mode = require_mode();
    function sanitizeError(error, serverMode) {
      if (error instanceof Error && serverMode !== mode.ServerMode.Development) {
        let sanitized = new Error("Unexpected Server Error");
        return sanitized.stack = void 0, sanitized;
      }
      return error;
    }
    function sanitizeErrors(errors, serverMode) {
      return Object.entries(errors).reduce((acc, [routeId, error]) => Object.assign(acc, {
        [routeId]: sanitizeError(error, serverMode)
      }), {});
    }
    function serializeError(error, serverMode) {
      let sanitized = sanitizeError(error, serverMode);
      return {
        message: sanitized.message,
        stack: sanitized.stack
      };
    }
    function serializeErrors(errors, serverMode) {
      if (!errors)
        return null;
      let entries = Object.entries(errors), serialized = {};
      for (let [key, val] of entries)
        if (router.isRouteErrorResponse(val))
          serialized[key] = {
            ...val,
            __type: "RouteErrorResponse"
          };
        else if (val instanceof Error) {
          let sanitized = sanitizeError(val, serverMode);
          serialized[key] = {
            message: sanitized.message,
            stack: sanitized.stack,
            __type: "Error"
          };
        } else
          serialized[key] = val;
      return serialized;
    }
    exports.sanitizeError = sanitizeError;
    exports.sanitizeErrors = sanitizeErrors;
    exports.serializeError = serializeError;
    exports.serializeErrors = serializeErrors;
  }
});

// node_modules/@remix-run/server-runtime/dist/responses.js
var require_responses = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/responses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var router = require_router_cjs(), errors = require_errors(), json = (data, init = {}) => router.json(data, init), defer = (data, init = {}) => router.defer(data, init), redirect = (url2, init = 302) => router.redirect(url2, init);
    function isDeferredData(value) {
      let deferred = value;
      return deferred && typeof deferred == "object" && typeof deferred.data == "object" && typeof deferred.subscribe == "function" && typeof deferred.cancel == "function" && typeof deferred.resolveData == "function";
    }
    function isResponse(value) {
      return value != null && typeof value.status == "number" && typeof value.statusText == "string" && typeof value.headers == "object" && typeof value.body < "u";
    }
    var redirectStatusCodes = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
    function isRedirectStatusCode(statusCode) {
      return redirectStatusCodes.has(statusCode);
    }
    function isRedirectResponse(response) {
      return isRedirectStatusCode(response.status);
    }
    function isTrackedPromise(value) {
      return value != null && typeof value.then == "function" && value._tracked === !0;
    }
    var DEFERRED_VALUE_PLACEHOLDER_PREFIX = "__deferred_promise:";
    function createDeferredReadableStream(deferredData, signal, serverMode) {
      let encoder = new TextEncoder();
      return new ReadableStream({
        async start(controller) {
          let criticalData = {}, preresolvedKeys = [];
          for (let [key, value] of Object.entries(deferredData.data))
            isTrackedPromise(value) ? (criticalData[key] = `${DEFERRED_VALUE_PLACEHOLDER_PREFIX}${key}`, (typeof value._data < "u" || typeof value._error < "u") && preresolvedKeys.push(key)) : criticalData[key] = value;
          controller.enqueue(encoder.encode(JSON.stringify(criticalData) + `

`));
          for (let preresolvedKey of preresolvedKeys)
            enqueueTrackedPromise(controller, encoder, preresolvedKey, deferredData.data[preresolvedKey], serverMode);
          let unsubscribe = deferredData.subscribe((aborted, settledKey) => {
            settledKey && enqueueTrackedPromise(controller, encoder, settledKey, deferredData.data[settledKey], serverMode);
          });
          await deferredData.resolveData(signal), unsubscribe(), controller.close();
        }
      });
    }
    function enqueueTrackedPromise(controller, encoder, settledKey, promise, serverMode) {
      "_error" in promise ? controller.enqueue(encoder.encode("error:" + JSON.stringify({
        [settledKey]: promise._error instanceof Error ? errors.serializeError(promise._error, serverMode) : promise._error
      }) + `

`)) : controller.enqueue(encoder.encode("data:" + JSON.stringify({
        [settledKey]: promise._data ?? null
      }) + `

`));
    }
    exports.createDeferredReadableStream = createDeferredReadableStream;
    exports.defer = defer;
    exports.isDeferredData = isDeferredData;
    exports.isRedirectResponse = isRedirectResponse;
    exports.isRedirectStatusCode = isRedirectStatusCode;
    exports.isResponse = isResponse;
    exports.json = json;
    exports.redirect = redirect;
  }
});

// node_modules/@remix-run/server-runtime/dist/entry.js
var require_entry = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/entry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    function createEntryRouteModules(manifest) {
      return Object.keys(manifest).reduce((memo, routeId) => (memo[routeId] = manifest[routeId].module, memo), {});
    }
    exports.createEntryRouteModules = createEntryRouteModules;
  }
});

// node_modules/set-cookie-parser/lib/set-cookie.js
var require_set_cookie = __commonJS({
  "node_modules/set-cookie-parser/lib/set-cookie.js"(exports, module2) {
    "use strict";
    var defaultParseOptions = {
      decodeValues: !0,
      map: !1,
      silent: !1
    };
    function isNonEmptyString(str) {
      return typeof str == "string" && !!str.trim();
    }
    function parseString(setCookieValue, options) {
      var parts = setCookieValue.split(";").filter(isNonEmptyString), nameValuePairStr = parts.shift(), parsed = parseNameValuePair(nameValuePairStr), name = parsed.name, value = parsed.value;
      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
      try {
        value = options.decodeValues ? decodeURIComponent(value) : value;
      } catch (e) {
        console.error(
          "set-cookie-parser encountered an error while decoding a cookie with value '" + value + "'. Set options.decodeValues to false to disable this feature.",
          e
        );
      }
      var cookie = {
        name,
        value
      };
      return parts.forEach(function(part) {
        var sides = part.split("="), key = sides.shift().trimLeft().toLowerCase(), value2 = sides.join("=");
        key === "expires" ? cookie.expires = new Date(value2) : key === "max-age" ? cookie.maxAge = parseInt(value2, 10) : key === "secure" ? cookie.secure = !0 : key === "httponly" ? cookie.httpOnly = !0 : key === "samesite" ? cookie.sameSite = value2 : cookie[key] = value2;
      }), cookie;
    }
    function parseNameValuePair(nameValuePairStr) {
      var name = "", value = "", nameValueArr = nameValuePairStr.split("=");
      return nameValueArr.length > 1 ? (name = nameValueArr.shift(), value = nameValueArr.join("=")) : value = nameValuePairStr, { name, value };
    }
    function parse(input, options) {
      if (options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions, !input)
        return options.map ? {} : [];
      if (input.headers)
        if (typeof input.headers.getSetCookie == "function")
          input = input.headers.getSetCookie();
        else if (input.headers["set-cookie"])
          input = input.headers["set-cookie"];
        else {
          var sch = input.headers[Object.keys(input.headers).find(function(key) {
            return key.toLowerCase() === "set-cookie";
          })];
          !sch && input.headers.cookie && !options.silent && console.warn(
            "Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning."
          ), input = sch;
        }
      if (Array.isArray(input) || (input = [input]), options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions, options.map) {
        var cookies = {};
        return input.filter(isNonEmptyString).reduce(function(cookies2, str) {
          var cookie = parseString(str, options);
          return cookies2[cookie.name] = cookie, cookies2;
        }, cookies);
      } else
        return input.filter(isNonEmptyString).map(function(str) {
          return parseString(str, options);
        });
    }
    function splitCookiesString(cookiesString) {
      if (Array.isArray(cookiesString))
        return cookiesString;
      if (typeof cookiesString != "string")
        return [];
      var cookiesStrings = [], pos = 0, start, ch, lastComma, nextStart, cookiesSeparatorFound;
      function skipWhitespace() {
        for (; pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos)); )
          pos += 1;
        return pos < cookiesString.length;
      }
      function notSpecialChar() {
        return ch = cookiesString.charAt(pos), ch !== "=" && ch !== ";" && ch !== ",";
      }
      for (; pos < cookiesString.length; ) {
        for (start = pos, cookiesSeparatorFound = !1; skipWhitespace(); )
          if (ch = cookiesString.charAt(pos), ch === ",") {
            for (lastComma = pos, pos += 1, skipWhitespace(), nextStart = pos; pos < cookiesString.length && notSpecialChar(); )
              pos += 1;
            pos < cookiesString.length && cookiesString.charAt(pos) === "=" ? (cookiesSeparatorFound = !0, pos = nextStart, cookiesStrings.push(cookiesString.substring(start, lastComma)), start = pos) : pos = lastComma + 1;
          } else
            pos += 1;
        (!cookiesSeparatorFound || pos >= cookiesString.length) && cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
      }
      return cookiesStrings;
    }
    module2.exports = parse;
    module2.exports.parse = parse;
    module2.exports.parseString = parseString;
    module2.exports.splitCookiesString = splitCookiesString;
  }
});

// node_modules/@remix-run/server-runtime/dist/headers.js
var require_headers = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/headers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var setCookieParser = require_set_cookie();
    function getDocumentHeadersRR(build, context) {
      return (context.errors ? context.matches.slice(0, context.matches.findIndex((m) => context.errors[m.route.id]) + 1) : context.matches).reduce((parentHeaders, match) => {
        let {
          id
        } = match.route, routeModule = build.routes[id].module, loaderHeaders = context.loaderHeaders[id] || new Headers(), actionHeaders = context.actionHeaders[id] || new Headers(), headers = new Headers(routeModule.headers ? typeof routeModule.headers == "function" ? routeModule.headers({
          loaderHeaders,
          parentHeaders,
          actionHeaders
        }) : routeModule.headers : void 0);
        return prependCookies(actionHeaders, headers), prependCookies(loaderHeaders, headers), prependCookies(parentHeaders, headers), headers;
      }, new Headers());
    }
    function prependCookies(parentHeaders, childHeaders) {
      let parentSetCookieString = parentHeaders.get("Set-Cookie");
      parentSetCookieString && setCookieParser.splitCookiesString(parentSetCookieString).forEach((cookie) => {
        childHeaders.append("Set-Cookie", cookie);
      });
    }
    exports.getDocumentHeadersRR = getDocumentHeadersRR;
  }
});

// node_modules/@remix-run/server-runtime/dist/invariant.js
var require_invariant = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/invariant.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    function invariant(value, message) {
      if (value === !1 || value === null || typeof value > "u")
        throw console.error("The following error is a bug in Remix; please open an issue! https://github.com/remix-run/remix/issues/new"), new Error(message);
    }
    exports.default = invariant;
  }
});

// node_modules/@remix-run/server-runtime/dist/routeMatching.js
var require_routeMatching = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/routeMatching.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var router = require_router_cjs();
    function matchServerRoutes(routes2, pathname) {
      let matches = router.matchRoutes(routes2, pathname);
      return matches ? matches.map((match) => ({
        params: match.params,
        pathname: match.pathname,
        route: match.route
      })) : null;
    }
    exports.matchServerRoutes = matchServerRoutes;
  }
});

// node_modules/@remix-run/server-runtime/dist/data.js
var require_data = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/data.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var responses = require_responses();
    async function callRouteActionRR({
      loadContext,
      action,
      params,
      request,
      routeId
    }) {
      let result = await action({
        request: stripDataParam(stripIndexParam(request)),
        context: loadContext,
        params
      });
      if (result === void 0)
        throw new Error(`You defined an action for route "${routeId}" but didn't return anything from your \`action\` function. Please return a value or \`null\`.`);
      return responses.isResponse(result) ? result : responses.json(result);
    }
    async function callRouteLoaderRR({
      loadContext,
      loader: loader3,
      params,
      request,
      routeId
    }) {
      let result = await loader3({
        request: stripDataParam(stripIndexParam(request)),
        context: loadContext,
        params
      });
      if (result === void 0)
        throw new Error(`You defined a loader for route "${routeId}" but didn't return anything from your \`loader\` function. Please return a value or \`null\`.`);
      return responses.isDeferredData(result) ? result.init && responses.isRedirectStatusCode(result.init.status || 200) ? responses.redirect(new Headers(result.init.headers).get("Location"), result.init) : result : responses.isResponse(result) ? result : responses.json(result);
    }
    function stripIndexParam(request) {
      let url2 = new URL(request.url), indexValues = url2.searchParams.getAll("index");
      url2.searchParams.delete("index");
      let indexValuesToKeep = [];
      for (let indexValue of indexValues)
        indexValue && indexValuesToKeep.push(indexValue);
      for (let toKeep of indexValuesToKeep)
        url2.searchParams.append("index", toKeep);
      return new Request(url2.href, request);
    }
    function stripDataParam(request) {
      let url2 = new URL(request.url);
      return url2.searchParams.delete("_data"), new Request(url2.href, request);
    }
    exports.callRouteActionRR = callRouteActionRR;
    exports.callRouteLoaderRR = callRouteLoaderRR;
  }
});

// node_modules/@remix-run/server-runtime/dist/routes.js
var require_routes = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/routes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var data = require_data();
    function groupRoutesByParentId(manifest) {
      let routes2 = {};
      return Object.values(manifest).forEach((route) => {
        let parentId = route.parentId || "";
        routes2[parentId] || (routes2[parentId] = []), routes2[parentId].push(route);
      }), routes2;
    }
    function createRoutes(manifest, parentId = "", routesByParentId = groupRoutesByParentId(manifest)) {
      return (routesByParentId[parentId] || []).map((route) => ({
        ...route,
        children: createRoutes(manifest, route.id, routesByParentId)
      }));
    }
    function createStaticHandlerDataRoutes(manifest, future2, parentId = "", routesByParentId = groupRoutesByParentId(manifest)) {
      return (routesByParentId[parentId] || []).map((route) => {
        let commonRoute = {
          // Always include root due to default boundaries
          hasErrorBoundary: future2.v2_errorBoundary === !0 ? route.id === "root" || route.module.ErrorBoundary != null : route.id === "root" || route.module.CatchBoundary != null || route.module.ErrorBoundary != null,
          id: route.id,
          path: route.path,
          loader: route.module.loader ? (args) => data.callRouteLoaderRR({
            request: args.request,
            params: args.params,
            loadContext: args.context,
            loader: route.module.loader,
            routeId: route.id
          }) : void 0,
          action: route.module.action ? (args) => data.callRouteActionRR({
            request: args.request,
            params: args.params,
            loadContext: args.context,
            action: route.module.action,
            routeId: route.id
          }) : void 0,
          handle: route.module.handle
        };
        return route.index ? {
          index: !0,
          ...commonRoute
        } : {
          caseSensitive: route.caseSensitive,
          children: createStaticHandlerDataRoutes(manifest, future2, route.id, routesByParentId),
          ...commonRoute
        };
      });
    }
    exports.createRoutes = createRoutes;
    exports.createStaticHandlerDataRoutes = createStaticHandlerDataRoutes;
  }
});

// node_modules/@remix-run/server-runtime/dist/markup.js
var require_markup = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/markup.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var ESCAPE_LOOKUP = {
      "&": "\\u0026",
      ">": "\\u003e",
      "<": "\\u003c",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    }, ESCAPE_REGEX = /[&><\u2028\u2029]/g;
    function escapeHtml(html) {
      return html.replace(ESCAPE_REGEX, (match) => ESCAPE_LOOKUP[match]);
    }
    exports.escapeHtml = escapeHtml;
  }
});

// node_modules/@remix-run/server-runtime/dist/serverHandoff.js
var require_serverHandoff = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/serverHandoff.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var markup = require_markup();
    function createServerHandoffString(serverHandoff) {
      return markup.escapeHtml(JSON.stringify(serverHandoff));
    }
    exports.createServerHandoffString = createServerHandoffString;
  }
});

// node_modules/@remix-run/server-runtime/dist/server.js
var require_server = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/server.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var router = require_router_cjs(), entry2 = require_entry(), errors = require_errors(), headers = require_headers(), invariant = require_invariant(), mode = require_mode(), routeMatching = require_routeMatching(), routes2 = require_routes(), responses = require_responses(), serverHandoff = require_serverHandoff(), createRequestHandler = (build, mode$1) => {
      let routes$1 = routes2.createRoutes(build.routes), dataRoutes = routes2.createStaticHandlerDataRoutes(build.routes, build.future), serverMode = mode.isServerMode(mode$1) ? mode$1 : mode.ServerMode.Production, staticHandler = router.createStaticHandler(dataRoutes);
      return async function(request, loadContext = {}) {
        let url2 = new URL(request.url), matches = routeMatching.matchServerRoutes(routes$1, url2.pathname), response;
        if (url2.searchParams.has("_data")) {
          let routeId = url2.searchParams.get("_data");
          if (response = await handleDataRequestRR(serverMode, staticHandler, routeId, request, loadContext), build.entry.module.handleDataRequest) {
            let match = matches.find((match2) => match2.route.id == routeId);
            response = await build.entry.module.handleDataRequest(response, {
              context: loadContext,
              params: match ? match.params : {},
              request
            });
          }
        } else
          matches && matches[matches.length - 1].route.module.default == null ? response = await handleResourceRequestRR(serverMode, staticHandler, matches.slice(-1)[0].route.id, request, loadContext) : response = await handleDocumentRequestRR(serverMode, build, staticHandler, request, loadContext);
        return request.method === "HEAD" ? new Response(null, {
          headers: response.headers,
          status: response.status,
          statusText: response.statusText
        }) : response;
      };
    };
    async function handleDataRequestRR(serverMode, staticHandler, routeId, request, loadContext) {
      try {
        let response = await staticHandler.queryRoute(request, {
          routeId,
          requestContext: loadContext
        });
        if (responses.isRedirectResponse(response)) {
          let headers2 = new Headers(response.headers);
          return headers2.set("X-Remix-Redirect", headers2.get("Location")), headers2.set("X-Remix-Status", response.status), headers2.delete("Location"), response.headers.get("Set-Cookie") !== null && headers2.set("X-Remix-Revalidate", "yes"), new Response(null, {
            status: 204,
            headers: headers2
          });
        }
        if (router.UNSAFE_DEFERRED_SYMBOL in response) {
          let deferredData = response[router.UNSAFE_DEFERRED_SYMBOL], body = responses.createDeferredReadableStream(deferredData, request.signal, serverMode), init = deferredData.init || {}, headers2 = new Headers(init.headers);
          return headers2.set("Content-Type", "text/remix-deferred"), init.headers = headers2, new Response(body, init);
        }
        return response;
      } catch (error) {
        if (responses.isResponse(error))
          return error.headers.set("X-Remix-Catch", "yes"), error;
        let status = router.isRouteErrorResponse(error) ? error.status : 500, errorInstance = router.isRouteErrorResponse(error) && error.error ? error.error : error instanceof Error ? error : new Error("Unexpected Server Error");
        return logServerErrorIfNotAborted(errorInstance, request, serverMode), responses.json(errors.serializeError(errorInstance, serverMode), {
          status,
          headers: {
            "X-Remix-Error": "yes"
          }
        });
      }
    }
    function findParentBoundary(routes3, routeId, error) {
      let route = routes3[routeId] || routes3.root, isCatch = router.isRouteErrorResponse(error) && (!error.error || error.status === 404);
      return isCatch && route.module.CatchBoundary || !isCatch && route.module.ErrorBoundary || !route.parentId ? route.id : findParentBoundary(routes3, route.parentId, error);
    }
    function differentiateCatchVersusErrorBoundaries(build, context) {
      if (!context.errors)
        return;
      let errors2 = {};
      for (let routeId of Object.keys(context.errors)) {
        let error = context.errors[routeId], handlingRouteId = findParentBoundary(build.routes, routeId, error);
        errors2[handlingRouteId] = error;
      }
      context.errors = errors2;
    }
    async function handleDocumentRequestRR(serverMode, build, staticHandler, request, loadContext) {
      let context;
      try {
        context = await staticHandler.query(request, {
          requestContext: loadContext
        });
      } catch (error) {
        return logServerErrorIfNotAborted(error, request, serverMode), new Response(null, {
          status: 500
        });
      }
      if (responses.isResponse(context))
        return context;
      context.errors && (context.errors = errors.sanitizeErrors(context.errors, serverMode)), build.future.v2_errorBoundary !== !0 && differentiateCatchVersusErrorBoundaries(build, context);
      let headers$1 = headers.getDocumentHeadersRR(build, context), entryContext = {
        manifest: build.assets,
        routeModules: entry2.createEntryRouteModules(build.routes),
        staticHandlerContext: context,
        serverHandoffString: serverHandoff.createServerHandoffString({
          state: {
            loaderData: context.loaderData,
            actionData: context.actionData,
            errors: errors.serializeErrors(context.errors, serverMode)
          },
          future: build.future,
          dev: build.dev
        }),
        future: build.future
      }, handleDocumentRequestFunction = build.entry.module.default;
      try {
        return await handleDocumentRequestFunction(request, context.statusCode, headers$1, entryContext, loadContext);
      } catch (error) {
        context = router.getStaticContextFromError(staticHandler.dataRoutes, context, error), context.errors && (context.errors = errors.sanitizeErrors(context.errors, serverMode)), build.future.v2_errorBoundary !== !0 && differentiateCatchVersusErrorBoundaries(build, context), entryContext = {
          ...entryContext,
          staticHandlerContext: context,
          serverHandoffString: serverHandoff.createServerHandoffString({
            state: {
              loaderData: context.loaderData,
              actionData: context.actionData,
              errors: errors.serializeErrors(context.errors, serverMode)
            },
            future: build.future
          })
        };
        try {
          return await handleDocumentRequestFunction(request, context.statusCode, headers$1, entryContext, loadContext);
        } catch (error2) {
          return logServerErrorIfNotAborted(error2, request, serverMode), returnLastResortErrorResponse(error2, serverMode);
        }
      }
    }
    async function handleResourceRequestRR(serverMode, staticHandler, routeId, request, loadContext) {
      try {
        let response = await staticHandler.queryRoute(request, {
          routeId,
          requestContext: loadContext
        });
        return invariant.default(responses.isResponse(response), "Expected a Response to be returned from queryRoute"), response;
      } catch (error) {
        return responses.isResponse(error) ? (error.headers.set("X-Remix-Catch", "yes"), error) : (logServerErrorIfNotAborted(error, request, serverMode), returnLastResortErrorResponse(error, serverMode));
      }
    }
    function logServerErrorIfNotAborted(error, request, serverMode) {
      serverMode !== mode.ServerMode.Test && !request.signal.aborted && console.error(error);
    }
    function returnLastResortErrorResponse(error, serverMode) {
      let message = "Unexpected Server Error";
      return serverMode !== mode.ServerMode.Production && (message += `

${String(error)}`), new Response(message, {
        status: 500,
        headers: {
          "Content-Type": "text/plain"
        }
      });
    }
    exports.createRequestHandler = createRequestHandler;
    exports.differentiateCatchVersusErrorBoundaries = differentiateCatchVersusErrorBoundaries;
  }
});

// node_modules/@remix-run/server-runtime/dist/sessions.js
var require_sessions = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/sessions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var cookies = require_cookies(), warnings = require_warnings();
    function flash(name) {
      return `__flash_${name}__`;
    }
    var createSession = (initialData = {}, id = "") => {
      let map = new Map(Object.entries(initialData));
      return {
        get id() {
          return id;
        },
        get data() {
          return Object.fromEntries(map);
        },
        has(name) {
          return map.has(name) || map.has(flash(name));
        },
        get(name) {
          if (map.has(name))
            return map.get(name);
          let flashName = flash(name);
          if (map.has(flashName)) {
            let value = map.get(flashName);
            return map.delete(flashName), value;
          }
        },
        set(name, value) {
          map.set(name, value);
        },
        flash(name, value) {
          map.set(flash(name), value);
        },
        unset(name) {
          map.delete(name);
        }
      };
    }, isSession = (object) => object != null && typeof object.id == "string" && typeof object.data < "u" && typeof object.has == "function" && typeof object.get == "function" && typeof object.set == "function" && typeof object.flash == "function" && typeof object.unset == "function", createSessionStorageFactory = (createCookie) => ({
      cookie: cookieArg,
      createData,
      readData,
      updateData,
      deleteData
    }) => {
      let cookie = cookies.isCookie(cookieArg) ? cookieArg : createCookie((cookieArg == null ? void 0 : cookieArg.name) || "__session", cookieArg);
      return warnOnceAboutSigningSessionCookie(cookie), {
        async getSession(cookieHeader, options) {
          let id = cookieHeader && await cookie.parse(cookieHeader, options), data = id && await readData(id);
          return createSession(data || {}, id || "");
        },
        async commitSession(session, options) {
          let {
            id,
            data
          } = session;
          return id ? await updateData(id, data, cookie.expires) : id = await createData(data, cookie.expires), cookie.serialize(id, options);
        },
        async destroySession(session, options) {
          return await deleteData(session.id), cookie.serialize("", {
            ...options,
            expires: /* @__PURE__ */ new Date(0)
          });
        }
      };
    };
    function warnOnceAboutSigningSessionCookie(cookie) {
      warnings.warnOnce(cookie.isSigned, `The "${cookie.name}" cookie is not signed, but session cookies should be signed to prevent tampering on the client before they are sent back to the server. See https://remix.run/utils/cookies#signing-cookies for more information.`);
    }
    exports.createSession = createSession;
    exports.createSessionStorageFactory = createSessionStorageFactory;
    exports.isSession = isSession;
    exports.warnOnceAboutSigningSessionCookie = warnOnceAboutSigningSessionCookie;
  }
});

// node_modules/@remix-run/server-runtime/dist/sessions/cookieStorage.js
var require_cookieStorage = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/sessions/cookieStorage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var cookies = require_cookies(), sessions = require_sessions(), createCookieSessionStorageFactory = (createCookie) => ({
      cookie: cookieArg
    } = {}) => {
      let cookie = cookies.isCookie(cookieArg) ? cookieArg : createCookie((cookieArg == null ? void 0 : cookieArg.name) || "__session", cookieArg);
      return sessions.warnOnceAboutSigningSessionCookie(cookie), {
        async getSession(cookieHeader, options) {
          return sessions.createSession(cookieHeader && await cookie.parse(cookieHeader, options) || {});
        },
        async commitSession(session, options) {
          let serializedCookie = await cookie.serialize(session.data, options);
          if (serializedCookie.length > 4096)
            throw new Error("Cookie length will exceed browser maximum. Length: " + serializedCookie.length);
          return serializedCookie;
        },
        async destroySession(_session, options) {
          return cookie.serialize("", {
            ...options,
            expires: /* @__PURE__ */ new Date(0)
          });
        }
      };
    };
    exports.createCookieSessionStorageFactory = createCookieSessionStorageFactory;
  }
});

// node_modules/@remix-run/server-runtime/dist/sessions/memoryStorage.js
var require_memoryStorage = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/sessions/memoryStorage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var createMemorySessionStorageFactory = (createSessionStorage) => ({
      cookie
    } = {}) => {
      let uniqueId = 0, map = /* @__PURE__ */ new Map();
      return createSessionStorage({
        cookie,
        async createData(data, expires) {
          let id = (++uniqueId).toString();
          return map.set(id, {
            data,
            expires
          }), id;
        },
        async readData(id) {
          if (map.has(id)) {
            let {
              data,
              expires
            } = map.get(id);
            if (!expires || expires > /* @__PURE__ */ new Date())
              return data;
            expires && map.delete(id);
          }
          return null;
        },
        async updateData(id, data, expires) {
          map.set(id, {
            data,
            expires
          });
        },
        async deleteData(id) {
          map.delete(id);
        }
      });
    };
    exports.createMemorySessionStorageFactory = createMemorySessionStorageFactory;
  }
});

// node_modules/@remix-run/server-runtime/dist/upload/errors.js
var require_errors2 = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/upload/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var MaxPartSizeExceededError = class extends Error {
      constructor(field, maxBytes) {
        super(`Field "${field}" exceeded upload size of ${maxBytes} bytes.`), this.field = field, this.maxBytes = maxBytes;
      }
    };
    exports.MaxPartSizeExceededError = MaxPartSizeExceededError;
  }
});

// node_modules/@remix-run/server-runtime/dist/upload/memoryUploadHandler.js
var require_memoryUploadHandler = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/upload/memoryUploadHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var errors = require_errors2();
    function createMemoryUploadHandler({
      filter: filter2,
      maxPartSize = 3e6
    } = {}) {
      return async ({
        filename,
        contentType,
        name,
        data
      }) => {
        if (filter2 && !await filter2({
          filename,
          contentType,
          name
        }))
          return;
        let size = 0, chunks = [];
        for await (let chunk of data) {
          if (size += chunk.byteLength, size > maxPartSize)
            throw new errors.MaxPartSizeExceededError(name, maxPartSize);
          chunks.push(chunk);
        }
        return typeof filename == "string" ? new File(chunks, filename, {
          type: contentType
        }) : await new Blob(chunks, {
          type: contentType
        }).text();
      };
    }
    exports.createMemoryUploadHandler = createMemoryUploadHandler;
  }
});

// node_modules/@remix-run/server-runtime/dist/dev.js
var require_dev = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/dev.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    function broadcastDevReady(build, origin) {
      if (origin ?? (origin = ""), !origin)
        throw Error("Dev server origin not set");
      fetch(`${origin}/ping`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          buildHash: build.assets.version
        })
      }).catch((error) => {
        console.error(`Could not reach Remix dev server at ${origin}`);
      });
    }
    function logDevReady(build) {
      console.log(`[REMIX DEV] ${build.assets.version} ready`);
    }
    exports.broadcastDevReady = broadcastDevReady;
    exports.logDevReady = logDevReady;
  }
});

// node_modules/@remix-run/server-runtime/dist/index.js
var require_dist = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var cookies = require_cookies(), formData = require_formData(), responses = require_responses(), server = require_server(), sessions = require_sessions(), cookieStorage = require_cookieStorage(), memoryStorage = require_memoryStorage(), memoryUploadHandler = require_memoryUploadHandler(), errors = require_errors2(), dev = require_dev();
    exports.createCookieFactory = cookies.createCookieFactory;
    exports.isCookie = cookies.isCookie;
    exports.unstable_composeUploadHandlers = formData.composeUploadHandlers;
    exports.unstable_parseMultipartFormData = formData.parseMultipartFormData;
    exports.defer = responses.defer;
    exports.json = responses.json;
    exports.redirect = responses.redirect;
    exports.createRequestHandler = server.createRequestHandler;
    exports.createSession = sessions.createSession;
    exports.createSessionStorageFactory = sessions.createSessionStorageFactory;
    exports.isSession = sessions.isSession;
    exports.createCookieSessionStorageFactory = cookieStorage.createCookieSessionStorageFactory;
    exports.createMemorySessionStorageFactory = memoryStorage.createMemorySessionStorageFactory;
    exports.unstable_createMemoryUploadHandler = memoryUploadHandler.createMemoryUploadHandler;
    exports.MaxPartSizeExceededError = errors.MaxPartSizeExceededError;
    exports.broadcastDevReady = dev.broadcastDevReady;
    exports.logDevReady = dev.logDevReady;
  }
});

// node_modules/cookie-signature/index.js
var require_cookie_signature = __commonJS({
  "node_modules/cookie-signature/index.js"(exports) {
    var crypto = require("crypto");
    exports.sign = function(val, secret) {
      if (typeof val != "string")
        throw new TypeError("Cookie value must be provided as a string.");
      if (secret == null)
        throw new TypeError("Secret key must be provided.");
      return val + "." + crypto.createHmac("sha256", secret).update(val).digest("base64").replace(/\=+$/, "");
    };
    exports.unsign = function(input, secret) {
      if (typeof input != "string")
        throw new TypeError("Signed cookie string must be provided.");
      if (secret == null)
        throw new TypeError("Secret key must be provided.");
      var tentativeValue = input.slice(0, input.lastIndexOf(".")), expectedInput = exports.sign(tentativeValue, secret), expectedBuffer = Buffer.from(expectedInput), inputBuffer = Buffer.from(input);
      return expectedBuffer.length === inputBuffer.length && crypto.timingSafeEqual(expectedBuffer, inputBuffer) ? tentativeValue : !1;
    };
  }
});

// node_modules/@remix-run/node/dist/crypto.js
var require_crypto = __commonJS({
  "node_modules/@remix-run/node/dist/crypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var cookieSignature = require_cookie_signature();
    function _interopDefaultLegacy(e) {
      return e && typeof e == "object" && "default" in e ? e : { default: e };
    }
    var cookieSignature__default = /* @__PURE__ */ _interopDefaultLegacy(cookieSignature), sign = async (value, secret) => cookieSignature__default.default.sign(value, secret), unsign = async (signed, secret) => cookieSignature__default.default.unsign(signed, secret);
    exports.sign = sign;
    exports.unsign = unsign;
  }
});

// node_modules/@remix-run/node/dist/implementations.js
var require_implementations = __commonJS({
  "node_modules/@remix-run/node/dist/implementations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var serverRuntime = require_dist(), crypto = require_crypto(), createCookie = serverRuntime.createCookieFactory({
      sign: crypto.sign,
      unsign: crypto.unsign
    }), createCookieSessionStorage = serverRuntime.createCookieSessionStorageFactory(createCookie), createSessionStorage = serverRuntime.createSessionStorageFactory(createCookie), createMemorySessionStorage = serverRuntime.createMemorySessionStorageFactory(createSessionStorage);
    exports.createCookie = createCookie;
    exports.createCookieSessionStorage = createCookieSessionStorage;
    exports.createMemorySessionStorage = createMemorySessionStorage;
    exports.createSessionStorage = createSessionStorage;
  }
});

// node_modules/@remix-run/node/dist/sessions/fileStorage.js
var require_fileStorage = __commonJS({
  "node_modules/@remix-run/node/dist/sessions/fileStorage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var crypto = require("crypto"), fs = require("fs"), path = require("path"), implementations = require_implementations();
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      return e && Object.keys(e).forEach(function(k) {
        if (k !== "default") {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: !0,
            get: function() {
              return e[k];
            }
          });
        }
      }), n.default = e, Object.freeze(n);
    }
    var crypto__namespace = /* @__PURE__ */ _interopNamespace(crypto), path__namespace = /* @__PURE__ */ _interopNamespace(path);
    function createFileSessionStorage({
      cookie,
      dir
    }) {
      return implementations.createSessionStorage({
        cookie,
        async createData(data, expires) {
          let content = JSON.stringify({
            data,
            expires
          });
          for (; ; ) {
            let randomBytes = crypto__namespace.randomBytes(8), id = Buffer.from(randomBytes).toString("hex");
            try {
              let file = getFile(dir, id);
              return await fs.promises.mkdir(path__namespace.dirname(file), {
                recursive: !0
              }), await fs.promises.writeFile(file, content, {
                encoding: "utf-8",
                flag: "wx"
              }), id;
            } catch (error) {
              if (error.code !== "EEXIST")
                throw error;
            }
          }
        },
        async readData(id) {
          try {
            let file = getFile(dir, id), content = JSON.parse(await fs.promises.readFile(file, "utf-8")), data = content.data, expires = typeof content.expires == "string" ? new Date(content.expires) : null;
            return !expires || expires > /* @__PURE__ */ new Date() ? data : (expires && await fs.promises.unlink(file), null);
          } catch (error) {
            if (error.code !== "ENOENT")
              throw error;
            return null;
          }
        },
        async updateData(id, data, expires) {
          let content = JSON.stringify({
            data,
            expires
          }), file = getFile(dir, id);
          await fs.promises.mkdir(path__namespace.dirname(file), {
            recursive: !0
          }), await fs.promises.writeFile(file, content, "utf-8");
        },
        async deleteData(id) {
          if (id)
            try {
              await fs.promises.unlink(getFile(dir, id));
            } catch (error) {
              if (error.code !== "ENOENT")
                throw error;
            }
        }
      });
    }
    function getFile(dir, id) {
      return path__namespace.join(dir, id.slice(0, 4), id.slice(4));
    }
    exports.createFileSessionStorage = createFileSessionStorage;
  }
});

// node_modules/stream-slice/index.js
var require_stream_slice = __commonJS({
  "node_modules/stream-slice/index.js"(exports) {
    var util2 = require("util"), Transform = require("stream").Transform;
    util2.inherits(SliceStream, Transform);
    function SliceStream(start, end) {
      if (!(this instanceof SliceStream))
        return new SliceStream();
      Transform.call(this), this._start = start || 0, this._end = end || 1 / 0, this._offset = 0, this._state = 0, this._emitUp = !1, this._emitDown = !1;
    }
    SliceStream.prototype._transform = function(chunk, encoding, done) {
      if (this._offset += chunk.length, !this._emitUp && this._offset >= this._start) {
        this._emitUp = !0;
        var start = chunk.length - (this._offset - this._start);
        if (this._offset > this._end) {
          var end = chunk.length - (this._offset - this._end);
          this._emitDown = !0, this.push(chunk.slice(start, end));
        } else
          this.push(chunk.slice(start, chunk.length));
        return done();
      }
      return this._emitUp && !this._emitDown && (this._offset >= this._end ? (this._emitDown = !0, this.push(chunk.slice(0, chunk.length - (this._offset - this._end)))) : this.push(chunk)), done();
    };
    exports.slice = function(start, end) {
      return new SliceStream(start, end);
    };
  }
});

// node_modules/@remix-run/node/dist/stream.js
var require_stream2 = __commonJS({
  "node_modules/@remix-run/node/dist/stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var stream4 = require("stream");
    async function writeReadableStreamToWritable(stream5, writable) {
      let reader = stream5.getReader();
      async function read() {
        let {
          done,
          value
        } = await reader.read();
        if (done) {
          writable.end();
          return;
        }
        writable.write(value);
        let flushable = writable;
        typeof flushable.flush == "function" && flushable.flush(), await read();
      }
      try {
        await read();
      } catch (error) {
        throw writable.destroy(error), error;
      }
    }
    async function writeAsyncIterableToWritable(iterable, writable) {
      try {
        for await (let chunk of iterable)
          writable.write(chunk);
        writable.end();
      } catch (error) {
        throw writable.destroy(error), error;
      }
    }
    async function readableStreamToString(stream5, encoding) {
      let reader = stream5.getReader(), chunks = [];
      async function read() {
        let {
          done,
          value
        } = await reader.read();
        done || (value && chunks.push(value), await read());
      }
      return await read(), Buffer.concat(chunks).toString(encoding);
    }
    var createReadableStreamFromReadable = (source) => {
      let pump = new StreamPump(source);
      return new ReadableStream(pump, pump);
    }, StreamPump = class {
      constructor(stream$1) {
        this.highWaterMark = stream$1.readableHighWaterMark || new stream4.Stream.Readable().readableHighWaterMark, this.accumalatedSize = 0, this.stream = stream$1, this.enqueue = this.enqueue.bind(this), this.error = this.error.bind(this), this.close = this.close.bind(this);
      }
      size(chunk) {
        return (chunk == null ? void 0 : chunk.byteLength) || 0;
      }
      start(controller) {
        this.controller = controller, this.stream.on("data", this.enqueue), this.stream.once("error", this.error), this.stream.once("end", this.close), this.stream.once("close", this.close);
      }
      pull() {
        this.resume();
      }
      cancel(reason) {
        this.stream.destroy && this.stream.destroy(reason), this.stream.off("data", this.enqueue), this.stream.off("error", this.error), this.stream.off("end", this.close), this.stream.off("close", this.close);
      }
      enqueue(chunk) {
        if (this.controller)
          try {
            let bytes = chunk instanceof Uint8Array ? chunk : Buffer.from(chunk), available = (this.controller.desiredSize || 0) - bytes.byteLength;
            this.controller.enqueue(bytes), available <= 0 && this.pause();
          } catch {
            this.controller.error(new Error("Could not create Buffer, chunk must be of type string or an instance of Buffer, ArrayBuffer, or Array or an Array-like Object")), this.cancel();
          }
      }
      pause() {
        this.stream.pause && this.stream.pause();
      }
      resume() {
        this.stream.readable && this.stream.resume && this.stream.resume();
      }
      close() {
        this.controller && (this.controller.close(), delete this.controller);
      }
      error(error) {
        this.controller && (this.controller.error(error), delete this.controller);
      }
    };
    exports.createReadableStreamFromReadable = createReadableStreamFromReadable;
    exports.readableStreamToString = readableStreamToString;
    exports.writeAsyncIterableToWritable = writeAsyncIterableToWritable;
    exports.writeReadableStreamToWritable = writeReadableStreamToWritable;
  }
});

// node_modules/@remix-run/node/dist/upload/fileUploadHandler.js
var require_fileUploadHandler = __commonJS({
  "node_modules/@remix-run/node/dist/upload/fileUploadHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var crypto = require("crypto"), fs = require("fs"), promises = require("fs/promises"), os = require("os"), path = require("path"), stream4 = require("stream"), util2 = require("util"), serverRuntime = require_dist(), streamSlice = require_stream_slice(), stream$1 = require_stream2();
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      return e && Object.keys(e).forEach(function(k) {
        if (k !== "default") {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: !0,
            get: function() {
              return e[k];
            }
          });
        }
      }), n.default = e, Object.freeze(n);
    }
    var streamSlice__namespace = /* @__PURE__ */ _interopNamespace(streamSlice), defaultFilePathResolver = ({
      filename
    }) => {
      let ext = filename ? path.extname(filename) : "";
      return "upload_" + crypto.randomBytes(4).readUInt32LE(0) + ext;
    };
    async function uniqueFile(filepath) {
      let ext = path.extname(filepath), uniqueFilepath = filepath;
      for (let i = 1; await promises.stat(uniqueFilepath).then(() => !0).catch(() => !1); i++)
        uniqueFilepath = (ext ? filepath.slice(0, -ext.length) : filepath) + `-${(/* @__PURE__ */ new Date()).getTime()}${ext}`;
      return uniqueFilepath;
    }
    function createFileUploadHandler({
      directory = os.tmpdir(),
      avoidFileConflicts = !0,
      file = defaultFilePathResolver,
      filter: filter2,
      maxPartSize = 3e6
    } = {}) {
      return async ({
        name,
        filename,
        contentType,
        data
      }) => {
        if (!filename || filter2 && !await filter2({
          name,
          filename,
          contentType
        }))
          return;
        let dir = typeof directory == "string" ? directory : directory({
          name,
          filename,
          contentType
        });
        if (!dir)
          return;
        let filedir = path.resolve(dir), path$1 = typeof file == "string" ? file : file({
          name,
          filename,
          contentType
        });
        if (!path$1)
          return;
        let filepath = path.resolve(filedir, path$1);
        avoidFileConflicts && (filepath = await uniqueFile(filepath)), await promises.mkdir(path.dirname(filepath), {
          recursive: !0
        }).catch(() => {
        });
        let writeFileStream = fs.createWriteStream(filepath), size = 0, deleteFile = !1;
        try {
          for await (let chunk of data) {
            if (size += chunk.byteLength, size > maxPartSize)
              throw deleteFile = !0, new serverRuntime.MaxPartSizeExceededError(name, maxPartSize);
            writeFileStream.write(chunk);
          }
        } finally {
          writeFileStream.end(), await util2.promisify(stream4.finished)(writeFileStream), deleteFile && await promises.rm(filepath).catch(() => {
          });
        }
        return new NodeOnDiskFile(filepath, contentType);
      };
    }
    var NodeOnDiskFile = class {
      lastModified = 0;
      webkitRelativePath = "";
      constructor(filepath, type, slicer) {
        this.filepath = filepath, this.type = type, this.slicer = slicer, this.name = path.basename(filepath);
      }
      get size() {
        let stats = fs.statSync(this.filepath);
        if (this.slicer) {
          let slice = this.slicer.end - this.slicer.start;
          return slice < 0 ? 0 : slice > stats.size ? stats.size : slice;
        }
        return stats.size;
      }
      slice(start, end, type) {
        var _this$slicer;
        typeof start == "number" && start < 0 && (start = this.size + start), typeof end == "number" && end < 0 && (end = this.size + end);
        let startOffset = ((_this$slicer = this.slicer) === null || _this$slicer === void 0 ? void 0 : _this$slicer.start) || 0;
        return start = startOffset + (start || 0), end = startOffset + (end || this.size), new NodeOnDiskFile(this.filepath, typeof type == "string" ? type : this.type, {
          start,
          end
        });
      }
      async arrayBuffer() {
        let stream5 = fs.createReadStream(this.filepath);
        return this.slicer && (stream5 = stream5.pipe(streamSlice__namespace.slice(this.slicer.start, this.slicer.end))), new Promise((resolve, reject) => {
          let buf = [];
          stream5.on("data", (chunk) => buf.push(chunk)), stream5.on("end", () => resolve(Buffer.concat(buf))), stream5.on("error", (err) => reject(err));
        });
      }
      stream() {
        let stream5 = fs.createReadStream(this.filepath);
        return this.slicer && (stream5 = stream5.pipe(streamSlice__namespace.slice(this.slicer.start, this.slicer.end))), stream$1.createReadableStreamFromReadable(stream5);
      }
      async text() {
        return stream$1.readableStreamToString(this.stream());
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
      remove() {
        return promises.unlink(this.filepath);
      }
      getFilePath() {
        return this.filepath;
      }
    };
    exports.NodeOnDiskFile = NodeOnDiskFile;
    exports.createFileUploadHandler = createFileUploadHandler;
  }
});

// node_modules/@remix-run/node/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/@remix-run/node/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var sourceMapSupport = require_source_map_support(), abortController = require_abort_controller(), fetch2 = require_fetch(), globals = require_globals(), fileStorage = require_fileStorage(), fileUploadHandler = require_fileUploadHandler(), implementations = require_implementations(), stream4 = require_stream2(), serverRuntime = require_dist(), webFetch = require_lib_node3();
    function _interopDefaultLegacy(e) {
      return e && typeof e == "object" && "default" in e ? e : { default: e };
    }
    var sourceMapSupport__default = /* @__PURE__ */ _interopDefaultLegacy(sourceMapSupport);
    sourceMapSupport__default.default.install();
    Object.defineProperty(exports, "AbortController", {
      enumerable: !0,
      get: function() {
        return abortController.AbortController;
      }
    });
    exports.Request = fetch2.Request;
    exports.Response = fetch2.Response;
    exports.fetch = fetch2.fetch;
    exports.installGlobals = globals.installGlobals;
    exports.createFileSessionStorage = fileStorage.createFileSessionStorage;
    exports.NodeOnDiskFile = fileUploadHandler.NodeOnDiskFile;
    exports.unstable_createFileUploadHandler = fileUploadHandler.createFileUploadHandler;
    exports.createCookie = implementations.createCookie;
    exports.createCookieSessionStorage = implementations.createCookieSessionStorage;
    exports.createMemorySessionStorage = implementations.createMemorySessionStorage;
    exports.createSessionStorage = implementations.createSessionStorage;
    exports.createReadableStreamFromReadable = stream4.createReadableStreamFromReadable;
    exports.readableStreamToString = stream4.readableStreamToString;
    exports.writeAsyncIterableToWritable = stream4.writeAsyncIterableToWritable;
    exports.writeReadableStreamToWritable = stream4.writeReadableStreamToWritable;
    Object.defineProperty(exports, "MaxPartSizeExceededError", {
      enumerable: !0,
      get: function() {
        return serverRuntime.MaxPartSizeExceededError;
      }
    });
    Object.defineProperty(exports, "broadcastDevReady", {
      enumerable: !0,
      get: function() {
        return serverRuntime.broadcastDevReady;
      }
    });
    Object.defineProperty(exports, "createRequestHandler", {
      enumerable: !0,
      get: function() {
        return serverRuntime.createRequestHandler;
      }
    });
    Object.defineProperty(exports, "createSession", {
      enumerable: !0,
      get: function() {
        return serverRuntime.createSession;
      }
    });
    Object.defineProperty(exports, "defer", {
      enumerable: !0,
      get: function() {
        return serverRuntime.defer;
      }
    });
    Object.defineProperty(exports, "isCookie", {
      enumerable: !0,
      get: function() {
        return serverRuntime.isCookie;
      }
    });
    Object.defineProperty(exports, "isSession", {
      enumerable: !0,
      get: function() {
        return serverRuntime.isSession;
      }
    });
    Object.defineProperty(exports, "json", {
      enumerable: !0,
      get: function() {
        return serverRuntime.json;
      }
    });
    Object.defineProperty(exports, "logDevReady", {
      enumerable: !0,
      get: function() {
        return serverRuntime.logDevReady;
      }
    });
    Object.defineProperty(exports, "redirect", {
      enumerable: !0,
      get: function() {
        return serverRuntime.redirect;
      }
    });
    Object.defineProperty(exports, "unstable_composeUploadHandlers", {
      enumerable: !0,
      get: function() {
        return serverRuntime.unstable_composeUploadHandlers;
      }
    });
    Object.defineProperty(exports, "unstable_createMemoryUploadHandler", {
      enumerable: !0,
      get: function() {
        return serverRuntime.unstable_createMemoryUploadHandler;
      }
    });
    Object.defineProperty(exports, "unstable_parseMultipartFormData", {
      enumerable: !0,
      get: function() {
        return serverRuntime.unstable_parseMultipartFormData;
      }
    });
    Object.defineProperty(exports, "FormData", {
      enumerable: !0,
      get: function() {
        return webFetch.FormData;
      }
    });
    Object.defineProperty(exports, "Headers", {
      enumerable: !0,
      get: function() {
        return webFetch.Headers;
      }
    });
  }
});

// node_modules/react/cjs/react.production.min.js
var require_react_production_min = __commonJS({
  "node_modules/react/cjs/react.production.min.js"(exports) {
    "use strict";
    var l = Symbol.for("react.element"), n = Symbol.for("react.portal"), p = Symbol.for("react.fragment"), q = Symbol.for("react.strict_mode"), r = Symbol.for("react.profiler"), t = Symbol.for("react.provider"), u = Symbol.for("react.context"), v = Symbol.for("react.forward_ref"), w = Symbol.for("react.suspense"), x = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), z = Symbol.iterator;
    function A(a) {
      return a === null || typeof a != "object" ? null : (a = z && a[z] || a["@@iterator"], typeof a == "function" ? a : null);
    }
    var B = { isMounted: function() {
      return !1;
    }, enqueueForceUpdate: function() {
    }, enqueueReplaceState: function() {
    }, enqueueSetState: function() {
    } }, C = Object.assign, D = {};
    function E(a, b, e) {
      this.props = a, this.context = b, this.refs = D, this.updater = e || B;
    }
    E.prototype.isReactComponent = {};
    E.prototype.setState = function(a, b) {
      if (typeof a != "object" && typeof a != "function" && a != null)
        throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
      this.updater.enqueueSetState(this, a, b, "setState");
    };
    E.prototype.forceUpdate = function(a) {
      this.updater.enqueueForceUpdate(this, a, "forceUpdate");
    };
    function F() {
    }
    F.prototype = E.prototype;
    function G(a, b, e) {
      this.props = a, this.context = b, this.refs = D, this.updater = e || B;
    }
    var H = G.prototype = new F();
    H.constructor = G;
    C(H, E.prototype);
    H.isPureReactComponent = !0;
    var I = Array.isArray, J = Object.prototype.hasOwnProperty, K = { current: null }, L = { key: !0, ref: !0, __self: !0, __source: !0 };
    function M(a, b, e) {
      var d, c = {}, k = null, h = null;
      if (b != null)
        for (d in b.ref !== void 0 && (h = b.ref), b.key !== void 0 && (k = "" + b.key), b)
          J.call(b, d) && !L.hasOwnProperty(d) && (c[d] = b[d]);
      var g = arguments.length - 2;
      if (g === 1)
        c.children = e;
      else if (1 < g) {
        for (var f = Array(g), m = 0; m < g; m++)
          f[m] = arguments[m + 2];
        c.children = f;
      }
      if (a && a.defaultProps)
        for (d in g = a.defaultProps, g)
          c[d] === void 0 && (c[d] = g[d]);
      return { $$typeof: l, type: a, key: k, ref: h, props: c, _owner: K.current };
    }
    function N(a, b) {
      return { $$typeof: l, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
    }
    function O(a) {
      return typeof a == "object" && a !== null && a.$$typeof === l;
    }
    function escape2(a) {
      var b = { "=": "=0", ":": "=2" };
      return "$" + a.replace(/[=:]/g, function(a2) {
        return b[a2];
      });
    }
    var P = /\/+/g;
    function Q(a, b) {
      return typeof a == "object" && a !== null && a.key != null ? escape2("" + a.key) : b.toString(36);
    }
    function R(a, b, e, d, c) {
      var k = typeof a;
      (k === "undefined" || k === "boolean") && (a = null);
      var h = !1;
      if (a === null)
        h = !0;
      else
        switch (k) {
          case "string":
          case "number":
            h = !0;
            break;
          case "object":
            switch (a.$$typeof) {
              case l:
              case n:
                h = !0;
            }
        }
      if (h)
        return h = a, c = c(h), a = d === "" ? "." + Q(h, 0) : d, I(c) ? (e = "", a != null && (e = a.replace(P, "$&/") + "/"), R(c, b, e, "", function(a2) {
          return a2;
        })) : c != null && (O(c) && (c = N(c, e + (!c.key || h && h.key === c.key ? "" : ("" + c.key).replace(P, "$&/") + "/") + a)), b.push(c)), 1;
      if (h = 0, d = d === "" ? "." : d + ":", I(a))
        for (var g = 0; g < a.length; g++) {
          k = a[g];
          var f = d + Q(k, g);
          h += R(k, b, e, f, c);
        }
      else if (f = A(a), typeof f == "function")
        for (a = f.call(a), g = 0; !(k = a.next()).done; )
          k = k.value, f = d + Q(k, g++), h += R(k, b, e, f, c);
      else if (k === "object")
        throw b = String(a), Error("Objects are not valid as a React child (found: " + (b === "[object Object]" ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
      return h;
    }
    function S(a, b, e) {
      if (a == null)
        return a;
      var d = [], c = 0;
      return R(a, d, "", "", function(a2) {
        return b.call(e, a2, c++);
      }), d;
    }
    function T(a) {
      if (a._status === -1) {
        var b = a._result;
        b = b(), b.then(function(b2) {
          (a._status === 0 || a._status === -1) && (a._status = 1, a._result = b2);
        }, function(b2) {
          (a._status === 0 || a._status === -1) && (a._status = 2, a._result = b2);
        }), a._status === -1 && (a._status = 0, a._result = b);
      }
      if (a._status === 1)
        return a._result.default;
      throw a._result;
    }
    var U = { current: null }, V = { transition: null }, W = { ReactCurrentDispatcher: U, ReactCurrentBatchConfig: V, ReactCurrentOwner: K };
    exports.Children = { map: S, forEach: function(a, b, e) {
      S(a, function() {
        b.apply(this, arguments);
      }, e);
    }, count: function(a) {
      var b = 0;
      return S(a, function() {
        b++;
      }), b;
    }, toArray: function(a) {
      return S(a, function(a2) {
        return a2;
      }) || [];
    }, only: function(a) {
      if (!O(a))
        throw Error("React.Children.only expected to receive a single React element child.");
      return a;
    } };
    exports.Component = E;
    exports.Fragment = p;
    exports.Profiler = r;
    exports.PureComponent = G;
    exports.StrictMode = q;
    exports.Suspense = w;
    exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W;
    exports.cloneElement = function(a, b, e) {
      if (a == null)
        throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
      var d = C({}, a.props), c = a.key, k = a.ref, h = a._owner;
      if (b != null) {
        if (b.ref !== void 0 && (k = b.ref, h = K.current), b.key !== void 0 && (c = "" + b.key), a.type && a.type.defaultProps)
          var g = a.type.defaultProps;
        for (f in b)
          J.call(b, f) && !L.hasOwnProperty(f) && (d[f] = b[f] === void 0 && g !== void 0 ? g[f] : b[f]);
      }
      var f = arguments.length - 2;
      if (f === 1)
        d.children = e;
      else if (1 < f) {
        g = Array(f);
        for (var m = 0; m < f; m++)
          g[m] = arguments[m + 2];
        d.children = g;
      }
      return { $$typeof: l, type: a.type, key: c, ref: k, props: d, _owner: h };
    };
    exports.createContext = function(a) {
      return a = { $$typeof: u, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, a.Provider = { $$typeof: t, _context: a }, a.Consumer = a;
    };
    exports.createElement = M;
    exports.createFactory = function(a) {
      var b = M.bind(null, a);
      return b.type = a, b;
    };
    exports.createRef = function() {
      return { current: null };
    };
    exports.forwardRef = function(a) {
      return { $$typeof: v, render: a };
    };
    exports.isValidElement = O;
    exports.lazy = function(a) {
      return { $$typeof: y, _payload: { _status: -1, _result: a }, _init: T };
    };
    exports.memo = function(a, b) {
      return { $$typeof: x, type: a, compare: b === void 0 ? null : b };
    };
    exports.startTransition = function(a) {
      var b = V.transition;
      V.transition = {};
      try {
        a();
      } finally {
        V.transition = b;
      }
    };
    exports.unstable_act = function() {
      throw Error("act(...) is not supported in production builds of React.");
    };
    exports.useCallback = function(a, b) {
      return U.current.useCallback(a, b);
    };
    exports.useContext = function(a) {
      return U.current.useContext(a);
    };
    exports.useDebugValue = function() {
    };
    exports.useDeferredValue = function(a) {
      return U.current.useDeferredValue(a);
    };
    exports.useEffect = function(a, b) {
      return U.current.useEffect(a, b);
    };
    exports.useId = function() {
      return U.current.useId();
    };
    exports.useImperativeHandle = function(a, b, e) {
      return U.current.useImperativeHandle(a, b, e);
    };
    exports.useInsertionEffect = function(a, b) {
      return U.current.useInsertionEffect(a, b);
    };
    exports.useLayoutEffect = function(a, b) {
      return U.current.useLayoutEffect(a, b);
    };
    exports.useMemo = function(a, b) {
      return U.current.useMemo(a, b);
    };
    exports.useReducer = function(a, b, e) {
      return U.current.useReducer(a, b, e);
    };
    exports.useRef = function(a) {
      return U.current.useRef(a);
    };
    exports.useState = function(a) {
      return U.current.useState(a);
    };
    exports.useSyncExternalStore = function(a, b, e) {
      return U.current.useSyncExternalStore(a, b, e);
    };
    exports.useTransition = function() {
      return U.current.useTransition();
    };
    exports.version = "18.2.0";
  }
});

// node_modules/react/index.js
var require_react = __commonJS({
  "node_modules/react/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_react_production_min();
  }
});

// node_modules/react-router/dist/umd/react-router.production.min.js
var require_react_router_production_min = __commonJS({
  "node_modules/react-router/dist/umd/react-router.production.min.js"(exports, module2) {
    (function(e, t) {
      typeof exports == "object" && typeof module2 < "u" ? t(exports, require_react(), require_router_cjs()) : typeof define == "function" && define.amd ? define(["exports", "react", "@remix-run/router"], t) : t((e = typeof globalThis < "u" ? globalThis : e || self).ReactRouter = {}, e.React, e.RemixRouter);
    })(exports, function(e, t, r) {
      "use strict";
      function n(e2) {
        if (e2 && e2.__esModule)
          return e2;
        var t2 = /* @__PURE__ */ Object.create(null);
        return e2 && Object.keys(e2).forEach(function(r2) {
          if (r2 !== "default") {
            var n2 = Object.getOwnPropertyDescriptor(e2, r2);
            Object.defineProperty(t2, r2, n2.get ? n2 : { enumerable: !0, get: function() {
              return e2[r2];
            } });
          }
        }), t2.default = e2, Object.freeze(t2);
      }
      var a = n(t);
      function o() {
        return o = Object.assign ? Object.assign.bind() : function(e2) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var r2 = arguments[t2];
            for (var n2 in r2)
              Object.prototype.hasOwnProperty.call(r2, n2) && (e2[n2] = r2[n2]);
          }
          return e2;
        }, o.apply(this, arguments);
      }
      let i = a.createContext(null), u = a.createContext(null), l = a.createContext(null), s = a.createContext(null), c = a.createContext(null), d = a.createContext({ outlet: null, matches: [], isDataRoute: !1 }), p = a.createContext(null);
      function m() {
        return a.useContext(c) != null;
      }
      function h() {
        return m() || r.UNSAFE_invariant(!1), a.useContext(c).location;
      }
      function f(e2) {
        a.useContext(s).static || a.useLayoutEffect(e2);
      }
      function v() {
        let { isDataRoute: e2 } = a.useContext(d);
        return e2 ? function() {
          let { router: e3 } = O(N.UseNavigateStable), t2 = j(_.UseNavigateStable), r2 = a.useRef(!1);
          return f(() => {
            r2.current = !0;
          }), a.useCallback(function(n2, a2) {
            a2 === void 0 && (a2 = {}), r2.current && (typeof n2 == "number" ? e3.navigate(n2) : e3.navigate(n2, o({ fromRouteId: t2 }, a2)));
          }, [e3, t2]);
        }() : function() {
          m() || r.UNSAFE_invariant(!1);
          let e3 = a.useContext(i), { basename: t2, navigator: n2 } = a.useContext(s), { matches: o2 } = a.useContext(d), { pathname: u2 } = h(), l2 = JSON.stringify(r.UNSAFE_getPathContributingMatches(o2).map((e4) => e4.pathnameBase)), c2 = a.useRef(!1);
          return f(() => {
            c2.current = !0;
          }), a.useCallback(function(a2, o3) {
            if (o3 === void 0 && (o3 = {}), !c2.current)
              return;
            if (typeof a2 == "number")
              return void n2.go(a2);
            let i2 = r.resolveTo(a2, JSON.parse(l2), u2, o3.relative === "path");
            e3 == null && t2 !== "/" && (i2.pathname = i2.pathname === "/" ? t2 : r.joinPaths([t2, i2.pathname])), (o3.replace ? n2.replace : n2.push)(i2, o3.state, o3);
          }, [t2, n2, l2, u2, e3]);
        }();
      }
      let g = a.createContext(null);
      function E(e2) {
        let t2 = a.useContext(d).outlet;
        return t2 && a.createElement(g.Provider, { value: e2 }, t2);
      }
      function y(e2, t2) {
        let { relative: n2 } = t2 === void 0 ? {} : t2, { matches: o2 } = a.useContext(d), { pathname: i2 } = h(), u2 = JSON.stringify(r.UNSAFE_getPathContributingMatches(o2).map((e3) => e3.pathnameBase));
        return a.useMemo(() => r.resolveTo(e2, JSON.parse(u2), i2, n2 === "path"), [e2, u2, i2, n2]);
      }
      function b(e2, t2) {
        return R(e2, t2);
      }
      function R(e2, t2, n2) {
        m() || r.UNSAFE_invariant(!1);
        let { navigator: i2 } = a.useContext(s), { matches: u2 } = a.useContext(d), l2 = u2[u2.length - 1], p2 = l2 ? l2.params : {};
        !l2 || l2.pathname;
        let f2 = l2 ? l2.pathnameBase : "/";
        l2 && l2.route;
        let v2, g2 = h();
        if (t2) {
          var E2;
          let e3 = typeof t2 == "string" ? r.parsePath(t2) : t2;
          f2 === "/" || (E2 = e3.pathname) != null && E2.startsWith(f2) || r.UNSAFE_invariant(!1), v2 = e3;
        } else
          v2 = g2;
        let y2 = v2.pathname || "/", b2 = f2 === "/" ? y2 : y2.slice(f2.length) || "/", R2 = r.matchRoutes(e2, { pathname: b2 }), C2 = S(R2 && R2.map((e3) => Object.assign({}, e3, { params: Object.assign({}, p2, e3.params), pathname: r.joinPaths([f2, i2.encodeLocation ? i2.encodeLocation(e3.pathname).pathname : e3.pathname]), pathnameBase: e3.pathnameBase === "/" ? f2 : r.joinPaths([f2, i2.encodeLocation ? i2.encodeLocation(e3.pathnameBase).pathname : e3.pathnameBase]) })), u2, n2);
        return t2 && C2 ? a.createElement(c.Provider, { value: { location: o({ pathname: "/", search: "", hash: "", state: null, key: "default" }, v2), navigationType: r.Action.Pop } }, C2) : C2;
      }
      function C() {
        let e2 = F(), t2 = r.isRouteErrorResponse(e2) ? e2.status + " " + e2.statusText : e2 instanceof Error ? e2.message : JSON.stringify(e2), n2 = e2 instanceof Error ? e2.stack : null, o2 = { padding: "0.5rem", backgroundColor: "rgba(200,200,200, 0.5)" };
        return a.createElement(a.Fragment, null, a.createElement("h2", null, "Unexpected Application Error!"), a.createElement("h3", { style: { fontStyle: "italic" } }, t2), n2 ? a.createElement("pre", { style: o2 }, n2) : null, null);
      }
      let P = a.createElement(C, null);
      class x extends a.Component {
        constructor(e2) {
          super(e2), this.state = { location: e2.location, revalidation: e2.revalidation, error: e2.error };
        }
        static getDerivedStateFromError(e2) {
          return { error: e2 };
        }
        static getDerivedStateFromProps(e2, t2) {
          return t2.location !== e2.location || t2.revalidation !== "idle" && e2.revalidation === "idle" ? { error: e2.error, location: e2.location, revalidation: e2.revalidation } : { error: e2.error || t2.error, location: t2.location, revalidation: e2.revalidation || t2.revalidation };
        }
        componentDidCatch(e2, t2) {
          console.error("React Router caught the following error during render", e2, t2);
        }
        render() {
          return this.state.error ? a.createElement(d.Provider, { value: this.props.routeContext }, a.createElement(p.Provider, { value: this.state.error, children: this.props.component })) : this.props.children;
        }
      }
      function U(e2) {
        let { routeContext: t2, match: r2, children: n2 } = e2, o2 = a.useContext(i);
        return o2 && o2.static && o2.staticContext && (r2.route.errorElement || r2.route.ErrorBoundary) && (o2.staticContext._deepestRenderedBoundaryId = r2.route.id), a.createElement(d.Provider, { value: t2 }, n2);
      }
      function S(e2, t2, n2) {
        var o2;
        if (t2 === void 0 && (t2 = []), n2 === void 0 && (n2 = null), e2 == null) {
          var i2;
          if ((i2 = n2) == null || !i2.errors)
            return null;
          e2 = n2.matches;
        }
        let u2 = e2, l2 = (o2 = n2) == null ? void 0 : o2.errors;
        if (l2 != null) {
          let e3 = u2.findIndex((e4) => e4.route.id && (l2 == null ? void 0 : l2[e4.route.id]));
          e3 >= 0 || r.UNSAFE_invariant(!1), u2 = u2.slice(0, Math.min(u2.length, e3 + 1));
        }
        return u2.reduceRight((e3, r2, o3) => {
          let i3 = r2.route.id ? l2 == null ? void 0 : l2[r2.route.id] : null, s2 = null;
          n2 && (s2 = r2.route.errorElement || P);
          let c2 = t2.concat(u2.slice(0, o3 + 1)), d2 = () => {
            let t3;
            return t3 = i3 ? s2 : r2.route.Component ? a.createElement(r2.route.Component, null) : r2.route.element ? r2.route.element : e3, a.createElement(U, { match: r2, routeContext: { outlet: e3, matches: c2, isDataRoute: n2 != null }, children: t3 });
          };
          return n2 && (r2.route.ErrorBoundary || r2.route.errorElement || o3 === 0) ? a.createElement(x, { location: n2.location, revalidation: n2.revalidation, component: s2, error: i3, children: d2(), routeContext: { outlet: null, matches: c2, isDataRoute: !0 } }) : d2();
        }, null);
      }
      var N, _;
      function O(e2) {
        let t2 = a.useContext(i);
        return t2 || r.UNSAFE_invariant(!1), t2;
      }
      function A(e2) {
        let t2 = a.useContext(u);
        return t2 || r.UNSAFE_invariant(!1), t2;
      }
      function j(e2) {
        let t2 = function(e3) {
          let t3 = a.useContext(d);
          return t3 || r.UNSAFE_invariant(!1), t3;
        }(), n2 = t2.matches[t2.matches.length - 1];
        return n2.route.id || r.UNSAFE_invariant(!1), n2.route.id;
      }
      function F() {
        var e2;
        let t2 = a.useContext(p), r2 = A(_.UseRouteError), n2 = j(_.UseRouteError);
        return t2 || ((e2 = r2.errors) == null ? void 0 : e2[n2]);
      }
      function D() {
        let e2 = a.useContext(l);
        return e2 == null ? void 0 : e2._data;
      }
      (function(e2) {
        e2.UseBlocker = "useBlocker", e2.UseRevalidator = "useRevalidator", e2.UseNavigateStable = "useNavigate";
      })(N || (N = {})), function(e2) {
        e2.UseBlocker = "useBlocker", e2.UseLoaderData = "useLoaderData", e2.UseActionData = "useActionData", e2.UseRouteError = "useRouteError", e2.UseNavigation = "useNavigation", e2.UseRouteLoaderData = "useRouteLoaderData", e2.UseMatches = "useMatches", e2.UseRevalidator = "useRevalidator", e2.UseNavigateStable = "useNavigate", e2.UseRouteId = "useRouteId";
      }(_ || (_ = {}));
      let B = 0;
      function k(e2) {
        let { routes: t2, state: r2 } = e2;
        return R(t2, void 0, r2);
      }
      function M(e2) {
        r.UNSAFE_invariant(!1);
      }
      function L(e2) {
        let { basename: t2 = "/", children: n2 = null, location: o2, navigationType: i2 = r.Action.Pop, navigator: u2, static: l2 = !1 } = e2;
        m() && r.UNSAFE_invariant(!1);
        let d2 = t2.replace(/^\/*/, "/"), p2 = a.useMemo(() => ({ basename: d2, navigator: u2, static: l2 }), [d2, u2, l2]);
        typeof o2 == "string" && (o2 = r.parsePath(o2));
        let { pathname: h2 = "/", search: f2 = "", hash: v2 = "", state: g2 = null, key: E2 = "default" } = o2, y2 = a.useMemo(() => {
          let e3 = r.stripBasename(h2, d2);
          return e3 == null ? null : { location: { pathname: e3, search: f2, hash: v2, state: g2, key: E2 }, navigationType: i2 };
        }, [d2, h2, f2, v2, g2, E2, i2]);
        return y2 == null ? null : a.createElement(s.Provider, { value: p2 }, a.createElement(c.Provider, { children: n2, value: y2 }));
      }
      var I;
      (function(e2) {
        e2[e2.pending = 0] = "pending", e2[e2.success = 1] = "success", e2[e2.error = 2] = "error";
      })(I || (I = {}));
      let T = new Promise(() => {
      });
      class w extends a.Component {
        constructor(e2) {
          super(e2), this.state = { error: null };
        }
        static getDerivedStateFromError(e2) {
          return { error: e2 };
        }
        componentDidCatch(e2, t2) {
          console.error("<Await> caught the following error during render", e2, t2);
        }
        render() {
          let { children: e2, errorElement: t2, resolve: n2 } = this.props, o2 = null, i2 = I.pending;
          if (n2 instanceof Promise)
            if (this.state.error) {
              i2 = I.error;
              let e3 = this.state.error;
              o2 = Promise.reject().catch(() => {
              }), Object.defineProperty(o2, "_tracked", { get: () => !0 }), Object.defineProperty(o2, "_error", { get: () => e3 });
            } else
              n2._tracked ? (o2 = n2, i2 = o2._error !== void 0 ? I.error : o2._data !== void 0 ? I.success : I.pending) : (i2 = I.pending, Object.defineProperty(n2, "_tracked", { get: () => !0 }), o2 = n2.then((e3) => Object.defineProperty(n2, "_data", { get: () => e3 }), (e3) => Object.defineProperty(n2, "_error", { get: () => e3 })));
          else
            i2 = I.success, o2 = Promise.resolve(), Object.defineProperty(o2, "_tracked", { get: () => !0 }), Object.defineProperty(o2, "_data", { get: () => n2 });
          if (i2 === I.error && o2._error instanceof r.AbortedDeferredError)
            throw T;
          if (i2 === I.error && !t2)
            throw o2._error;
          if (i2 === I.error)
            return a.createElement(l.Provider, { value: o2, children: t2 });
          if (i2 === I.success)
            return a.createElement(l.Provider, { value: o2, children: e2 });
          throw o2;
        }
      }
      function J(e2) {
        let { children: t2 } = e2, r2 = D(), n2 = typeof t2 == "function" ? t2(r2) : t2;
        return a.createElement(a.Fragment, null, n2);
      }
      function H(e2, t2) {
        t2 === void 0 && (t2 = []);
        let n2 = [];
        return a.Children.forEach(e2, (e3, o2) => {
          if (!a.isValidElement(e3))
            return;
          let i2 = [...t2, o2];
          if (e3.type === a.Fragment)
            return void n2.push.apply(n2, H(e3.props.children, i2));
          e3.type !== M && r.UNSAFE_invariant(!1), e3.props.index && e3.props.children && r.UNSAFE_invariant(!1);
          let u2 = { id: e3.props.id || i2.join("-"), caseSensitive: e3.props.caseSensitive, element: e3.props.element, Component: e3.props.Component, index: e3.props.index, path: e3.props.path, loader: e3.props.loader, action: e3.props.action, errorElement: e3.props.errorElement, ErrorBoundary: e3.props.ErrorBoundary, hasErrorBoundary: e3.props.ErrorBoundary != null || e3.props.errorElement != null, shouldRevalidate: e3.props.shouldRevalidate, handle: e3.props.handle, lazy: e3.props.lazy };
          e3.props.children && (u2.children = H(e3.props.children, i2)), n2.push(u2);
        }), n2;
      }
      function z(e2) {
        let t2 = { hasErrorBoundary: e2.ErrorBoundary != null || e2.errorElement != null };
        return e2.Component && Object.assign(t2, { element: a.createElement(e2.Component), Component: void 0 }), e2.ErrorBoundary && Object.assign(t2, { errorElement: a.createElement(e2.ErrorBoundary), ErrorBoundary: void 0 }), t2;
      }
      Object.defineProperty(e, "AbortedDeferredError", { enumerable: !0, get: function() {
        return r.AbortedDeferredError;
      } }), Object.defineProperty(e, "NavigationType", { enumerable: !0, get: function() {
        return r.Action;
      } }), Object.defineProperty(e, "createPath", { enumerable: !0, get: function() {
        return r.createPath;
      } }), Object.defineProperty(e, "defer", { enumerable: !0, get: function() {
        return r.defer;
      } }), Object.defineProperty(e, "generatePath", { enumerable: !0, get: function() {
        return r.generatePath;
      } }), Object.defineProperty(e, "isRouteErrorResponse", { enumerable: !0, get: function() {
        return r.isRouteErrorResponse;
      } }), Object.defineProperty(e, "json", { enumerable: !0, get: function() {
        return r.json;
      } }), Object.defineProperty(e, "matchPath", { enumerable: !0, get: function() {
        return r.matchPath;
      } }), Object.defineProperty(e, "matchRoutes", { enumerable: !0, get: function() {
        return r.matchRoutes;
      } }), Object.defineProperty(e, "parsePath", { enumerable: !0, get: function() {
        return r.parsePath;
      } }), Object.defineProperty(e, "redirect", { enumerable: !0, get: function() {
        return r.redirect;
      } }), Object.defineProperty(e, "resolvePath", { enumerable: !0, get: function() {
        return r.resolvePath;
      } }), e.Await = function(e2) {
        let { children: t2, errorElement: r2, resolve: n2 } = e2;
        return a.createElement(w, { resolve: n2, errorElement: r2 }, a.createElement(J, null, t2));
      }, e.MemoryRouter = function(e2) {
        let { basename: t2, children: n2, initialEntries: o2, initialIndex: i2 } = e2, u2 = a.useRef();
        u2.current == null && (u2.current = r.createMemoryHistory({ initialEntries: o2, initialIndex: i2, v5Compat: !0 }));
        let l2 = u2.current, [s2, c2] = a.useState({ action: l2.action, location: l2.location });
        return a.useLayoutEffect(() => l2.listen(c2), [l2]), a.createElement(L, { basename: t2, children: n2, location: s2.location, navigationType: s2.action, navigator: l2 });
      }, e.Navigate = function(e2) {
        let { to: t2, replace: n2, state: o2, relative: i2 } = e2;
        m() || r.UNSAFE_invariant(!1);
        let { matches: u2 } = a.useContext(d), { pathname: l2 } = h(), s2 = v(), c2 = r.resolveTo(t2, r.UNSAFE_getPathContributingMatches(u2).map((e3) => e3.pathnameBase), l2, i2 === "path"), p2 = JSON.stringify(c2);
        return a.useEffect(() => s2(JSON.parse(p2), { replace: n2, state: o2, relative: i2 }), [s2, p2, i2, n2, o2]), null;
      }, e.Outlet = function(e2) {
        return E(e2.context);
      }, e.Route = M, e.Router = L, e.RouterProvider = function(e2) {
        let { fallbackElement: t2, router: r2 } = e2, [n2, o2] = a.useState(r2.state);
        a.useLayoutEffect(() => r2.subscribe(o2), [r2, o2]);
        let l2 = a.useMemo(() => ({ createHref: r2.createHref, encodeLocation: r2.encodeLocation, go: (e3) => r2.navigate(e3), push: (e3, t3, n3) => r2.navigate(e3, { state: t3, preventScrollReset: n3 == null ? void 0 : n3.preventScrollReset }), replace: (e3, t3, n3) => r2.navigate(e3, { replace: !0, state: t3, preventScrollReset: n3 == null ? void 0 : n3.preventScrollReset }) }), [r2]), s2 = r2.basename || "/", c2 = a.useMemo(() => ({ router: r2, navigator: l2, static: !1, basename: s2 }), [r2, l2, s2]);
        return a.createElement(a.Fragment, null, a.createElement(i.Provider, { value: c2 }, a.createElement(u.Provider, { value: n2 }, a.createElement(L, { basename: r2.basename, location: r2.state.location, navigationType: r2.state.historyAction, navigator: l2 }, r2.state.initialized ? a.createElement(k, { routes: r2.routes, state: n2 }) : t2))), null);
      }, e.Routes = function(e2) {
        let { children: t2, location: r2 } = e2;
        return b(H(t2), r2);
      }, e.UNSAFE_DataRouterContext = i, e.UNSAFE_DataRouterStateContext = u, e.UNSAFE_LocationContext = c, e.UNSAFE_NavigationContext = s, e.UNSAFE_RouteContext = d, e.UNSAFE_mapRouteProperties = z, e.UNSAFE_useRouteId = function() {
        return j(_.UseRouteId);
      }, e.UNSAFE_useRoutesImpl = R, e.createMemoryRouter = function(e2, t2) {
        return r.createRouter({ basename: t2 == null ? void 0 : t2.basename, future: o({}, t2 == null ? void 0 : t2.future, { v7_prependBasename: !0 }), history: r.createMemoryHistory({ initialEntries: t2 == null ? void 0 : t2.initialEntries, initialIndex: t2 == null ? void 0 : t2.initialIndex }), hydrationData: t2 == null ? void 0 : t2.hydrationData, routes: e2, mapRouteProperties: z }).initialize();
      }, e.createRoutesFromChildren = H, e.createRoutesFromElements = H, e.renderMatches = function(e2) {
        return S(e2);
      }, e.unstable_useBlocker = function(e2) {
        let { router: t2 } = O(N.UseBlocker), r2 = A(_.UseBlocker), [n2] = a.useState(() => String(++B)), o2 = a.useCallback((t3) => typeof e2 == "function" ? !!e2(t3) : !!e2, [e2]), i2 = t2.getBlocker(n2, o2);
        return a.useEffect(() => () => t2.deleteBlocker(n2), [t2, n2]), r2.blockers.get(n2) || i2;
      }, e.useActionData = function() {
        let e2 = A(_.UseActionData);
        return a.useContext(d) || r.UNSAFE_invariant(!1), Object.values((e2 == null ? void 0 : e2.actionData) || {})[0];
      }, e.useAsyncError = function() {
        let e2 = a.useContext(l);
        return e2 == null ? void 0 : e2._error;
      }, e.useAsyncValue = D, e.useHref = function(e2, t2) {
        let { relative: n2 } = t2 === void 0 ? {} : t2;
        m() || r.UNSAFE_invariant(!1);
        let { basename: o2, navigator: i2 } = a.useContext(s), { hash: u2, pathname: l2, search: c2 } = y(e2, { relative: n2 }), d2 = l2;
        return o2 !== "/" && (d2 = l2 === "/" ? o2 : r.joinPaths([o2, l2])), i2.createHref({ pathname: d2, search: c2, hash: u2 });
      }, e.useInRouterContext = m, e.useLoaderData = function() {
        let e2 = A(_.UseLoaderData), t2 = j(_.UseLoaderData);
        if (!e2.errors || e2.errors[t2] == null)
          return e2.loaderData[t2];
        console.error("You cannot `useLoaderData` in an errorElement (routeId: " + t2 + ")");
      }, e.useLocation = h, e.useMatch = function(e2) {
        m() || r.UNSAFE_invariant(!1);
        let { pathname: t2 } = h();
        return a.useMemo(() => r.matchPath(e2, t2), [t2, e2]);
      }, e.useMatches = function() {
        let { matches: e2, loaderData: t2 } = A(_.UseMatches);
        return a.useMemo(() => e2.map((e3) => {
          let { pathname: r2, params: n2 } = e3;
          return { id: e3.route.id, pathname: r2, params: n2, data: t2[e3.route.id], handle: e3.route.handle };
        }), [e2, t2]);
      }, e.useNavigate = v, e.useNavigation = function() {
        return A(_.UseNavigation).navigation;
      }, e.useNavigationType = function() {
        return a.useContext(c).navigationType;
      }, e.useOutlet = E, e.useOutletContext = function() {
        return a.useContext(g);
      }, e.useParams = function() {
        let { matches: e2 } = a.useContext(d), t2 = e2[e2.length - 1];
        return t2 ? t2.params : {};
      }, e.useResolvedPath = y, e.useRevalidator = function() {
        let e2 = O(N.UseRevalidator), t2 = A(_.UseRevalidator);
        return { revalidate: e2.router.revalidate, state: t2.revalidation };
      }, e.useRouteError = F, e.useRouteLoaderData = function(e2) {
        return A(_.UseRouteLoaderData).loaderData[e2];
      }, e.useRoutes = b, Object.defineProperty(e, "__esModule", { value: !0 });
    });
  }
});

// node_modules/react-router/dist/main.js
var require_main = __commonJS({
  "node_modules/react-router/dist/main.js"(exports, module2) {
    "use strict";
    module2.exports = require_react_router_production_min();
  }
});

// node_modules/react-router-dom/dist/umd/react-router-dom.production.min.js
var require_react_router_dom_production_min = __commonJS({
  "node_modules/react-router-dom/dist/umd/react-router-dom.production.min.js"(exports, module2) {
    (function(e, t) {
      typeof exports == "object" && typeof module2 < "u" ? t(exports, require_react(), require_main(), require_router_cjs()) : typeof define == "function" && define.amd ? define(["exports", "react", "react-router", "@remix-run/router"], t) : t((e = typeof globalThis < "u" ? globalThis : e || self).ReactRouterDOM = {}, e.React, e.ReactRouter, e.RemixRouter);
    })(exports, function(e, t, r, n) {
      "use strict";
      function o(e2) {
        if (e2 && e2.__esModule)
          return e2;
        var t2 = /* @__PURE__ */ Object.create(null);
        return e2 && Object.keys(e2).forEach(function(r2) {
          if (r2 !== "default") {
            var n2 = Object.getOwnPropertyDescriptor(e2, r2);
            Object.defineProperty(t2, r2, n2.get ? n2 : { enumerable: !0, get: function() {
              return e2[r2];
            } });
          }
        }), t2.default = e2, Object.freeze(t2);
      }
      var a = o(t);
      function u() {
        return u = Object.assign ? Object.assign.bind() : function(e2) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var r2 = arguments[t2];
            for (var n2 in r2)
              Object.prototype.hasOwnProperty.call(r2, n2) && (e2[n2] = r2[n2]);
          }
          return e2;
        }, u.apply(this, arguments);
      }
      function i(e2, t2) {
        if (e2 == null)
          return {};
        var r2, n2, o2 = {}, a2 = Object.keys(e2);
        for (n2 = 0; n2 < a2.length; n2++)
          r2 = a2[n2], t2.indexOf(r2) >= 0 || (o2[r2] = e2[r2]);
        return o2;
      }
      let c = "get", s = "application/x-www-form-urlencoded";
      function l(e2) {
        return e2 != null && typeof e2.tagName == "string";
      }
      function f(e2) {
        return e2 === void 0 && (e2 = ""), new URLSearchParams(typeof e2 == "string" || Array.isArray(e2) || e2 instanceof URLSearchParams ? e2 : Object.keys(e2).reduce((t2, r2) => {
          let n2 = e2[r2];
          return t2.concat(Array.isArray(n2) ? n2.map((e3) => [r2, e3]) : [[r2, n2]]);
        }, []));
      }
      function d(e2, t2, r2) {
        let o2, a2, u2, i2 = null;
        if (l(f2 = e2) && f2.tagName.toLowerCase() === "form") {
          let l2 = t2.submissionTrigger;
          if (t2.action)
            i2 = t2.action;
          else {
            let t3 = e2.getAttribute("action");
            i2 = t3 ? n.stripBasename(t3, r2) : null;
          }
          o2 = t2.method || e2.getAttribute("method") || c, a2 = t2.encType || e2.getAttribute("enctype") || s, u2 = new FormData(e2), l2 && l2.name && u2.append(l2.name, l2.value);
        } else if (function(e3) {
          return l(e3) && e3.tagName.toLowerCase() === "button";
        }(e2) || function(e3) {
          return l(e3) && e3.tagName.toLowerCase() === "input";
        }(e2) && (e2.type === "submit" || e2.type === "image")) {
          let l2 = e2.form;
          if (l2 == null)
            throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
          if (t2.action)
            i2 = t2.action;
          else {
            let t3 = e2.getAttribute("formaction") || l2.getAttribute("action");
            i2 = t3 ? n.stripBasename(t3, r2) : null;
          }
          o2 = t2.method || e2.getAttribute("formmethod") || l2.getAttribute("method") || c, a2 = t2.encType || e2.getAttribute("formenctype") || l2.getAttribute("enctype") || s, u2 = new FormData(l2), e2.name && u2.append(e2.name, e2.value);
        } else {
          if (l(e2))
            throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
          if (o2 = t2.method || c, i2 = t2.action || null, a2 = t2.encType || s, e2 instanceof FormData)
            u2 = e2;
          else if (u2 = new FormData(), e2 instanceof URLSearchParams)
            for (let [t3, r3] of e2)
              u2.append(t3, r3);
          else if (e2 != null)
            for (let t3 of Object.keys(e2))
              u2.append(t3, e2[t3]);
        }
        var f2;
        return { action: i2, method: o2.toLowerCase(), encType: a2, formData: u2 };
      }
      let m = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset"], p = ["aria-current", "caseSensitive", "className", "end", "style", "to", "children"], b = ["reloadDocument", "replace", "method", "action", "onSubmit", "fetcherKey", "routeId", "relative", "preventScrollReset"];
      function g() {
        var e2;
        let t2 = (e2 = window) == null ? void 0 : e2.__staticRouterHydrationData;
        return t2 && t2.errors && (t2 = u({}, t2, { errors: h(t2.errors) })), t2;
      }
      function h(e2) {
        if (!e2)
          return null;
        let t2 = Object.entries(e2), r2 = {};
        for (let [e3, o2] of t2)
          if (o2 && o2.__type === "RouteErrorResponse")
            r2[e3] = new n.ErrorResponse(o2.status, o2.statusText, o2.data, o2.internal === !0);
          else if (o2 && o2.__type === "Error") {
            let t3 = new Error(o2.message);
            t3.stack = "", r2[e3] = t3;
          } else
            r2[e3] = o2;
        return r2;
      }
      let y = typeof window < "u" && window.document !== void 0 && window.document.createElement !== void 0, v = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, R = a.forwardRef(function(e2, t2) {
        let o2, { onClick: c2, relative: s2, reloadDocument: l2, replace: f2, state: d2, target: p2, to: b2, preventScrollReset: g2 } = e2, h2 = i(e2, m), { basename: R2 } = a.useContext(r.UNSAFE_NavigationContext), w2 = !1;
        if (typeof b2 == "string" && v.test(b2) && (o2 = b2, y))
          try {
            let e3 = new URL(window.location.href), t3 = b2.startsWith("//") ? new URL(e3.protocol + b2) : new URL(b2), r2 = n.stripBasename(t3.pathname, R2);
            t3.origin === e3.origin && r2 != null ? b2 = r2 + t3.search + t3.hash : w2 = !0;
          } catch {
          }
        let P2 = r.useHref(b2, { relative: s2 }), S2 = N(b2, { replace: f2, state: d2, target: p2, preventScrollReset: g2, relative: s2 });
        return a.createElement("a", u({}, h2, { href: o2 || P2, onClick: w2 || l2 ? c2 : function(e3) {
          c2 && c2(e3), e3.defaultPrevented || S2(e3);
        }, ref: t2, target: p2 }));
      }), w = a.forwardRef(function(e2, t2) {
        let { "aria-current": n2 = "page", caseSensitive: o2 = !1, className: c2 = "", end: s2 = !1, style: l2, to: f2, children: d2 } = e2, m2 = i(e2, p), b2 = r.useResolvedPath(f2, { relative: m2.relative }), g2 = r.useLocation(), h2 = a.useContext(r.UNSAFE_DataRouterStateContext), { navigator: y2 } = a.useContext(r.UNSAFE_NavigationContext), v2 = y2.encodeLocation ? y2.encodeLocation(b2).pathname : b2.pathname, w2 = g2.pathname, P2 = h2 && h2.navigation && h2.navigation.location ? h2.navigation.location.pathname : null;
        o2 || (w2 = w2.toLowerCase(), P2 = P2 ? P2.toLowerCase() : null, v2 = v2.toLowerCase());
        let S2, E2 = w2 === v2 || !s2 && w2.startsWith(v2) && w2.charAt(v2.length) === "/", O2 = P2 != null && (P2 === v2 || !s2 && P2.startsWith(v2) && P2.charAt(v2.length) === "/"), j2 = E2 ? n2 : void 0;
        S2 = typeof c2 == "function" ? c2({ isActive: E2, isPending: O2 }) : [c2, E2 ? "active" : null, O2 ? "pending" : null].filter(Boolean).join(" ");
        let A2 = typeof l2 == "function" ? l2({ isActive: E2, isPending: O2 }) : l2;
        return a.createElement(R, u({}, m2, { "aria-current": j2, className: S2, ref: t2, style: A2, to: f2 }), typeof d2 == "function" ? d2({ isActive: E2, isPending: O2 }) : d2);
      }), P = a.forwardRef((e2, t2) => a.createElement(S, u({}, e2, { ref: t2 }))), S = a.forwardRef((e2, t2) => {
        let { reloadDocument: r2, replace: n2, method: o2 = c, action: s2, onSubmit: l2, fetcherKey: f2, routeId: d2, relative: m2, preventScrollReset: p2 } = e2, g2 = i(e2, b), h2 = F(f2, d2), y2 = o2.toLowerCase() === "get" ? "get" : "post", v2 = C(s2, { relative: m2 });
        return a.createElement("form", u({ ref: t2, method: y2, action: v2, onSubmit: r2 ? l2 : (e3) => {
          if (l2 && l2(e3), e3.defaultPrevented)
            return;
          e3.preventDefault();
          let t3 = e3.nativeEvent.submitter, r3 = (t3 == null ? void 0 : t3.getAttribute("formmethod")) || o2;
          h2(t3 || e3.currentTarget, { method: r3, replace: n2, relative: m2, preventScrollReset: p2 });
        } }, g2));
      });
      var E, O;
      function j(e2) {
        let t2 = a.useContext(r.UNSAFE_DataRouterContext);
        return t2 || n.UNSAFE_invariant(!1), t2;
      }
      function A(e2) {
        let t2 = a.useContext(r.UNSAFE_DataRouterStateContext);
        return t2 || n.UNSAFE_invariant(!1), t2;
      }
      function N(e2, t2) {
        let { target: n2, replace: o2, state: u2, preventScrollReset: i2, relative: c2 } = t2 === void 0 ? {} : t2, s2 = r.useNavigate(), l2 = r.useLocation(), f2 = r.useResolvedPath(e2, { relative: c2 });
        return a.useCallback((t3) => {
          if (function(e3, t4) {
            return !(e3.button !== 0 || t4 && t4 !== "_self" || function(e4) {
              return !!(e4.metaKey || e4.altKey || e4.ctrlKey || e4.shiftKey);
            }(e3));
          }(t3, n2)) {
            t3.preventDefault();
            let n3 = o2 !== void 0 ? o2 : r.createPath(l2) === r.createPath(f2);
            s2(e2, { replace: n3, state: u2, preventScrollReset: i2, relative: c2 });
          }
        }, [l2, s2, f2, o2, u2, n2, e2, i2, c2]);
      }
      function F(e2, t2) {
        let { router: o2 } = j(E.UseSubmitImpl), { basename: i2 } = a.useContext(r.UNSAFE_NavigationContext), c2 = r.UNSAFE_useRouteId();
        return a.useCallback(function(r2, a2) {
          if (a2 === void 0 && (a2 = {}), typeof document > "u")
            throw new Error("You are calling submit during the server render. Try calling submit within a `useEffect` or callback instead.");
          let { action: s2, method: l2, encType: f2, formData: m2 } = d(r2, a2, i2), p2 = { preventScrollReset: a2.preventScrollReset, formData: m2, formMethod: l2, formEncType: f2 };
          e2 ? (t2 == null && n.UNSAFE_invariant(!1), o2.fetch(e2, t2, s2, p2)) : o2.navigate(s2, u({}, p2, { replace: a2.replace, fromRouteId: c2 }));
        }, [o2, i2, e2, t2, c2]);
      }
      function C(e2, t2) {
        let { relative: o2 } = t2 === void 0 ? {} : t2, { basename: i2 } = a.useContext(r.UNSAFE_NavigationContext), c2 = a.useContext(r.UNSAFE_RouteContext);
        c2 || n.UNSAFE_invariant(!1);
        let [s2] = c2.matches.slice(-1), l2 = u({}, r.useResolvedPath(e2 || ".", { relative: o2 })), f2 = r.useLocation();
        if (e2 == null && (l2.search = f2.search, l2.hash = f2.hash, s2.route.index)) {
          let e3 = new URLSearchParams(l2.search);
          e3.delete("index"), l2.search = e3.toString() ? "?" + e3.toString() : "";
        }
        return e2 && e2 !== "." || !s2.route.index || (l2.search = l2.search ? l2.search.replace(/^\?/, "?index&") : "?index"), i2 !== "/" && (l2.pathname = l2.pathname === "/" ? i2 : n.joinPaths([i2, l2.pathname])), r.createPath(l2);
      }
      (function(e2) {
        e2.UseScrollRestoration = "useScrollRestoration", e2.UseSubmitImpl = "useSubmitImpl", e2.UseFetcher = "useFetcher";
      })(E || (E = {})), function(e2) {
        e2.UseFetchers = "useFetchers", e2.UseScrollRestoration = "useScrollRestoration";
      }(O || (O = {}));
      let U = 0, _ = "react-router-scroll-positions", x = {};
      function L(e2) {
        let { getKey: t2, storageKey: n2 } = e2 === void 0 ? {} : e2, { router: o2 } = j(E.UseScrollRestoration), { restoreScrollPosition: u2, preventScrollReset: i2 } = A(O.UseScrollRestoration), c2 = r.useLocation(), s2 = r.useMatches(), l2 = r.useNavigation();
        a.useEffect(() => (window.history.scrollRestoration = "manual", () => {
          window.history.scrollRestoration = "auto";
        }), []), function(e3, t3) {
          let { capture: r2 } = t3 || {};
          a.useEffect(() => {
            let t4 = r2 != null ? { capture: r2 } : void 0;
            return window.addEventListener("pagehide", e3, t4), () => {
              window.removeEventListener("pagehide", e3, t4);
            };
          }, [e3, r2]);
        }(a.useCallback(() => {
          if (l2.state === "idle") {
            let e3 = (t2 ? t2(c2, s2) : null) || c2.key;
            x[e3] = window.scrollY;
          }
          sessionStorage.setItem(n2 || _, JSON.stringify(x)), window.history.scrollRestoration = "auto";
        }, [n2, t2, l2.state, c2, s2])), typeof document < "u" && (a.useLayoutEffect(() => {
          try {
            let e3 = sessionStorage.getItem(n2 || _);
            e3 && (x = JSON.parse(e3));
          } catch {
          }
        }, [n2]), a.useLayoutEffect(() => {
          let e3 = o2 == null ? void 0 : o2.enableScrollRestoration(x, () => window.scrollY, t2);
          return () => e3 && e3();
        }, [o2, t2]), a.useLayoutEffect(() => {
          if (u2 !== !1)
            if (typeof u2 != "number") {
              if (c2.hash) {
                let e3 = document.getElementById(c2.hash.slice(1));
                if (e3)
                  return void e3.scrollIntoView();
              }
              i2 !== !0 && window.scrollTo(0, 0);
            } else
              window.scrollTo(0, u2);
        }, [c2, u2, i2]));
      }
      Object.defineProperty(e, "AbortedDeferredError", { enumerable: !0, get: function() {
        return r.AbortedDeferredError;
      } }), Object.defineProperty(e, "Await", { enumerable: !0, get: function() {
        return r.Await;
      } }), Object.defineProperty(e, "MemoryRouter", { enumerable: !0, get: function() {
        return r.MemoryRouter;
      } }), Object.defineProperty(e, "Navigate", { enumerable: !0, get: function() {
        return r.Navigate;
      } }), Object.defineProperty(e, "NavigationType", { enumerable: !0, get: function() {
        return r.NavigationType;
      } }), Object.defineProperty(e, "Outlet", { enumerable: !0, get: function() {
        return r.Outlet;
      } }), Object.defineProperty(e, "Route", { enumerable: !0, get: function() {
        return r.Route;
      } }), Object.defineProperty(e, "Router", { enumerable: !0, get: function() {
        return r.Router;
      } }), Object.defineProperty(e, "RouterProvider", { enumerable: !0, get: function() {
        return r.RouterProvider;
      } }), Object.defineProperty(e, "Routes", { enumerable: !0, get: function() {
        return r.Routes;
      } }), Object.defineProperty(e, "UNSAFE_DataRouterContext", { enumerable: !0, get: function() {
        return r.UNSAFE_DataRouterContext;
      } }), Object.defineProperty(e, "UNSAFE_DataRouterStateContext", { enumerable: !0, get: function() {
        return r.UNSAFE_DataRouterStateContext;
      } }), Object.defineProperty(e, "UNSAFE_LocationContext", { enumerable: !0, get: function() {
        return r.UNSAFE_LocationContext;
      } }), Object.defineProperty(e, "UNSAFE_NavigationContext", { enumerable: !0, get: function() {
        return r.UNSAFE_NavigationContext;
      } }), Object.defineProperty(e, "UNSAFE_RouteContext", { enumerable: !0, get: function() {
        return r.UNSAFE_RouteContext;
      } }), Object.defineProperty(e, "UNSAFE_useRouteId", { enumerable: !0, get: function() {
        return r.UNSAFE_useRouteId;
      } }), Object.defineProperty(e, "createMemoryRouter", { enumerable: !0, get: function() {
        return r.createMemoryRouter;
      } }), Object.defineProperty(e, "createPath", { enumerable: !0, get: function() {
        return r.createPath;
      } }), Object.defineProperty(e, "createRoutesFromChildren", { enumerable: !0, get: function() {
        return r.createRoutesFromChildren;
      } }), Object.defineProperty(e, "createRoutesFromElements", { enumerable: !0, get: function() {
        return r.createRoutesFromElements;
      } }), Object.defineProperty(e, "defer", { enumerable: !0, get: function() {
        return r.defer;
      } }), Object.defineProperty(e, "generatePath", { enumerable: !0, get: function() {
        return r.generatePath;
      } }), Object.defineProperty(e, "isRouteErrorResponse", { enumerable: !0, get: function() {
        return r.isRouteErrorResponse;
      } }), Object.defineProperty(e, "json", { enumerable: !0, get: function() {
        return r.json;
      } }), Object.defineProperty(e, "matchPath", { enumerable: !0, get: function() {
        return r.matchPath;
      } }), Object.defineProperty(e, "matchRoutes", { enumerable: !0, get: function() {
        return r.matchRoutes;
      } }), Object.defineProperty(e, "parsePath", { enumerable: !0, get: function() {
        return r.parsePath;
      } }), Object.defineProperty(e, "redirect", { enumerable: !0, get: function() {
        return r.redirect;
      } }), Object.defineProperty(e, "renderMatches", { enumerable: !0, get: function() {
        return r.renderMatches;
      } }), Object.defineProperty(e, "resolvePath", { enumerable: !0, get: function() {
        return r.resolvePath;
      } }), Object.defineProperty(e, "unstable_useBlocker", { enumerable: !0, get: function() {
        return r.unstable_useBlocker;
      } }), Object.defineProperty(e, "useActionData", { enumerable: !0, get: function() {
        return r.useActionData;
      } }), Object.defineProperty(e, "useAsyncError", { enumerable: !0, get: function() {
        return r.useAsyncError;
      } }), Object.defineProperty(e, "useAsyncValue", { enumerable: !0, get: function() {
        return r.useAsyncValue;
      } }), Object.defineProperty(e, "useHref", { enumerable: !0, get: function() {
        return r.useHref;
      } }), Object.defineProperty(e, "useInRouterContext", { enumerable: !0, get: function() {
        return r.useInRouterContext;
      } }), Object.defineProperty(e, "useLoaderData", { enumerable: !0, get: function() {
        return r.useLoaderData;
      } }), Object.defineProperty(e, "useLocation", { enumerable: !0, get: function() {
        return r.useLocation;
      } }), Object.defineProperty(e, "useMatch", { enumerable: !0, get: function() {
        return r.useMatch;
      } }), Object.defineProperty(e, "useMatches", { enumerable: !0, get: function() {
        return r.useMatches;
      } }), Object.defineProperty(e, "useNavigate", { enumerable: !0, get: function() {
        return r.useNavigate;
      } }), Object.defineProperty(e, "useNavigation", { enumerable: !0, get: function() {
        return r.useNavigation;
      } }), Object.defineProperty(e, "useNavigationType", { enumerable: !0, get: function() {
        return r.useNavigationType;
      } }), Object.defineProperty(e, "useOutlet", { enumerable: !0, get: function() {
        return r.useOutlet;
      } }), Object.defineProperty(e, "useOutletContext", { enumerable: !0, get: function() {
        return r.useOutletContext;
      } }), Object.defineProperty(e, "useParams", { enumerable: !0, get: function() {
        return r.useParams;
      } }), Object.defineProperty(e, "useResolvedPath", { enumerable: !0, get: function() {
        return r.useResolvedPath;
      } }), Object.defineProperty(e, "useRevalidator", { enumerable: !0, get: function() {
        return r.useRevalidator;
      } }), Object.defineProperty(e, "useRouteError", { enumerable: !0, get: function() {
        return r.useRouteError;
      } }), Object.defineProperty(e, "useRouteLoaderData", { enumerable: !0, get: function() {
        return r.useRouteLoaderData;
      } }), Object.defineProperty(e, "useRoutes", { enumerable: !0, get: function() {
        return r.useRoutes;
      } }), e.BrowserRouter = function(e2) {
        let { basename: t2, children: o2, window: u2 } = e2, i2 = a.useRef();
        i2.current == null && (i2.current = n.createBrowserHistory({ window: u2, v5Compat: !0 }));
        let c2 = i2.current, [s2, l2] = a.useState({ action: c2.action, location: c2.location });
        return a.useLayoutEffect(() => c2.listen(l2), [c2]), a.createElement(r.Router, { basename: t2, children: o2, location: s2.location, navigationType: s2.action, navigator: c2 });
      }, e.Form = P, e.HashRouter = function(e2) {
        let { basename: t2, children: o2, window: u2 } = e2, i2 = a.useRef();
        i2.current == null && (i2.current = n.createHashHistory({ window: u2, v5Compat: !0 }));
        let c2 = i2.current, [s2, l2] = a.useState({ action: c2.action, location: c2.location });
        return a.useLayoutEffect(() => c2.listen(l2), [c2]), a.createElement(r.Router, { basename: t2, children: o2, location: s2.location, navigationType: s2.action, navigator: c2 });
      }, e.Link = R, e.NavLink = w, e.ScrollRestoration = function(e2) {
        let { getKey: t2, storageKey: r2 } = e2;
        return L({ getKey: t2, storageKey: r2 }), null;
      }, e.UNSAFE_useScrollRestoration = L, e.createBrowserRouter = function(e2, t2) {
        return n.createRouter({ basename: t2 == null ? void 0 : t2.basename, future: u({}, t2 == null ? void 0 : t2.future, { v7_prependBasename: !0 }), history: n.createBrowserHistory({ window: t2 == null ? void 0 : t2.window }), hydrationData: (t2 == null ? void 0 : t2.hydrationData) || g(), routes: e2, mapRouteProperties: r.UNSAFE_mapRouteProperties }).initialize();
      }, e.createHashRouter = function(e2, t2) {
        return n.createRouter({ basename: t2 == null ? void 0 : t2.basename, future: u({}, t2 == null ? void 0 : t2.future, { v7_prependBasename: !0 }), history: n.createHashHistory({ window: t2 == null ? void 0 : t2.window }), hydrationData: (t2 == null ? void 0 : t2.hydrationData) || g(), routes: e2, mapRouteProperties: r.UNSAFE_mapRouteProperties }).initialize();
      }, e.createSearchParams = f, e.unstable_HistoryRouter = function(e2) {
        let { basename: t2, children: n2, history: o2 } = e2, [u2, i2] = a.useState({ action: o2.action, location: o2.location });
        return a.useLayoutEffect(() => o2.listen(i2), [o2]), a.createElement(r.Router, { basename: t2, children: n2, location: u2.location, navigationType: u2.action, navigator: o2 });
      }, e.unstable_usePrompt = function(e2) {
        let { when: t2, message: n2 } = e2, o2 = r.unstable_useBlocker(t2);
        a.useEffect(() => {
          o2.state !== "blocked" || t2 || o2.reset();
        }, [o2, t2]), a.useEffect(() => {
          o2.state === "blocked" && (window.confirm(n2) ? setTimeout(o2.proceed, 0) : o2.reset());
        }, [o2, n2]);
      }, e.useBeforeUnload = function(e2, t2) {
        let { capture: r2 } = t2 || {};
        a.useEffect(() => {
          let t3 = r2 != null ? { capture: r2 } : void 0;
          return window.addEventListener("beforeunload", e2, t3), () => {
            window.removeEventListener("beforeunload", e2, t3);
          };
        }, [e2, r2]);
      }, e.useFetcher = function() {
        var e2;
        let { router: t2 } = j(E.UseFetcher), o2 = a.useContext(r.UNSAFE_RouteContext);
        o2 || n.UNSAFE_invariant(!1);
        let i2 = (e2 = o2.matches[o2.matches.length - 1]) == null ? void 0 : e2.route.id;
        i2 == null && n.UNSAFE_invariant(!1);
        let [c2] = a.useState(() => String(++U)), [s2] = a.useState(() => (i2 || n.UNSAFE_invariant(!1), function(e3, t3) {
          return a.forwardRef((r2, n2) => a.createElement(S, u({}, r2, { ref: n2, fetcherKey: e3, routeId: t3 })));
        }(c2, i2))), [l2] = a.useState(() => (e3) => {
          t2 || n.UNSAFE_invariant(!1), i2 || n.UNSAFE_invariant(!1), t2.fetch(c2, i2, e3);
        }), f2 = F(c2, i2), d2 = t2.getFetcher(c2), m2 = a.useMemo(() => u({ Form: s2, submit: f2, load: l2 }, d2), [d2, s2, f2, l2]);
        return a.useEffect(() => () => {
          t2 ? t2.deleteFetcher(c2) : console.warn("No router available to clean up from useFetcher()");
        }, [t2, c2]), m2;
      }, e.useFetchers = function() {
        return [...A(O.UseFetchers).fetchers.values()];
      }, e.useFormAction = C, e.useLinkClickHandler = N, e.useSearchParams = function(e2) {
        let t2 = a.useRef(f(e2)), n2 = a.useRef(!1), o2 = r.useLocation(), u2 = a.useMemo(() => function(e3, t3) {
          let r2 = f(e3);
          if (t3)
            for (let e4 of t3.keys())
              r2.has(e4) || t3.getAll(e4).forEach((t4) => {
                r2.append(e4, t4);
              });
          return r2;
        }(o2.search, n2.current ? null : t2.current), [o2.search]), i2 = r.useNavigate(), c2 = a.useCallback((e3, t3) => {
          let r2 = f(typeof e3 == "function" ? e3(u2) : e3);
          n2.current = !0, i2("?" + r2, t3);
        }, [i2, u2]);
        return [u2, c2];
      }, e.useSubmit = function() {
        return F();
      }, Object.defineProperty(e, "__esModule", { value: !0 });
    });
  }
});

// node_modules/react-router-dom/dist/main.js
var require_main2 = __commonJS({
  "node_modules/react-router-dom/dist/main.js"(exports, module2) {
    "use strict";
    module2.exports = require_react_router_dom_production_min();
  }
});

// node_modules/@remix-run/react/dist/_virtual/_rollupPluginBabelHelpers.js
var require_rollupPluginBabelHelpers = __commonJS({
  "node_modules/@remix-run/react/dist/_virtual/_rollupPluginBabelHelpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    function _extends() {
      return _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source)
            Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
        }
        return target;
      }, _extends.apply(this, arguments);
    }
    exports.extends = _extends;
  }
});

// node_modules/@remix-run/react/dist/errorBoundaries.js
var require_errorBoundaries = __commonJS({
  "node_modules/@remix-run/react/dist/errorBoundaries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var React = require_react(), reactRouterDom = require_main2();
    function _interopDefaultLegacy(e) {
      return e && typeof e == "object" && "default" in e ? e : { default: e };
    }
    var React__default = /* @__PURE__ */ _interopDefaultLegacy(React), RemixErrorBoundary = class extends React__default.default.Component {
      constructor(props) {
        super(props), this.state = {
          error: props.error || null,
          location: props.location
        };
      }
      static getDerivedStateFromError(error) {
        return {
          error
        };
      }
      static getDerivedStateFromProps(props, state) {
        return state.location !== props.location ? {
          error: props.error || null,
          location: props.location
        } : {
          error: props.error || state.error,
          location: state.location
        };
      }
      render() {
        return this.state.error ? /* @__PURE__ */ React__default.default.createElement(this.props.component, {
          error: this.state.error
        }) : this.props.children;
      }
    };
    function RemixRootDefaultErrorBoundary({
      error
    }) {
      return console.error(error), /* @__PURE__ */ React__default.default.createElement("html", {
        lang: "en"
      }, /* @__PURE__ */ React__default.default.createElement("head", null, /* @__PURE__ */ React__default.default.createElement("meta", {
        charSet: "utf-8"
      }), /* @__PURE__ */ React__default.default.createElement("meta", {
        name: "viewport",
        content: "width=device-width, initial-scale=1, viewport-fit=cover"
      }), /* @__PURE__ */ React__default.default.createElement("title", null, "Application Error!")), /* @__PURE__ */ React__default.default.createElement("body", null, /* @__PURE__ */ React__default.default.createElement("main", {
        style: {
          fontFamily: "system-ui, sans-serif",
          padding: "2rem"
        }
      }, /* @__PURE__ */ React__default.default.createElement("h1", {
        style: {
          fontSize: "24px"
        }
      }, "Application Error"), /* @__PURE__ */ React__default.default.createElement("pre", {
        style: {
          padding: "2rem",
          background: "hsla(10, 50%, 50%, 0.1)",
          color: "red",
          overflow: "auto"
        }
      }, error.stack)), /* @__PURE__ */ React__default.default.createElement("script", {
        dangerouslySetInnerHTML: {
          __html: `
              console.log(
                "\u{1F4BF} Hey developer\u{1F44B}. You can provide a way better UX than this when your app throws errors. Check out https://remix.run/guides/errors for more information."
              );
            `
        }
      })));
    }
    function V2_RemixRootDefaultErrorBoundary() {
      let error = reactRouterDom.useRouteError();
      if (reactRouterDom.isRouteErrorResponse(error))
        return /* @__PURE__ */ React__default.default.createElement(RemixRootDefaultCatchBoundaryImpl, {
          caught: error
        });
      if (error instanceof Error)
        return /* @__PURE__ */ React__default.default.createElement(RemixRootDefaultErrorBoundary, {
          error
        });
      {
        let errorString = error == null ? "Unknown Error" : typeof error == "object" && "toString" in error ? error.toString() : JSON.stringify(error);
        return /* @__PURE__ */ React__default.default.createElement(RemixRootDefaultErrorBoundary, {
          error: new Error(errorString)
        });
      }
    }
    var RemixCatchContext = /* @__PURE__ */ React__default.default.createContext(void 0);
    function useCatch() {
      return React.useContext(RemixCatchContext);
    }
    function RemixCatchBoundary({
      catch: catchVal,
      component: Component,
      children
    }) {
      return catchVal ? /* @__PURE__ */ React__default.default.createElement(RemixCatchContext.Provider, {
        value: catchVal
      }, /* @__PURE__ */ React__default.default.createElement(Component, null)) : /* @__PURE__ */ React__default.default.createElement(React__default.default.Fragment, null, children);
    }
    function RemixRootDefaultCatchBoundary() {
      let caught = useCatch();
      return /* @__PURE__ */ React__default.default.createElement(RemixRootDefaultCatchBoundaryImpl, {
        caught
      });
    }
    function RemixRootDefaultCatchBoundaryImpl({
      caught
    }) {
      return /* @__PURE__ */ React__default.default.createElement("html", {
        lang: "en"
      }, /* @__PURE__ */ React__default.default.createElement("head", null, /* @__PURE__ */ React__default.default.createElement("meta", {
        charSet: "utf-8"
      }), /* @__PURE__ */ React__default.default.createElement("meta", {
        name: "viewport",
        content: "width=device-width, initial-scale=1, viewport-fit=cover"
      }), /* @__PURE__ */ React__default.default.createElement("title", null, "Unhandled Thrown Response!")), /* @__PURE__ */ React__default.default.createElement("body", null, /* @__PURE__ */ React__default.default.createElement("h1", {
        style: {
          fontFamily: "system-ui, sans-serif",
          padding: "2rem"
        }
      }, caught.status, " ", caught.statusText), /* @__PURE__ */ React__default.default.createElement("script", {
        dangerouslySetInnerHTML: {
          __html: `
              console.log(
                "\u{1F4BF} Hey developer\u{1F44B}. You can provide a way better UX than this when your app throws 404s (and other responses). Check out https://remix.run/guides/not-found for more information."
              );
            `
        }
      })));
    }
    exports.RemixCatchBoundary = RemixCatchBoundary;
    exports.RemixErrorBoundary = RemixErrorBoundary;
    exports.RemixRootDefaultCatchBoundary = RemixRootDefaultCatchBoundary;
    exports.RemixRootDefaultErrorBoundary = RemixRootDefaultErrorBoundary;
    exports.V2_RemixRootDefaultErrorBoundary = V2_RemixRootDefaultErrorBoundary;
    exports.useCatch = useCatch;
  }
});

// node_modules/@remix-run/react/dist/invariant.js
var require_invariant2 = __commonJS({
  "node_modules/@remix-run/react/dist/invariant.js"(exports, module2) {
    "use strict";
    function invariant(value, message) {
      if (value === !1 || value === null || typeof value > "u")
        throw new Error(message);
    }
    module2.exports = invariant;
  }
});

// node_modules/@remix-run/react/dist/routeModules.js
var require_routeModules = __commonJS({
  "node_modules/@remix-run/react/dist/routeModules.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      return e && Object.keys(e).forEach(function(k) {
        if (k !== "default") {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: !0,
            get: function() {
              return e[k];
            }
          });
        }
      }), n.default = e, Object.freeze(n);
    }
    async function loadRouteModule(route, routeModulesCache) {
      if (route.id in routeModulesCache)
        return routeModulesCache[route.id];
      try {
        let routeModule = await function(t) {
          return Promise.resolve().then(function() {
            return /* @__PURE__ */ _interopNamespace(require(t));
          });
        }(
          /* webpackIgnore: true */
          route.module
        );
        return routeModulesCache[route.id] = routeModule, routeModule;
      } catch {
        return window.location.reload(), new Promise(() => {
        });
      }
    }
    exports.loadRouteModule = loadRouteModule;
  }
});

// node_modules/@remix-run/react/dist/links.js
var require_links = __commonJS({
  "node_modules/@remix-run/react/dist/links.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var reactRouterDom = require_main2(), routeModules = require_routeModules();
    function getLinksForMatches(matches, routeModules2, manifest) {
      let descriptors2 = matches.map((match) => {
        var _module$links;
        let module3 = routeModules2[match.route.id];
        return ((_module$links = module3.links) === null || _module$links === void 0 ? void 0 : _module$links.call(module3)) || [];
      }).flat(1), preloads = getCurrentPageModulePreloadHrefs(matches, manifest);
      return dedupe(descriptors2, preloads);
    }
    async function prefetchStyleLinks(routeModule) {
      if (!routeModule.links)
        return;
      let descriptors2 = routeModule.links();
      if (!descriptors2)
        return;
      let styleLinks = [];
      for (let descriptor of descriptors2)
        !isPageLinkDescriptor(descriptor) && descriptor.rel === "stylesheet" && styleLinks.push({
          ...descriptor,
          rel: "preload",
          as: "style"
        });
      let matchingLinks = styleLinks.filter((link) => !link.media || window.matchMedia(link.media).matches);
      await Promise.all(matchingLinks.map(prefetchStyleLink));
    }
    async function prefetchStyleLink(descriptor) {
      return new Promise((resolve) => {
        let link = document.createElement("link");
        Object.assign(link, descriptor);
        function removeLink() {
          document.head.contains(link) && document.head.removeChild(link);
        }
        link.onload = () => {
          removeLink(), resolve();
        }, link.onerror = () => {
          removeLink(), resolve();
        }, document.head.appendChild(link);
      });
    }
    function isPageLinkDescriptor(object) {
      return object != null && typeof object.page == "string";
    }
    function isHtmlLinkDescriptor(object) {
      return object == null ? !1 : object.href == null ? object.rel === "preload" && (typeof object.imageSrcSet == "string" || typeof object.imagesrcset == "string") && (typeof object.imageSizes == "string" || typeof object.imagesizes == "string") : typeof object.rel == "string" && typeof object.href == "string";
    }
    async function getStylesheetPrefetchLinks(matches, manifest, routeModules$1) {
      return (await Promise.all(matches.map(async (match) => {
        let mod = await routeModules.loadRouteModule(manifest.routes[match.route.id], routeModules$1);
        return mod.links ? mod.links() : [];
      }))).flat(1).filter(isHtmlLinkDescriptor).filter((link) => link.rel === "stylesheet" || link.rel === "preload").map((link) => link.rel === "preload" ? {
        ...link,
        rel: "prefetch"
      } : {
        ...link,
        rel: "prefetch",
        as: "style"
      });
    }
    function getNewMatchesForLinks(page, nextMatches, currentMatches, manifest, location, mode) {
      let path = parsePathPatch(page), isNew = (match, index) => currentMatches[index] ? match.route.id !== currentMatches[index].route.id : !0, matchPathChanged = (match, index) => {
        var _currentMatches$index;
        return (
          // param change, /users/123 -> /users/456
          currentMatches[index].pathname !== match.pathname || // splat param changed, which is not present in match.path
          // e.g. /files/images/avatar.jpg -> files/finances.xls
          ((_currentMatches$index = currentMatches[index].route.path) === null || _currentMatches$index === void 0 ? void 0 : _currentMatches$index.endsWith("*")) && currentMatches[index].params["*"] !== match.params["*"]
        );
      };
      return mode === "data" && location.search !== path.search ? (
        // this is really similar to stuff in transition.ts, maybe somebody smarter
        // than me (or in less of a hurry) can share some of it. You're the best.
        nextMatches.filter((match, index) => {
          if (!manifest.routes[match.route.id].hasLoader)
            return !1;
          if (isNew(match, index) || matchPathChanged(match, index))
            return !0;
          if (match.route.shouldRevalidate) {
            var _currentMatches$;
            let routeChoice = match.route.shouldRevalidate({
              currentUrl: new URL(location.pathname + location.search + location.hash, window.origin),
              currentParams: ((_currentMatches$ = currentMatches[0]) === null || _currentMatches$ === void 0 ? void 0 : _currentMatches$.params) || {},
              nextUrl: new URL(page, window.origin),
              nextParams: match.params,
              defaultShouldRevalidate: !0
            });
            if (typeof routeChoice == "boolean")
              return routeChoice;
          }
          return !0;
        })
      ) : nextMatches.filter((match, index) => {
        let manifestRoute = manifest.routes[match.route.id];
        return (mode === "assets" || manifestRoute.hasLoader) && (isNew(match, index) || matchPathChanged(match, index));
      });
    }
    function getDataLinkHrefs(page, matches, manifest) {
      let path = parsePathPatch(page);
      return dedupeHrefs(matches.filter((match) => manifest.routes[match.route.id].hasLoader).map((match) => {
        let {
          pathname,
          search
        } = path, searchParams = new URLSearchParams(search);
        return searchParams.set("_data", match.route.id), `${pathname}?${searchParams}`;
      }));
    }
    function getModuleLinkHrefs(matches, manifestPatch) {
      return dedupeHrefs(matches.map((match) => {
        let route = manifestPatch.routes[match.route.id], hrefs = [route.module];
        return route.imports && (hrefs = hrefs.concat(route.imports)), hrefs;
      }).flat(1));
    }
    function getCurrentPageModulePreloadHrefs(matches, manifest) {
      return dedupeHrefs(matches.map((match) => {
        let route = manifest.routes[match.route.id], hrefs = [route.module];
        return route.imports && (hrefs = hrefs.concat(route.imports)), hrefs;
      }).flat(1));
    }
    function dedupeHrefs(hrefs) {
      return [...new Set(hrefs)];
    }
    function dedupe(descriptors2, preloads) {
      let set = /* @__PURE__ */ new Set(), preloadsSet = new Set(preloads);
      return descriptors2.reduce((deduped, descriptor) => {
        if (!isPageLinkDescriptor(descriptor) && descriptor.as === "script" && descriptor.href && preloadsSet.has(descriptor.href))
          return deduped;
        let str = JSON.stringify(descriptor);
        return set.has(str) || (set.add(str), deduped.push(descriptor)), deduped;
      }, []);
    }
    function parsePathPatch(href) {
      let path = reactRouterDom.parsePath(href);
      return path.search === void 0 && (path.search = ""), path;
    }
    exports.dedupe = dedupe;
    exports.getDataLinkHrefs = getDataLinkHrefs;
    exports.getLinksForMatches = getLinksForMatches;
    exports.getModuleLinkHrefs = getModuleLinkHrefs;
    exports.getNewMatchesForLinks = getNewMatchesForLinks;
    exports.getStylesheetPrefetchLinks = getStylesheetPrefetchLinks;
    exports.isHtmlLinkDescriptor = isHtmlLinkDescriptor;
    exports.isPageLinkDescriptor = isPageLinkDescriptor;
    exports.prefetchStyleLinks = prefetchStyleLinks;
  }
});

// node_modules/@remix-run/react/dist/markup.js
var require_markup2 = __commonJS({
  "node_modules/@remix-run/react/dist/markup.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var ESCAPE_LOOKUP = {
      "&": "\\u0026",
      ">": "\\u003e",
      "<": "\\u003c",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    }, ESCAPE_REGEX = /[&><\u2028\u2029]/g;
    function escapeHtml(html) {
      return html.replace(ESCAPE_REGEX, (match) => ESCAPE_LOOKUP[match]);
    }
    function createHtml(html) {
      return {
        __html: html
      };
    }
    exports.createHtml = createHtml;
    exports.escapeHtml = escapeHtml;
  }
});

// node_modules/@remix-run/react/dist/transition.js
var require_transition = __commonJS({
  "node_modules/@remix-run/react/dist/transition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var IDLE_TRANSITION = {
      state: "idle",
      submission: void 0,
      location: void 0,
      type: "idle"
    }, IDLE_FETCHER = {
      state: "idle",
      type: "init",
      data: void 0,
      formMethod: void 0,
      formAction: void 0,
      formData: void 0,
      formEncType: void 0,
      submission: void 0
    };
    exports.IDLE_FETCHER = IDLE_FETCHER;
    exports.IDLE_TRANSITION = IDLE_TRANSITION;
  }
});

// node_modules/@remix-run/react/dist/warnings.js
var require_warnings2 = __commonJS({
  "node_modules/@remix-run/react/dist/warnings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    function logDeprecationOnce(message, key = message) {
    }
    exports.logDeprecationOnce = logDeprecationOnce;
  }
});

// node_modules/@remix-run/react/dist/components.js
var require_components = __commonJS({
  "node_modules/@remix-run/react/dist/components.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var _rollupPluginBabelHelpers = require_rollupPluginBabelHelpers(), React = require_react(), reactRouterDom = require_main2(), errorBoundaries = require_errorBoundaries(), invariant = require_invariant2(), links2 = require_links(), markup = require_markup2(), transition = require_transition(), warnings = require_warnings2();
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      return e && Object.keys(e).forEach(function(k) {
        if (k !== "default") {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: !0,
            get: function() {
              return e[k];
            }
          });
        }
      }), n.default = e, Object.freeze(n);
    }
    var React__namespace = /* @__PURE__ */ _interopNamespace(React);
    function useDataRouterContext() {
      let context = React__namespace.useContext(reactRouterDom.UNSAFE_DataRouterContext);
      return invariant(context, "You must render this element inside a <DataRouterContext.Provider> element"), context;
    }
    function useDataRouterStateContext() {
      let context = React__namespace.useContext(reactRouterDom.UNSAFE_DataRouterStateContext);
      return invariant(context, "You must render this element inside a <DataRouterStateContext.Provider> element"), context;
    }
    var RemixContext = /* @__PURE__ */ React__namespace.createContext(void 0);
    RemixContext.displayName = "Remix";
    function useRemixContext() {
      let context = React__namespace.useContext(RemixContext);
      return invariant(context, "You must render this element inside a <Remix> element"), context;
    }
    function RemixRoute({
      id
    }) {
      let {
        routeModules,
        future: future2
      } = useRemixContext();
      invariant(routeModules, `Cannot initialize 'routeModules'. This normally occurs when you have server code in your client modules.
Check this link for more details:
https://remix.run/pages/gotchas#server-code-in-client-bundles`);
      let {
        default: Component,
        ErrorBoundary,
        CatchBoundary: CatchBoundary2
      } = routeModules[id];
      return !Component && (ErrorBoundary || !future2.v2_errorBoundary && CatchBoundary2) && (Component = reactRouterDom.Outlet), invariant(Component, `Route "${id}" has no component! Please go add a \`default\` export in the route module file.
If you were trying to navigate or submit to a resource route, use \`<a>\` instead of \`<Link>\` or \`<Form reloadDocument>\`.`), /* @__PURE__ */ React__namespace.createElement(Component, null);
    }
    function RemixRouteError({
      id
    }) {
      let {
        future: future2,
        routeModules
      } = useRemixContext();
      invariant(routeModules, `Cannot initialize 'routeModules'. This normally occurs when you have server code in your client modules.
Check this link for more details:
https://remix.run/pages/gotchas#server-code-in-client-bundles`);
      let error = reactRouterDom.useRouteError(), {
        CatchBoundary: CatchBoundary2,
        ErrorBoundary
      } = routeModules[id];
      if (future2.v2_errorBoundary) {
        if (id === "root" && (ErrorBoundary || (ErrorBoundary = errorBoundaries.V2_RemixRootDefaultErrorBoundary)), ErrorBoundary)
          return /* @__PURE__ */ React__namespace.createElement(ErrorBoundary, null);
        throw error;
      }
      if (id === "root" && (CatchBoundary2 || (CatchBoundary2 = errorBoundaries.RemixRootDefaultCatchBoundary), ErrorBoundary || (ErrorBoundary = errorBoundaries.RemixRootDefaultErrorBoundary)), reactRouterDom.isRouteErrorResponse(error)) {
        let tError = error;
        if ((tError == null ? void 0 : tError.error) instanceof Error && tError.status !== 404 && ErrorBoundary)
          return /* @__PURE__ */ React__namespace.createElement(ErrorBoundary, {
            error: tError.error
          });
        if (CatchBoundary2)
          return /* @__PURE__ */ React__namespace.createElement(errorBoundaries.RemixCatchBoundary, {
            component: CatchBoundary2,
            catch: error
          });
      }
      if (error instanceof Error && ErrorBoundary)
        return /* @__PURE__ */ React__namespace.createElement(ErrorBoundary, {
          error
        });
      throw error;
    }
    function usePrefetchBehavior(prefetch, theirElementProps) {
      let [maybePrefetch, setMaybePrefetch] = React__namespace.useState(!1), [shouldPrefetch, setShouldPrefetch] = React__namespace.useState(!1), {
        onFocus,
        onBlur,
        onMouseEnter,
        onMouseLeave,
        onTouchStart
      } = theirElementProps;
      React__namespace.useEffect(() => {
        prefetch === "render" && setShouldPrefetch(!0);
      }, [prefetch]);
      let setIntent = () => {
        prefetch === "intent" && setMaybePrefetch(!0);
      }, cancelIntent = () => {
        prefetch === "intent" && (setMaybePrefetch(!1), setShouldPrefetch(!1));
      };
      return React__namespace.useEffect(() => {
        if (maybePrefetch) {
          let id = setTimeout(() => {
            setShouldPrefetch(!0);
          }, 100);
          return () => {
            clearTimeout(id);
          };
        }
      }, [maybePrefetch]), [shouldPrefetch, {
        onFocus: composeEventHandlers(onFocus, setIntent),
        onBlur: composeEventHandlers(onBlur, cancelIntent),
        onMouseEnter: composeEventHandlers(onMouseEnter, setIntent),
        onMouseLeave: composeEventHandlers(onMouseLeave, cancelIntent),
        onTouchStart: composeEventHandlers(onTouchStart, setIntent)
      }];
    }
    var ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, NavLink = /* @__PURE__ */ React__namespace.forwardRef(({
      to,
      prefetch = "none",
      ...props
    }, forwardedRef) => {
      let isAbsolute = typeof to == "string" && ABSOLUTE_URL_REGEX.test(to), href = reactRouterDom.useHref(to), [shouldPrefetch, prefetchHandlers] = usePrefetchBehavior(prefetch, props);
      return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(reactRouterDom.NavLink, _rollupPluginBabelHelpers.extends({
        ref: forwardedRef,
        to
      }, props, prefetchHandlers)), shouldPrefetch && !isAbsolute ? /* @__PURE__ */ React__namespace.createElement(PrefetchPageLinks, {
        page: href
      }) : null);
    });
    NavLink.displayName = "NavLink";
    var Link = /* @__PURE__ */ React__namespace.forwardRef(({
      to,
      prefetch = "none",
      ...props
    }, forwardedRef) => {
      let isAbsolute = typeof to == "string" && ABSOLUTE_URL_REGEX.test(to), href = reactRouterDom.useHref(to), [shouldPrefetch, prefetchHandlers] = usePrefetchBehavior(prefetch, props);
      return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(reactRouterDom.Link, _rollupPluginBabelHelpers.extends({
        ref: forwardedRef,
        to
      }, props, prefetchHandlers)), shouldPrefetch && !isAbsolute ? /* @__PURE__ */ React__namespace.createElement(PrefetchPageLinks, {
        page: href
      }) : null);
    });
    Link.displayName = "Link";
    function composeEventHandlers(theirHandler, ourHandler) {
      return (event) => {
        theirHandler && theirHandler(event), event.defaultPrevented || ourHandler(event);
      };
    }
    var linksWarning = "\u26A0\uFE0F REMIX FUTURE CHANGE: The behavior of links `imagesizes` and `imagesrcset` will be changing in v2. Only the React camel case versions will be valid. Please change to `imageSizes` and `imageSrcSet`.For instructions on making this change see https://remix.run/docs/en/v1.15.0/pages/v2#links-imagesizes-and-imagesrcset", useTransitionWarning = "\u26A0\uFE0F REMIX FUTURE CHANGE: `useTransition` will be removed in v2 in favor of `useNavigation`. You can prepare for this change at your convenience by updating to `useNavigation`.For instructions on making this change see https://remix.run/docs/en/v1.15.0/pages/v2#usetransition", fetcherTypeWarning = "\u26A0\uFE0F REMIX FUTURE CHANGE: `fetcher.type` will be removed in v2. Please use `fetcher.state`, `fetcher.formData`, and `fetcher.data` to achieve the same UX.For instructions on making this change see https://remix.run/docs/en/v1.15.0/pages/v2#usefetcher", fetcherSubmissionWarning = "\u26A0\uFE0F REMIX FUTURE CHANGE : `fetcher.submission` will be removed in v2. The submission fields are now part of the fetcher object itself (`fetcher.formData`). For instructions on making this change see https://remix.run/docs/en/v1.15.0/pages/v2#usefetcher";
    function Links2() {
      let {
        manifest,
        routeModules
      } = useRemixContext(), {
        errors,
        matches: routerMatches
      } = useDataRouterStateContext(), matches = errors ? routerMatches.slice(0, routerMatches.findIndex((m) => errors[m.route.id]) + 1) : routerMatches, links$1 = React__namespace.useMemo(() => links2.getLinksForMatches(matches, routeModules, manifest), [matches, routeModules, manifest]);
      return React__namespace.useEffect(() => {
        links$1.some((link) => "imagesizes" in link || "imagesrcset" in link) && warnings.logDeprecationOnce(linksWarning);
      }, [links$1]), /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, links$1.map((link) => {
        if (links2.isPageLinkDescriptor(link))
          return /* @__PURE__ */ React__namespace.createElement(PrefetchPageLinks, _rollupPluginBabelHelpers.extends({
            key: link.page
          }, link));
        let imageSrcSet = null;
        return "useId" in React__namespace ? (link.imagesrcset && (link.imageSrcSet = imageSrcSet = link.imagesrcset, delete link.imagesrcset), link.imagesizes && (link.imageSizes = link.imagesizes, delete link.imagesizes)) : (link.imageSrcSet && (link.imagesrcset = imageSrcSet = link.imageSrcSet, delete link.imageSrcSet), link.imageSizes && (link.imagesizes = link.imageSizes, delete link.imageSizes)), /* @__PURE__ */ React__namespace.createElement("link", _rollupPluginBabelHelpers.extends({
          key: link.rel + (link.href || "") + (imageSrcSet || "")
        }, link));
      }));
    }
    function PrefetchPageLinks({
      page,
      ...dataLinkProps
    }) {
      let {
        router
      } = useDataRouterContext(), matches = React__namespace.useMemo(() => reactRouterDom.matchRoutes(router.routes, page), [router.routes, page]);
      return matches ? /* @__PURE__ */ React__namespace.createElement(PrefetchPageLinksImpl, _rollupPluginBabelHelpers.extends({
        page,
        matches
      }, dataLinkProps)) : (console.warn(`Tried to prefetch ${page} but no routes matched.`), null);
    }
    function usePrefetchedStylesheets(matches) {
      let {
        manifest,
        routeModules
      } = useRemixContext(), [styleLinks, setStyleLinks] = React__namespace.useState([]);
      return React__namespace.useEffect(() => {
        let interrupted = !1;
        return links2.getStylesheetPrefetchLinks(matches, manifest, routeModules).then((links3) => {
          interrupted || setStyleLinks(links3);
        }), () => {
          interrupted = !0;
        };
      }, [matches, manifest, routeModules]), styleLinks;
    }
    function PrefetchPageLinksImpl({
      page,
      matches: nextMatches,
      ...linkProps
    }) {
      let location = reactRouterDom.useLocation(), {
        manifest
      } = useRemixContext(), {
        matches
      } = useDataRouterStateContext(), newMatchesForData = React__namespace.useMemo(() => links2.getNewMatchesForLinks(page, nextMatches, matches, manifest, location, "data"), [page, nextMatches, matches, manifest, location]), newMatchesForAssets = React__namespace.useMemo(() => links2.getNewMatchesForLinks(page, nextMatches, matches, manifest, location, "assets"), [page, nextMatches, matches, manifest, location]), dataHrefs = React__namespace.useMemo(() => links2.getDataLinkHrefs(page, newMatchesForData, manifest), [newMatchesForData, page, manifest]), moduleHrefs = React__namespace.useMemo(() => links2.getModuleLinkHrefs(newMatchesForAssets, manifest), [newMatchesForAssets, manifest]), styleLinks = usePrefetchedStylesheets(newMatchesForAssets);
      return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, dataHrefs.map((href) => /* @__PURE__ */ React__namespace.createElement("link", _rollupPluginBabelHelpers.extends({
        key: href,
        rel: "prefetch",
        as: "fetch",
        href
      }, linkProps))), moduleHrefs.map((href) => /* @__PURE__ */ React__namespace.createElement("link", _rollupPluginBabelHelpers.extends({
        key: href,
        rel: "modulepreload",
        href
      }, linkProps))), styleLinks.map((link) => (
        // these don't spread `linkProps` because they are full link descriptors
        // already with their own props
        /* @__PURE__ */ React__namespace.createElement("link", _rollupPluginBabelHelpers.extends({
          key: link.href
        }, link))
      )));
    }
    function V1Meta() {
      let {
        routeModules
      } = useRemixContext(), {
        errors,
        matches: routerMatches,
        loaderData
      } = useDataRouterStateContext(), location = reactRouterDom.useLocation(), matches = errors ? routerMatches.slice(0, routerMatches.findIndex((m) => errors[m.route.id]) + 1) : routerMatches, meta = {}, parentsData = {};
      for (let match of matches) {
        let routeId = match.route.id, data = loaderData[routeId], params = match.params, routeModule = routeModules[routeId];
        if (routeModule.meta) {
          let routeMeta = typeof routeModule.meta == "function" ? routeModule.meta({
            data,
            parentsData,
            params,
            location
          }) : routeModule.meta;
          if (routeMeta && Array.isArray(routeMeta))
            throw new Error(
              "The route at " + match.route.path + " returns an array. This is only supported with the `v2_meta` future flag in the Remix config. Either set the flag to `true` or update the route's meta function to return an object.\n\nTo reference the v1 meta function API, see https://remix.run/route/meta"
              // TODO: Add link to the docs once they are written
              // + "\n\nTo reference future flags and the v2 meta API, see https://remix.run/file-conventions/remix-config#future-v2-meta."
            );
          Object.assign(meta, routeMeta);
        }
        parentsData[routeId] = data;
      }
      return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, Object.entries(meta).map(([name, value]) => {
        if (!value)
          return null;
        if (["charset", "charSet"].includes(name))
          return /* @__PURE__ */ React__namespace.createElement("meta", {
            key: "charSet",
            charSet: value
          });
        if (name === "title")
          return /* @__PURE__ */ React__namespace.createElement("title", {
            key: "title"
          }, String(value));
        let isOpenGraphTag = /^(og|music|video|article|book|profile|fb):.+$/.test(name);
        return [value].flat().map((content) => isOpenGraphTag ? /* @__PURE__ */ React__namespace.createElement("meta", {
          property: name,
          content,
          key: name + content
        }) : typeof content == "string" ? /* @__PURE__ */ React__namespace.createElement("meta", {
          name,
          content,
          key: name + content
        }) : /* @__PURE__ */ React__namespace.createElement("meta", _rollupPluginBabelHelpers.extends({
          key: name + JSON.stringify(content)
        }, content)));
      }));
    }
    function V2Meta() {
      let {
        routeModules
      } = useRemixContext(), {
        errors,
        matches: routerMatches,
        loaderData
      } = useDataRouterStateContext(), location = reactRouterDom.useLocation(), _matches = errors ? routerMatches.slice(0, routerMatches.findIndex((m) => errors[m.route.id]) + 1) : routerMatches, meta = [], leafMeta = null, matches = [];
      for (let i = 0; i < _matches.length; i++) {
        let _match = _matches[i], routeId = _match.route.id, data = loaderData[routeId], params = _match.params, routeModule = routeModules[routeId], routeMeta = [], match = {
          id: routeId,
          data,
          meta: [],
          params: _match.params,
          pathname: _match.pathname,
          handle: _match.route.handle,
          // TODO: Remove in v2. Only leaving it for now because we used it in
          // examples and there's no reason to crash someone's build for one line.
          // They'll get a TS error from the type updates anyway.
          // @ts-expect-error
          get route() {
            return console.warn("The meta function in " + _match.route.path + " accesses the `route` property on `matches`. This is deprecated and will be removed in Remix version 2. See"), _match.route;
          }
        };
        if (matches[i] = match, routeModule != null && routeModule.meta ? routeMeta = typeof routeModule.meta == "function" ? routeModule.meta({
          data,
          params,
          location,
          matches
        }) : Array.isArray(routeModule.meta) ? [...routeModule.meta] : routeModule.meta : leafMeta && (routeMeta = [...leafMeta]), routeMeta = routeMeta || [], !Array.isArray(routeMeta))
          throw new Error("The `v2_meta` API is enabled in the Remix config, but the route at " + _match.route.path + ` returns an invalid value. In v2, all route meta functions must return an array of meta objects.

To reference the v1 meta function API, see https://remix.run/route/meta`);
        match.meta = routeMeta, matches[i] = match, meta = [...routeMeta], leafMeta = meta;
      }
      return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, meta.flat().map((metaProps) => {
        if (!metaProps)
          return null;
        if ("tagName" in metaProps) {
          let tagName = metaProps.tagName;
          if (delete metaProps.tagName, !isValidMetaTag(tagName))
            return console.warn(`A meta object uses an invalid tagName: ${tagName}. Expected either 'link' or 'meta'`), null;
          let Comp = tagName;
          return /* @__PURE__ */ React__namespace.createElement(Comp, _rollupPluginBabelHelpers.extends({
            key: JSON.stringify(metaProps)
          }, metaProps));
        }
        if ("title" in metaProps)
          return /* @__PURE__ */ React__namespace.createElement("title", {
            key: "title"
          }, String(metaProps.title));
        if ("charset" in metaProps && (metaProps.charSet ?? (metaProps.charSet = metaProps.charset), delete metaProps.charset), "charSet" in metaProps && metaProps.charSet != null)
          return typeof metaProps.charSet == "string" ? /* @__PURE__ */ React__namespace.createElement("meta", {
            key: "charSet",
            charSet: metaProps.charSet
          }) : null;
        if ("script:ld+json" in metaProps) {
          let json = null;
          try {
            json = JSON.stringify(metaProps["script:ld+json"]);
          } catch {
          }
          return json != null && /* @__PURE__ */ React__namespace.createElement("script", {
            key: "script:ld+json",
            type: "application/ld+json",
            dangerouslySetInnerHTML: {
              __html: JSON.stringify(metaProps["script:ld+json"])
            }
          });
        }
        return /* @__PURE__ */ React__namespace.createElement("meta", _rollupPluginBabelHelpers.extends({
          key: JSON.stringify(metaProps)
        }, metaProps));
      }));
    }
    function isValidMetaTag(tagName) {
      return typeof tagName == "string" && /^(meta|link)$/.test(tagName);
    }
    function Meta2() {
      let {
        future: future2
      } = useRemixContext();
      return future2 != null && future2.v2_meta ? /* @__PURE__ */ React__namespace.createElement(V2Meta, null) : /* @__PURE__ */ React__namespace.createElement(V1Meta, null);
    }
    function Await(props) {
      return /* @__PURE__ */ React__namespace.createElement(reactRouterDom.Await, props);
    }
    var isHydrated = !1;
    function Scripts2(props) {
      let {
        manifest,
        serverHandoffString,
        abortDelay
      } = useRemixContext(), {
        router,
        static: isStatic,
        staticContext
      } = useDataRouterContext(), {
        matches
      } = useDataRouterStateContext(), navigation = reactRouterDom.useNavigation();
      React__namespace.useEffect(() => {
        isHydrated = !0;
      }, []);
      let deferredScripts = [], initialScripts = React__namespace.useMemo(() => {
        var _manifest$hmr;
        let contextScript = staticContext ? `window.__remixContext = ${serverHandoffString};` : " ", activeDeferreds = staticContext == null ? void 0 : staticContext.activeDeferreds;
        contextScript += activeDeferreds ? ["__remixContext.p = function(v,e,p,x) {", "  if (typeof e !== 'undefined') {", `    x=new Error("Unexpected Server Error");
    x.stack=undefined;`, "    p=Promise.reject(x);", "  } else {", "    p=Promise.resolve(v);", "  }", "  return p;", "};", "__remixContext.n = function(i,k) {", "  __remixContext.t = __remixContext.t || {};", "  __remixContext.t[i] = __remixContext.t[i] || {};", "  let p = new Promise((r, e) => {__remixContext.t[i][k] = {r:(v)=>{r(v);},e:(v)=>{e(v);}};});", typeof abortDelay == "number" ? `setTimeout(() => {if(typeof p._error !== "undefined" || typeof p._data !== "undefined"){return;} __remixContext.t[i][k].e(new Error("Server timeout."))}, ${abortDelay});` : "", "  return p;", "};", "__remixContext.r = function(i,k,v,e,p,x) {", "  p = __remixContext.t[i][k];", "  if (typeof e !== 'undefined') {", `    x=new Error("Unexpected Server Error");
    x.stack=undefined;`, "    p.e(x);", "  } else {", "    p.r(v);", "  }", "};"].join(`
`) + Object.entries(activeDeferreds).map(([routeId, deferredData]) => {
          let pendingKeys = new Set(deferredData.pendingKeys), promiseKeyValues = deferredData.deferredKeys.map((key) => {
            if (pendingKeys.has(key))
              return deferredScripts.push(/* @__PURE__ */ React__namespace.createElement(DeferredHydrationScript, {
                key: `${routeId} | ${key}`,
                deferredData,
                routeId,
                dataKey: key
              })), `${JSON.stringify(key)}:__remixContext.n(${JSON.stringify(routeId)}, ${JSON.stringify(key)})`;
            {
              let trackedPromise = deferredData.data[key];
              if (typeof trackedPromise._error < "u") {
                let toSerialize = {
                  message: "Unexpected Server Error",
                  stack: void 0
                };
                return `${JSON.stringify(key)}:__remixContext.p(!1, ${markup.escapeHtml(JSON.stringify(toSerialize))})`;
              } else {
                if (typeof trackedPromise._data > "u")
                  throw new Error(`The deferred data for ${key} was not resolved, did you forget to return data from a deferred promise?`);
                return `${JSON.stringify(key)}:__remixContext.p(${markup.escapeHtml(JSON.stringify(trackedPromise._data))})`;
              }
            }
          }).join(`,
`);
          return `Object.assign(__remixContext.state.loaderData[${JSON.stringify(routeId)}], {${promiseKeyValues}});`;
        }).join(`
`) + (deferredScripts.length > 0 ? `__remixContext.a=${deferredScripts.length};` : "") : "";
        let routeModulesScript = isStatic ? `${(_manifest$hmr = manifest.hmr) !== null && _manifest$hmr !== void 0 && _manifest$hmr.runtime ? `import ${JSON.stringify(manifest.hmr.runtime)};` : ""}import ${JSON.stringify(manifest.url)};
${matches.map((match, index) => `import * as route${index} from ${JSON.stringify(manifest.routes[match.route.id].module)};`).join(`
`)}
window.__remixRouteModules = {${matches.map((match, index) => `${JSON.stringify(match.route.id)}:route${index}`).join(",")}};

import(${JSON.stringify(manifest.entry.module)});` : " ";
        return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement("script", _rollupPluginBabelHelpers.extends({}, props, {
          suppressHydrationWarning: !0,
          dangerouslySetInnerHTML: markup.createHtml(contextScript),
          type: void 0
        })), /* @__PURE__ */ React__namespace.createElement("script", _rollupPluginBabelHelpers.extends({}, props, {
          suppressHydrationWarning: !0,
          dangerouslySetInnerHTML: markup.createHtml(routeModulesScript),
          type: "module",
          async: !0
        })));
      }, []);
      if (!isStatic && typeof __remixContext == "object" && __remixContext.a)
        for (let i = 0; i < __remixContext.a; i++)
          deferredScripts.push(/* @__PURE__ */ React__namespace.createElement(DeferredHydrationScript, {
            key: i
          }));
      let nextMatches = React__namespace.useMemo(() => {
        if (navigation.location) {
          let matches2 = reactRouterDom.matchRoutes(router.routes, navigation.location);
          return invariant(matches2, `No routes match path "${navigation.location.pathname}"`), matches2;
        }
        return [];
      }, [navigation.location, router.routes]), routePreloads = matches.concat(nextMatches).map((match) => {
        let route = manifest.routes[match.route.id];
        return (route.imports || []).concat([route.module]);
      }).flat(1), preloads = isHydrated ? [] : manifest.entry.imports.concat(routePreloads);
      return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement("link", {
        rel: "modulepreload",
        href: manifest.url,
        crossOrigin: props.crossOrigin
      }), /* @__PURE__ */ React__namespace.createElement("link", {
        rel: "modulepreload",
        href: manifest.entry.module,
        crossOrigin: props.crossOrigin
      }), dedupe(preloads).map((path) => /* @__PURE__ */ React__namespace.createElement("link", {
        key: path,
        rel: "modulepreload",
        href: path,
        crossOrigin: props.crossOrigin
      })), !isHydrated && initialScripts, !isHydrated && deferredScripts);
    }
    function DeferredHydrationScript({
      dataKey,
      deferredData,
      routeId
    }) {
      return typeof document > "u" && deferredData && dataKey && routeId && invariant(deferredData.pendingKeys.includes(dataKey), `Deferred data for route ${routeId} with key ${dataKey} was not pending but tried to render a script for it.`), /* @__PURE__ */ React__namespace.createElement(React__namespace.Suspense, {
        fallback: (
          // This makes absolutely no sense. The server renders null as a fallback,
          // but when hydrating, we need to render a script tag to avoid a hydration issue.
          // To reproduce a hydration mismatch, just render null as a fallback.
          typeof document > "u" && deferredData && dataKey && routeId ? null : /* @__PURE__ */ React__namespace.createElement("script", {
            async: !0,
            suppressHydrationWarning: !0,
            dangerouslySetInnerHTML: {
              __html: " "
            }
          })
        )
      }, typeof document > "u" && deferredData && dataKey && routeId ? /* @__PURE__ */ React__namespace.createElement(Await, {
        resolve: deferredData.data[dataKey],
        errorElement: /* @__PURE__ */ React__namespace.createElement(ErrorDeferredHydrationScript, {
          dataKey,
          routeId
        }),
        children: (data) => /* @__PURE__ */ React__namespace.createElement("script", {
          async: !0,
          suppressHydrationWarning: !0,
          dangerouslySetInnerHTML: {
            __html: `__remixContext.r(${JSON.stringify(routeId)}, ${JSON.stringify(dataKey)}, ${markup.escapeHtml(JSON.stringify(data))});`
          }
        })
      }) : /* @__PURE__ */ React__namespace.createElement("script", {
        async: !0,
        suppressHydrationWarning: !0,
        dangerouslySetInnerHTML: {
          __html: " "
        }
      }));
    }
    function ErrorDeferredHydrationScript({
      dataKey,
      routeId
    }) {
      let error = reactRouterDom.useAsyncError(), toSerialize = {
        message: "Unexpected Server Error",
        stack: void 0
      };
      return /* @__PURE__ */ React__namespace.createElement("script", {
        suppressHydrationWarning: !0,
        dangerouslySetInnerHTML: {
          __html: `__remixContext.r(${JSON.stringify(routeId)}, ${JSON.stringify(dataKey)}, !1, ${markup.escapeHtml(JSON.stringify(toSerialize))});`
        }
      });
    }
    function dedupe(array) {
      return [...new Set(array)];
    }
    function useMatches() {
      let {
        routeModules
      } = useRemixContext(), matches = reactRouterDom.useMatches();
      return React__namespace.useMemo(() => matches.map((match) => ({
        id: match.id,
        pathname: match.pathname,
        params: match.params,
        data: match.data,
        // Need to grab handle here since we don't have it at client-side route
        // creation time
        handle: routeModules[match.id].handle
      })), [matches, routeModules]);
    }
    function useLoaderData3() {
      return reactRouterDom.useLoaderData();
    }
    function useActionData() {
      return reactRouterDom.useActionData();
    }
    function useTransition() {
      let navigation = reactRouterDom.useNavigation();
      return React__namespace.useEffect(() => {
        warnings.logDeprecationOnce(useTransitionWarning);
      }, []), React__namespace.useMemo(() => convertNavigationToTransition(navigation), [navigation]);
    }
    function convertNavigationToTransition(navigation) {
      let {
        location,
        state,
        formMethod,
        formAction,
        formEncType,
        formData
      } = navigation;
      if (!location)
        return transition.IDLE_TRANSITION;
      let isActionSubmission = formMethod != null && ["POST", "PUT", "PATCH", "DELETE"].includes(formMethod.toUpperCase());
      if (state === "submitting" && formMethod && formAction && formEncType && formData) {
        if (isActionSubmission)
          return {
            location,
            state,
            submission: {
              method: formMethod.toUpperCase(),
              action: formAction,
              encType: formEncType,
              formData,
              key: ""
            },
            type: "actionSubmission"
          };
        invariant(!1, "Encountered an unexpected navigation scenario in useTransition()");
      }
      if (state === "loading") {
        let {
          _isRedirect,
          _isFetchActionRedirect
        } = location.state || {};
        if (formMethod && formAction && formEncType && formData) {
          if (_isRedirect)
            return isActionSubmission ? {
              location,
              state,
              submission: {
                method: formMethod.toUpperCase(),
                action: formAction,
                encType: formEncType,
                formData,
                key: ""
              },
              type: "actionRedirect"
            } : {
              location,
              state,
              submission: {
                method: formMethod.toUpperCase(),
                action: formAction,
                encType: formEncType,
                formData,
                key: ""
              },
              type: "loaderSubmissionRedirect"
            };
          if (isActionSubmission)
            return {
              location,
              state,
              submission: {
                method: formMethod.toUpperCase(),
                action: formAction,
                encType: formEncType,
                formData,
                key: ""
              },
              type: "actionReload"
            };
          {
            let url2 = new URL(formAction, window.location.origin);
            return url2.search = new URLSearchParams(formData.entries()).toString(), {
              location,
              state: "submitting",
              submission: {
                method: formMethod.toUpperCase(),
                action: url2.pathname + url2.search,
                encType: formEncType,
                formData,
                key: ""
              },
              type: "loaderSubmission"
            };
          }
        } else if (_isRedirect)
          return _isFetchActionRedirect ? {
            location,
            state,
            submission: void 0,
            type: "fetchActionRedirect"
          } : {
            location,
            state,
            submission: void 0,
            type: "normalRedirect"
          };
      }
      return {
        location,
        state: "loading",
        submission: void 0,
        type: "normalLoad"
      };
    }
    function useFetchers() {
      return reactRouterDom.useFetchers().map((f) => {
        let fetcher = convertRouterFetcherToRemixFetcher({
          state: f.state,
          data: f.data,
          formMethod: f.formMethod,
          formAction: f.formAction,
          formData: f.formData,
          formEncType: f.formEncType,
          " _hasFetcherDoneAnything ": f[" _hasFetcherDoneAnything "]
        });
        return addFetcherDeprecationWarnings(fetcher), fetcher;
      });
    }
    function useFetcher() {
      let fetcherRR = reactRouterDom.useFetcher();
      return React__namespace.useMemo(() => {
        let fetcherWithComponents = {
          ...convertRouterFetcherToRemixFetcher({
            state: fetcherRR.state,
            data: fetcherRR.data,
            formMethod: fetcherRR.formMethod,
            formAction: fetcherRR.formAction,
            formData: fetcherRR.formData,
            formEncType: fetcherRR.formEncType,
            " _hasFetcherDoneAnything ": fetcherRR[" _hasFetcherDoneAnything "]
          }),
          load: fetcherRR.load,
          submit: fetcherRR.submit,
          Form: fetcherRR.Form
        };
        return addFetcherDeprecationWarnings(fetcherWithComponents), fetcherWithComponents;
      }, [fetcherRR]);
    }
    function addFetcherDeprecationWarnings(fetcher) {
      let type = fetcher.type;
      Object.defineProperty(fetcher, "type", {
        get() {
          return warnings.logDeprecationOnce(fetcherTypeWarning), type;
        },
        set(value) {
          type = value;
        },
        // These settings should make this behave like a normal object `type` field
        configurable: !0,
        enumerable: !0
      });
      let submission = fetcher.submission;
      Object.defineProperty(fetcher, "submission", {
        get() {
          return warnings.logDeprecationOnce(fetcherSubmissionWarning), submission;
        },
        set(value) {
          submission = value;
        },
        // These settings should make this behave like a normal object `type` field
        configurable: !0,
        enumerable: !0
      });
    }
    function convertRouterFetcherToRemixFetcher(fetcherRR) {
      let {
        state,
        formMethod,
        formAction,
        formEncType,
        formData,
        data
      } = fetcherRR, isActionSubmission = formMethod != null && ["POST", "PUT", "PATCH", "DELETE"].includes(formMethod.toUpperCase());
      if (state === "idle")
        return fetcherRR[" _hasFetcherDoneAnything "] === !0 ? {
          state: "idle",
          type: "done",
          formMethod: void 0,
          formAction: void 0,
          formData: void 0,
          formEncType: void 0,
          submission: void 0,
          data
        } : transition.IDLE_FETCHER;
      if (state === "submitting" && formMethod && formAction && formEncType && formData) {
        if (isActionSubmission)
          return {
            state,
            type: "actionSubmission",
            formMethod: formMethod.toUpperCase(),
            formAction,
            formEncType,
            formData,
            submission: {
              method: formMethod.toUpperCase(),
              action: formAction,
              encType: formEncType,
              formData,
              key: ""
            },
            data
          };
        invariant(!1, "Encountered an unexpected fetcher scenario in useFetcher()");
      }
      if (state === "loading" && formMethod && formAction && formEncType && formData) {
        if (isActionSubmission)
          return data ? {
            state,
            type: "actionReload",
            formMethod: formMethod.toUpperCase(),
            formAction,
            formEncType,
            formData,
            submission: {
              method: formMethod.toUpperCase(),
              action: formAction,
              encType: formEncType,
              formData,
              key: ""
            },
            data
          } : {
            state,
            type: "actionRedirect",
            formMethod: formMethod.toUpperCase(),
            formAction,
            formEncType,
            formData,
            submission: {
              method: formMethod.toUpperCase(),
              action: formAction,
              encType: formEncType,
              formData,
              key: ""
            },
            data: void 0
          };
        {
          let url2 = new URL(formAction, window.location.origin);
          return url2.search = new URLSearchParams(formData.entries()).toString(), {
            state: "submitting",
            type: "loaderSubmission",
            formMethod: formMethod.toUpperCase(),
            formAction,
            formEncType,
            formData,
            submission: {
              method: formMethod.toUpperCase(),
              action: url2.pathname + url2.search,
              encType: formEncType,
              formData,
              key: ""
            },
            data
          };
        }
      }
      return {
        state: "loading",
        type: "normalLoad",
        formMethod: void 0,
        formAction: void 0,
        formData: void 0,
        formEncType: void 0,
        submission: void 0,
        data
      };
    }
    var LiveReload = () => null;
    exports.Await = Await;
    exports.Link = Link;
    exports.Links = Links2;
    exports.LiveReload = LiveReload;
    exports.Meta = Meta2;
    exports.NavLink = NavLink;
    exports.PrefetchPageLinks = PrefetchPageLinks;
    exports.RemixContext = RemixContext;
    exports.RemixRoute = RemixRoute;
    exports.RemixRouteError = RemixRouteError;
    exports.Scripts = Scripts2;
    exports.composeEventHandlers = composeEventHandlers;
    exports.useActionData = useActionData;
    exports.useFetcher = useFetcher;
    exports.useFetchers = useFetchers;
    exports.useLoaderData = useLoaderData3;
    exports.useMatches = useMatches;
    exports.useTransition = useTransition;
  }
});

// node_modules/@remix-run/react/dist/errors.js
var require_errors3 = __commonJS({
  "node_modules/@remix-run/react/dist/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var router = require_router_cjs();
    function deserializeErrors(errors) {
      if (!errors)
        return null;
      let entries = Object.entries(errors), serialized = {};
      for (let [key, val] of entries)
        if (val && val.__type === "RouteErrorResponse")
          serialized[key] = new router.ErrorResponse(val.status, val.statusText, val.data, val.internal === !0);
        else if (val && val.__type === "Error") {
          let error = new Error(val.message);
          error.stack = val.stack, serialized[key] = error;
        } else
          serialized[key] = val;
      return serialized;
    }
    exports.deserializeErrors = deserializeErrors;
  }
});

// node_modules/@remix-run/react/dist/data.js
var require_data2 = __commonJS({
  "node_modules/@remix-run/react/dist/data.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var router = require_router_cjs();
    function isCatchResponse(response) {
      return response instanceof Response && response.headers.get("X-Remix-Catch") != null;
    }
    function isErrorResponse(response) {
      return response instanceof Response && response.headers.get("X-Remix-Error") != null;
    }
    function isRedirectResponse(response) {
      return response instanceof Response && response.headers.get("X-Remix-Redirect") != null;
    }
    function isDeferredResponse(response) {
      var _response$headers$get;
      return response instanceof Response && !!((_response$headers$get = response.headers.get("Content-Type")) !== null && _response$headers$get !== void 0 && _response$headers$get.match(/text\/remix-deferred/));
    }
    async function fetchData(request, routeId) {
      let url2 = new URL(request.url);
      url2.searchParams.set("_data", routeId);
      let init = {
        signal: request.signal
      };
      if (request.method !== "GET") {
        init.method = request.method;
        let contentType = request.headers.get("Content-Type");
        init.body = // Check between word boundaries instead of startsWith() due to the last
        // paragraph of https://httpwg.org/specs/rfc9110.html#field.content-type
        contentType && /\bapplication\/x-www-form-urlencoded\b/.test(contentType) ? new URLSearchParams(await request.text()) : await request.formData();
      }
      let response = await fetch(url2.href, init);
      if (isErrorResponse(response)) {
        let data = await response.json(), error = new Error(data.message);
        return error.stack = data.stack, error;
      }
      return response;
    }
    var DEFERRED_VALUE_PLACEHOLDER_PREFIX = "__deferred_promise:";
    async function parseDeferredReadableStream(stream4) {
      if (!stream4)
        throw new Error("parseDeferredReadableStream requires stream argument");
      let deferredData, deferredResolvers = {};
      try {
        let sectionReader = readStreamSections(stream4), initialSection = (await sectionReader.next()).value;
        if (!initialSection)
          throw new Error("no critical data");
        let criticalData = JSON.parse(initialSection);
        if (typeof criticalData == "object" && criticalData !== null)
          for (let [eventKey, value] of Object.entries(criticalData))
            typeof value != "string" || !value.startsWith(DEFERRED_VALUE_PLACEHOLDER_PREFIX) || (deferredData = deferredData || {}, deferredData[eventKey] = new Promise((resolve, reject) => {
              deferredResolvers[eventKey] = {
                resolve: (value2) => {
                  resolve(value2), delete deferredResolvers[eventKey];
                },
                reject: (error) => {
                  reject(error), delete deferredResolvers[eventKey];
                }
              };
            }));
        return (async () => {
          try {
            for await (let section of sectionReader) {
              let [event, ...sectionDataStrings] = section.split(":"), sectionDataString = sectionDataStrings.join(":"), data = JSON.parse(sectionDataString);
              if (event === "data")
                for (let [key, value] of Object.entries(data))
                  deferredResolvers[key] && deferredResolvers[key].resolve(value);
              else if (event === "error")
                for (let [key, value] of Object.entries(data)) {
                  let err = new Error(value.message);
                  err.stack = value.stack, deferredResolvers[key] && deferredResolvers[key].reject(err);
                }
            }
            for (let [key, resolver] of Object.entries(deferredResolvers))
              resolver.reject(new router.AbortedDeferredError(`Deferred ${key} will never be resolved`));
          } catch (error) {
            for (let resolver of Object.values(deferredResolvers))
              resolver.reject(error);
          }
        })(), new router.UNSAFE_DeferredData({
          ...criticalData,
          ...deferredData
        });
      } catch (error) {
        for (let resolver of Object.values(deferredResolvers))
          resolver.reject(error);
        throw error;
      }
    }
    async function* readStreamSections(stream4) {
      let reader = stream4.getReader(), buffer = [], sections = [], closed = !1, encoder = new TextEncoder(), decoder = new TextDecoder(), readStreamSection = async () => {
        if (sections.length > 0)
          return sections.shift();
        for (; !closed && sections.length === 0; ) {
          let chunk = await reader.read();
          if (chunk.done) {
            closed = !0;
            break;
          }
          buffer.push(chunk.value);
          try {
            let splitSections = decoder.decode(mergeArrays(...buffer)).split(`

`);
            if (splitSections.length >= 2 && (sections.push(...splitSections.slice(0, -1)), buffer = [encoder.encode(splitSections.slice(-1).join(`

`))]), sections.length > 0)
              break;
          } catch {
            continue;
          }
        }
        return sections.length > 0 || buffer.length > 0 && (sections = decoder.decode(mergeArrays(...buffer)).split(`

`).filter((s) => s), buffer = []), sections.shift();
      }, section = await readStreamSection();
      for (; section; )
        yield section, section = await readStreamSection();
    }
    function mergeArrays(...arrays) {
      let out = new Uint8Array(arrays.reduce((total, arr) => total + arr.length, 0)), offset = 0;
      for (let arr of arrays)
        out.set(arr, offset), offset += arr.length;
      return out;
    }
    exports.fetchData = fetchData;
    exports.isCatchResponse = isCatchResponse;
    exports.isDeferredResponse = isDeferredResponse;
    exports.isErrorResponse = isErrorResponse;
    exports.isRedirectResponse = isRedirectResponse;
    exports.parseDeferredReadableStream = parseDeferredReadableStream;
  }
});

// node_modules/@remix-run/react/dist/routes.js
var require_routes2 = __commonJS({
  "node_modules/@remix-run/react/dist/routes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var React = require_react(), reactRouterDom = require_main2(), routeModules = require_routeModules(), data = require_data2(), links2 = require_links(), invariant = require_invariant2(), components = require_components();
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      return e && Object.keys(e).forEach(function(k) {
        if (k !== "default") {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: !0,
            get: function() {
              return e[k];
            }
          });
        }
      }), n.default = e, Object.freeze(n);
    }
    var React__namespace = /* @__PURE__ */ _interopNamespace(React);
    function groupRoutesByParentId(manifest) {
      let routes2 = {};
      return Object.values(manifest).forEach((route) => {
        let parentId = route.parentId || "";
        routes2[parentId] || (routes2[parentId] = []), routes2[parentId].push(route);
      }), routes2;
    }
    function createServerRoutes(manifest, routeModules2, future2, parentId = "", routesByParentId = groupRoutesByParentId(manifest)) {
      return (routesByParentId[parentId] || []).map((route) => {
        let hasErrorBoundary = future2.v2_errorBoundary === !0 ? route.id === "root" || route.hasErrorBoundary : route.id === "root" || route.hasCatchBoundary || route.hasErrorBoundary, dataRoute = {
          caseSensitive: route.caseSensitive,
          element: /* @__PURE__ */ React__namespace.createElement(components.RemixRoute, {
            id: route.id
          }),
          errorElement: hasErrorBoundary ? /* @__PURE__ */ React__namespace.createElement(components.RemixRouteError, {
            id: route.id
          }) : void 0,
          id: route.id,
          index: route.index,
          path: route.path,
          handle: routeModules2[route.id].handle
          // Note: we don't need loader/action/shouldRevalidate on these routes
          // since they're for a static render
        }, children = createServerRoutes(manifest, routeModules2, future2, route.id, routesByParentId);
        return children.length > 0 && (dataRoute.children = children), dataRoute;
      });
    }
    function createClientRoutes(manifest, routeModulesCache, future2, parentId = "", routesByParentId = groupRoutesByParentId(manifest), needsRevalidation) {
      return (routesByParentId[parentId] || []).map((route) => {
        let hasErrorBoundary = future2.v2_errorBoundary === !0 ? route.id === "root" || route.hasErrorBoundary : route.id === "root" || route.hasCatchBoundary || route.hasErrorBoundary, dataRoute = {
          caseSensitive: route.caseSensitive,
          element: /* @__PURE__ */ React__namespace.createElement(components.RemixRoute, {
            id: route.id
          }),
          errorElement: hasErrorBoundary ? /* @__PURE__ */ React__namespace.createElement(components.RemixRouteError, {
            id: route.id
          }) : void 0,
          id: route.id,
          index: route.index,
          path: route.path,
          // handle gets added in via useMatches since we aren't guaranteed to
          // have the route module available here
          handle: void 0,
          loader: createDataFunction(route, routeModulesCache, !1),
          action: createDataFunction(route, routeModulesCache, !0),
          shouldRevalidate: createShouldRevalidate(route, routeModulesCache, needsRevalidation)
        }, children = createClientRoutes(manifest, routeModulesCache, future2, route.id, routesByParentId, needsRevalidation);
        return children.length > 0 && (dataRoute.children = children), dataRoute;
      });
    }
    function createShouldRevalidate(route, routeModules2, needsRevalidation) {
      let handledRevalidation = !1;
      return function(arg) {
        let module3 = routeModules2[route.id];
        return invariant(module3, `Expected route module to be loaded for ${route.id}`), needsRevalidation !== void 0 && !handledRevalidation ? (handledRevalidation = !0, needsRevalidation.has(route.id)) : module3.shouldRevalidate ? module3.shouldRevalidate(arg) : arg.defaultShouldRevalidate;
      };
    }
    async function loadRouteModuleWithBlockingLinks(route, routeModules$1) {
      let routeModule = await routeModules.loadRouteModule(route, routeModules$1);
      return await links2.prefetchStyleLinks(routeModule), routeModule;
    }
    function createDataFunction(route, routeModules2, isAction) {
      return async ({
        request
      }) => {
        let routeModulePromise = loadRouteModuleWithBlockingLinks(route, routeModules2);
        try {
          if (isAction && !route.hasAction) {
            let msg = `Route "${route.id}" does not have an action, but you are trying to submit to it. To fix this, please add an \`action\` function to the route`;
            throw console.error(msg), new Error(msg);
          } else if (!isAction && !route.hasLoader)
            return null;
          let result = await data.fetchData(request, route.id);
          if (result instanceof Error)
            throw result;
          if (data.isRedirectResponse(result))
            throw getRedirect(result);
          if (data.isCatchResponse(result))
            throw result;
          return data.isDeferredResponse(result) && result.body ? await data.parseDeferredReadableStream(result.body) : result;
        } finally {
          await routeModulePromise;
        }
      };
    }
    function getRedirect(response) {
      let status = parseInt(response.headers.get("X-Remix-Status"), 10) || 302, url2 = response.headers.get("X-Remix-Redirect"), headers = {}, revalidate = response.headers.get("X-Remix-Revalidate");
      return revalidate && (headers["X-Remix-Revalidate"] = revalidate), reactRouterDom.redirect(url2, {
        status,
        headers
      });
    }
    exports.createClientRoutes = createClientRoutes;
    exports.createServerRoutes = createServerRoutes;
  }
});

// node_modules/@remix-run/react/dist/browser.js
var require_browser = __commonJS({
  "node_modules/@remix-run/react/dist/browser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var React = require_react(), reactRouterDom = require_main2(), components = require_components(), errorBoundaries = require_errorBoundaries(), errors = require_errors3(), routes2 = require_routes2();
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      return e && Object.keys(e).forEach(function(k) {
        if (k !== "default") {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: !0,
            get: function() {
              return e[k];
            }
          });
        }
      }), n.default = e, Object.freeze(n);
    }
    var React__namespace = /* @__PURE__ */ _interopNamespace(React), router;
    function RemixBrowser(_props) {
      if (!router) {
        let routes$1 = routes2.createClientRoutes(window.__remixManifest.routes, window.__remixRouteModules, window.__remixContext.future), hydrationData = window.__remixContext.state;
        hydrationData && hydrationData.errors && (hydrationData = {
          ...hydrationData,
          errors: errors.deserializeErrors(hydrationData.errors)
        }), router = reactRouterDom.createBrowserRouter(routes$1, {
          hydrationData,
          future: {
            // Pass through the Remix future flag to avoid a v1 breaking change in
            // useNavigation() - users can control the casing via the flag in v1.
            // useFetcher still always uppercases in the back-compat layer in v1.
            // In v2 we can just always pass true here and remove the back-compat
            // layer
            v7_normalizeFormMethod: window.__remixContext.future.v2_normalizeFormMethod
          }
        });
      }
      let [location, setLocation] = React__namespace.useState(router.state.location);
      return React__namespace.useLayoutEffect(() => router.subscribe((newState) => {
        newState.location !== location && setLocation(newState.location);
      }), [location]), /* @__PURE__ */ React__namespace.createElement(components.RemixContext.Provider, {
        value: {
          manifest: window.__remixManifest,
          routeModules: window.__remixRouteModules,
          future: window.__remixContext.future
        }
      }, /* @__PURE__ */ React__namespace.createElement(errorBoundaries.RemixErrorBoundary, {
        location,
        component: errorBoundaries.RemixRootDefaultErrorBoundary
      }, /* @__PURE__ */ React__namespace.createElement(reactRouterDom.RouterProvider, {
        router,
        fallbackElement: null
      })));
    }
    exports.RemixBrowser = RemixBrowser;
  }
});

// node_modules/@remix-run/react/dist/scroll-restoration.js
var require_scroll_restoration = __commonJS({
  "node_modules/@remix-run/react/dist/scroll-restoration.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var _rollupPluginBabelHelpers = require_rollupPluginBabelHelpers(), React = require_react(), reactRouterDom = require_main2(), components = require_components();
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      return e && Object.keys(e).forEach(function(k) {
        if (k !== "default") {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: !0,
            get: function() {
              return e[k];
            }
          });
        }
      }), n.default = e, Object.freeze(n);
    }
    var React__namespace = /* @__PURE__ */ _interopNamespace(React), STORAGE_KEY = "positions";
    function ScrollRestoration2({
      getKey,
      ...props
    }) {
      let location = reactRouterDom.useLocation(), matches = components.useMatches();
      reactRouterDom.UNSAFE_useScrollRestoration({
        getKey,
        storageKey: STORAGE_KEY
      });
      let key = React__namespace.useMemo(
        () => {
          if (!getKey)
            return null;
          let userKey = getKey(location, matches);
          return userKey !== location.key ? userKey : null;
        },
        // Nah, we only need this the first time for the SSR render
        // eslint-disable-next-line react-hooks/exhaustive-deps
        []
      ), restoreScroll = ((STORAGE_KEY2, restoreKey) => {
        if (!window.history.state || !window.history.state.key) {
          let key2 = Math.random().toString(32).slice(2);
          window.history.replaceState({
            key: key2
          }, "");
        }
        try {
          let storedY = JSON.parse(sessionStorage.getItem(STORAGE_KEY2) || "{}")[restoreKey || window.history.state.key];
          typeof storedY == "number" && window.scrollTo(0, storedY);
        } catch (error) {
          console.error(error), sessionStorage.removeItem(STORAGE_KEY2);
        }
      }).toString();
      return /* @__PURE__ */ React__namespace.createElement("script", _rollupPluginBabelHelpers.extends({}, props, {
        suppressHydrationWarning: !0,
        dangerouslySetInnerHTML: {
          __html: `(${restoreScroll})(${JSON.stringify(STORAGE_KEY)}, ${JSON.stringify(key)})`
        }
      }));
    }
    exports.ScrollRestoration = ScrollRestoration2;
  }
});

// node_modules/react-router-dom/server.js
var require_server2 = __commonJS({
  "node_modules/react-router-dom/server.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var React = require_react(), router = require_router_cjs(), reactRouter = require_main(), reactRouterDom = require_main2();
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      return e && Object.keys(e).forEach(function(k) {
        if (k !== "default") {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: !0,
            get: function() {
              return e[k];
            }
          });
        }
      }), n.default = e, Object.freeze(n);
    }
    var React__namespace = /* @__PURE__ */ _interopNamespace(React);
    function StaticRouter({
      basename,
      children,
      location: locationProp = "/"
    }) {
      typeof locationProp == "string" && (locationProp = reactRouterDom.parsePath(locationProp));
      let action = router.Action.Pop, location = {
        pathname: locationProp.pathname || "/",
        search: locationProp.search || "",
        hash: locationProp.hash || "",
        state: locationProp.state || null,
        key: locationProp.key || "default"
      }, staticNavigator = getStatelessNavigator();
      return /* @__PURE__ */ React__namespace.createElement(reactRouterDom.Router, {
        basename,
        children,
        location,
        navigationType: action,
        navigator: staticNavigator,
        static: !0
      });
    }
    function StaticRouterProvider({
      context,
      router: router$1,
      hydrate = !0,
      nonce
    }) {
      router$1 && context || router.UNSAFE_invariant(!1);
      let dataRouterContext = {
        router: router$1,
        navigator: getStatelessNavigator(),
        static: !0,
        staticContext: context,
        basename: context.basename || "/"
      }, hydrateScript = "";
      if (hydrate !== !1) {
        let data = {
          loaderData: context.loaderData,
          actionData: context.actionData,
          errors: serializeErrors(context.errors)
        };
        hydrateScript = `window.__staticRouterHydrationData = JSON.parse(${htmlEscape(JSON.stringify(JSON.stringify(data)))});`;
      }
      let {
        state
      } = dataRouterContext.router;
      return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(reactRouterDom.UNSAFE_DataRouterContext.Provider, {
        value: dataRouterContext
      }, /* @__PURE__ */ React__namespace.createElement(reactRouterDom.UNSAFE_DataRouterStateContext.Provider, {
        value: state
      }, /* @__PURE__ */ React__namespace.createElement(reactRouterDom.Router, {
        basename: dataRouterContext.basename,
        location: state.location,
        navigationType: state.historyAction,
        navigator: dataRouterContext.navigator,
        static: dataRouterContext.static
      }, /* @__PURE__ */ React__namespace.createElement(DataRoutes, {
        routes: router$1.routes,
        state
      })))), hydrateScript ? /* @__PURE__ */ React__namespace.createElement("script", {
        suppressHydrationWarning: !0,
        nonce,
        dangerouslySetInnerHTML: {
          __html: hydrateScript
        }
      }) : null);
    }
    function DataRoutes({
      routes: routes2,
      state
    }) {
      return reactRouter.UNSAFE_useRoutesImpl(routes2, void 0, state);
    }
    function serializeErrors(errors) {
      if (!errors)
        return null;
      let entries = Object.entries(errors), serialized = {};
      for (let [key, val] of entries)
        router.isRouteErrorResponse(val) ? serialized[key] = {
          ...val,
          __type: "RouteErrorResponse"
        } : val instanceof Error ? serialized[key] = {
          message: val.message,
          __type: "Error"
        } : serialized[key] = val;
      return serialized;
    }
    function getStatelessNavigator() {
      return {
        createHref,
        encodeLocation,
        push(to) {
          throw new Error(`You cannot use navigator.push() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${JSON.stringify(to)})\` somewhere in your app.`);
        },
        replace(to) {
          throw new Error(`You cannot use navigator.replace() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${JSON.stringify(to)}, { replace: true })\` somewhere in your app.`);
        },
        go(delta) {
          throw new Error(`You cannot use navigator.go() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${delta})\` somewhere in your app.`);
        },
        back() {
          throw new Error("You cannot use navigator.back() on the server because it is a stateless environment.");
        },
        forward() {
          throw new Error("You cannot use navigator.forward() on the server because it is a stateless environment.");
        }
      };
    }
    function createStaticHandler(routes2, opts) {
      return router.createStaticHandler(routes2, {
        ...opts,
        mapRouteProperties: reactRouter.UNSAFE_mapRouteProperties
      });
    }
    function createStaticRouter(routes2, context) {
      let manifest = {}, dataRoutes = router.UNSAFE_convertRoutesToDataRoutes(routes2, reactRouter.UNSAFE_mapRouteProperties, void 0, manifest), matches = context.matches.map((match) => {
        let route = manifest[match.route.id] || match.route;
        return {
          ...match,
          route
        };
      }), msg = (method) => `You cannot use router.${method}() on the server because it is a stateless environment`;
      return {
        get basename() {
          return context.basename;
        },
        get state() {
          return {
            historyAction: router.Action.Pop,
            location: context.location,
            matches,
            loaderData: context.loaderData,
            actionData: context.actionData,
            errors: context.errors,
            initialized: !0,
            navigation: router.IDLE_NAVIGATION,
            restoreScrollPosition: null,
            preventScrollReset: !1,
            revalidation: "idle",
            fetchers: /* @__PURE__ */ new Map(),
            blockers: /* @__PURE__ */ new Map()
          };
        },
        get routes() {
          return dataRoutes;
        },
        initialize() {
          throw msg("initialize");
        },
        subscribe() {
          throw msg("subscribe");
        },
        enableScrollRestoration() {
          throw msg("enableScrollRestoration");
        },
        navigate() {
          throw msg("navigate");
        },
        fetch() {
          throw msg("fetch");
        },
        revalidate() {
          throw msg("revalidate");
        },
        createHref,
        encodeLocation,
        getFetcher() {
          return router.IDLE_FETCHER;
        },
        deleteFetcher() {
          throw msg("deleteFetcher");
        },
        dispose() {
          throw msg("dispose");
        },
        getBlocker() {
          return router.IDLE_BLOCKER;
        },
        deleteBlocker() {
          throw msg("deleteBlocker");
        },
        _internalFetchControllers: /* @__PURE__ */ new Map(),
        _internalActiveDeferreds: /* @__PURE__ */ new Map(),
        _internalSetRoutes() {
          throw msg("_internalSetRoutes");
        }
      };
    }
    function createHref(to) {
      return typeof to == "string" ? to : reactRouterDom.createPath(to);
    }
    function encodeLocation(to) {
      let path = typeof to == "string" ? reactRouterDom.parsePath(to) : to;
      return {
        pathname: path.pathname || "",
        search: path.search || "",
        hash: path.hash || ""
      };
    }
    var ESCAPE_LOOKUP = {
      "&": "\\u0026",
      ">": "\\u003e",
      "<": "\\u003c",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    }, ESCAPE_REGEX = /[&><\u2028\u2029]/g;
    function htmlEscape(str) {
      return str.replace(ESCAPE_REGEX, (match) => ESCAPE_LOOKUP[match]);
    }
    exports.StaticRouter = StaticRouter;
    exports.StaticRouterProvider = StaticRouterProvider;
    exports.createStaticHandler = createStaticHandler;
    exports.createStaticRouter = createStaticRouter;
  }
});

// node_modules/@remix-run/react/dist/server.js
var require_server3 = __commonJS({
  "node_modules/@remix-run/react/dist/server.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var React = require_react(), server = require_server2(), components = require_components(), errorBoundaries = require_errorBoundaries(), routes2 = require_routes2();
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      return e && Object.keys(e).forEach(function(k) {
        if (k !== "default") {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: !0,
            get: function() {
              return e[k];
            }
          });
        }
      }), n.default = e, Object.freeze(n);
    }
    var React__namespace = /* @__PURE__ */ _interopNamespace(React);
    function RemixServer2({
      context,
      url: url2,
      abortDelay
    }) {
      typeof url2 == "string" && (url2 = new URL(url2));
      let {
        manifest,
        routeModules,
        serverHandoffString
      } = context, routes$1 = routes2.createServerRoutes(manifest.routes, routeModules, context.future), router = server.createStaticRouter(routes$1, context.staticHandlerContext);
      return /* @__PURE__ */ React__namespace.createElement(components.RemixContext.Provider, {
        value: {
          manifest,
          routeModules,
          serverHandoffString,
          future: context.future,
          abortDelay
        }
      }, /* @__PURE__ */ React__namespace.createElement(errorBoundaries.RemixErrorBoundary, {
        location: router.state.location,
        component: errorBoundaries.RemixRootDefaultErrorBoundary
      }, /* @__PURE__ */ React__namespace.createElement(server.StaticRouterProvider, {
        router,
        context: context.staticHandlerContext,
        hydrate: !1
      })));
    }
    exports.RemixServer = RemixServer2;
  }
});

// node_modules/@remix-run/react/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/@remix-run/react/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var browser = require_browser(), reactRouterDom = require_main2(), components = require_components(), errorBoundaries = require_errorBoundaries(), scrollRestoration = require_scroll_restoration(), server = require_server3();
    exports.RemixBrowser = browser.RemixBrowser;
    Object.defineProperty(exports, "Form", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.Form;
      }
    });
    Object.defineProperty(exports, "Outlet", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.Outlet;
      }
    });
    Object.defineProperty(exports, "isRouteErrorResponse", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.isRouteErrorResponse;
      }
    });
    Object.defineProperty(exports, "unstable_useBlocker", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.unstable_useBlocker;
      }
    });
    Object.defineProperty(exports, "unstable_usePrompt", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.unstable_usePrompt;
      }
    });
    Object.defineProperty(exports, "useAsyncError", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useAsyncError;
      }
    });
    Object.defineProperty(exports, "useAsyncValue", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useAsyncValue;
      }
    });
    Object.defineProperty(exports, "useBeforeUnload", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useBeforeUnload;
      }
    });
    Object.defineProperty(exports, "useFormAction", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useFormAction;
      }
    });
    Object.defineProperty(exports, "useHref", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useHref;
      }
    });
    Object.defineProperty(exports, "useLocation", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useLocation;
      }
    });
    Object.defineProperty(exports, "useMatch", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useMatch;
      }
    });
    Object.defineProperty(exports, "useNavigate", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useNavigate;
      }
    });
    Object.defineProperty(exports, "useNavigation", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useNavigation;
      }
    });
    Object.defineProperty(exports, "useNavigationType", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useNavigationType;
      }
    });
    Object.defineProperty(exports, "useOutlet", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useOutlet;
      }
    });
    Object.defineProperty(exports, "useOutletContext", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useOutletContext;
      }
    });
    Object.defineProperty(exports, "useParams", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useParams;
      }
    });
    Object.defineProperty(exports, "useResolvedPath", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useResolvedPath;
      }
    });
    Object.defineProperty(exports, "useRevalidator", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useRevalidator;
      }
    });
    Object.defineProperty(exports, "useRouteError", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useRouteError;
      }
    });
    Object.defineProperty(exports, "useRouteLoaderData", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useRouteLoaderData;
      }
    });
    Object.defineProperty(exports, "useSearchParams", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useSearchParams;
      }
    });
    Object.defineProperty(exports, "useSubmit", {
      enumerable: !0,
      get: function() {
        return reactRouterDom.useSubmit;
      }
    });
    exports.Await = components.Await;
    exports.Link = components.Link;
    exports.Links = components.Links;
    exports.LiveReload = components.LiveReload;
    exports.Meta = components.Meta;
    exports.NavLink = components.NavLink;
    exports.PrefetchPageLinks = components.PrefetchPageLinks;
    exports.Scripts = components.Scripts;
    exports.UNSAFE_RemixContext = components.RemixContext;
    exports.useActionData = components.useActionData;
    exports.useFetcher = components.useFetcher;
    exports.useFetchers = components.useFetchers;
    exports.useLoaderData = components.useLoaderData;
    exports.useMatches = components.useMatches;
    exports.useTransition = components.useTransition;
    exports.useCatch = errorBoundaries.useCatch;
    exports.ScrollRestoration = scrollRestoration.ScrollRestoration;
    exports.RemixServer = server.RemixServer;
  }
});

// node_modules/react-dom/cjs/react-dom-server-legacy.node.production.min.js
var require_react_dom_server_legacy_node_production_min = __commonJS({
  "node_modules/react-dom/cjs/react-dom-server-legacy.node.production.min.js"(exports) {
    "use strict";
    var ea = require_react(), fa = require("stream"), n = Object.prototype.hasOwnProperty, ha = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, ia = {}, ja = {};
    function ka(a) {
      return n.call(ja, a) ? !0 : n.call(ia, a) ? !1 : ha.test(a) ? ja[a] = !0 : (ia[a] = !0, !1);
    }
    function q(a, b, c, d, f, e, g) {
      this.acceptsBooleans = b === 2 || b === 3 || b === 4, this.attributeName = d, this.attributeNamespace = f, this.mustUseProperty = c, this.propertyName = a, this.type = b, this.sanitizeURL = e, this.removeEmptyString = g;
    }
    var r = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
      r[a] = new q(a, 0, !1, a, null, !1, !1);
    });
    [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
      var b = a[0];
      r[b] = new q(b, 1, !1, a[1], null, !1, !1);
    });
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
      r[a] = new q(a, 2, !1, a.toLowerCase(), null, !1, !1);
    });
    ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
      r[a] = new q(a, 2, !1, a, null, !1, !1);
    });
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
      r[a] = new q(a, 3, !1, a.toLowerCase(), null, !1, !1);
    });
    ["checked", "multiple", "muted", "selected"].forEach(function(a) {
      r[a] = new q(a, 3, !0, a, null, !1, !1);
    });
    ["capture", "download"].forEach(function(a) {
      r[a] = new q(a, 4, !1, a, null, !1, !1);
    });
    ["cols", "rows", "size", "span"].forEach(function(a) {
      r[a] = new q(a, 6, !1, a, null, !1, !1);
    });
    ["rowSpan", "start"].forEach(function(a) {
      r[a] = new q(a, 5, !1, a.toLowerCase(), null, !1, !1);
    });
    var la = /[\-:]([a-z])/g;
    function ma(a) {
      return a[1].toUpperCase();
    }
    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
      var b = a.replace(
        la,
        ma
      );
      r[b] = new q(b, 1, !1, a, null, !1, !1);
    });
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
      var b = a.replace(la, ma);
      r[b] = new q(b, 1, !1, a, "http://www.w3.org/1999/xlink", !1, !1);
    });
    ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
      var b = a.replace(la, ma);
      r[b] = new q(b, 1, !1, a, "http://www.w3.org/XML/1998/namespace", !1, !1);
    });
    ["tabIndex", "crossOrigin"].forEach(function(a) {
      r[a] = new q(a, 1, !1, a.toLowerCase(), null, !1, !1);
    });
    r.xlinkHref = new q("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
    ["src", "href", "action", "formAction"].forEach(function(a) {
      r[a] = new q(a, 1, !1, a.toLowerCase(), null, !0, !0);
    });
    var t = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    }, na = ["Webkit", "ms", "Moz", "O"];
    Object.keys(t).forEach(function(a) {
      na.forEach(function(b) {
        b = b + a.charAt(0).toUpperCase() + a.substring(1), t[b] = t[a];
      });
    });
    var oa = /["'&<>]/;
    function u(a) {
      if (typeof a == "boolean" || typeof a == "number")
        return "" + a;
      a = "" + a;
      var b = oa.exec(a);
      if (b) {
        var c = "", d, f = 0;
        for (d = b.index; d < a.length; d++) {
          switch (a.charCodeAt(d)) {
            case 34:
              b = "&quot;";
              break;
            case 38:
              b = "&amp;";
              break;
            case 39:
              b = "&#x27;";
              break;
            case 60:
              b = "&lt;";
              break;
            case 62:
              b = "&gt;";
              break;
            default:
              continue;
          }
          f !== d && (c += a.substring(f, d)), f = d + 1, c += b;
        }
        a = f !== d ? c + a.substring(f, d) : c;
      }
      return a;
    }
    var pa = /([A-Z])/g, qa = /^ms-/, ra = Array.isArray;
    function v(a, b) {
      return { insertionMode: a, selectedValue: b };
    }
    function sa(a, b, c) {
      switch (b) {
        case "select":
          return v(1, c.value != null ? c.value : c.defaultValue);
        case "svg":
          return v(2, null);
        case "math":
          return v(3, null);
        case "foreignObject":
          return v(1, null);
        case "table":
          return v(4, null);
        case "thead":
        case "tbody":
        case "tfoot":
          return v(5, null);
        case "colgroup":
          return v(7, null);
        case "tr":
          return v(6, null);
      }
      return 4 <= a.insertionMode || a.insertionMode === 0 ? v(1, null) : a;
    }
    var ta = /* @__PURE__ */ new Map();
    function ua(a, b, c) {
      if (typeof c != "object")
        throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      b = !0;
      for (var d in c)
        if (n.call(c, d)) {
          var f = c[d];
          if (f != null && typeof f != "boolean" && f !== "") {
            if (d.indexOf("--") === 0) {
              var e = u(d);
              f = u(("" + f).trim());
            } else {
              e = d;
              var g = ta.get(e);
              g !== void 0 || (g = u(e.replace(pa, "-$1").toLowerCase().replace(qa, "-ms-")), ta.set(e, g)), e = g, f = typeof f == "number" ? f === 0 || n.call(
                t,
                d
              ) ? "" + f : f + "px" : u(("" + f).trim());
            }
            b ? (b = !1, a.push(' style="', e, ":", f)) : a.push(";", e, ":", f);
          }
        }
      b || a.push('"');
    }
    function w(a, b, c, d) {
      switch (c) {
        case "style":
          ua(a, b, d);
          return;
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
          return;
      }
      if (!(2 < c.length) || c[0] !== "o" && c[0] !== "O" || c[1] !== "n" && c[1] !== "N") {
        if (b = r.hasOwnProperty(c) ? r[c] : null, b !== null) {
          switch (typeof d) {
            case "function":
            case "symbol":
              return;
            case "boolean":
              if (!b.acceptsBooleans)
                return;
          }
          switch (c = b.attributeName, b.type) {
            case 3:
              d && a.push(" ", c, '=""');
              break;
            case 4:
              d === !0 ? a.push(" ", c, '=""') : d !== !1 && a.push(" ", c, '="', u(d), '"');
              break;
            case 5:
              isNaN(d) || a.push(" ", c, '="', u(d), '"');
              break;
            case 6:
              !isNaN(d) && 1 <= d && a.push(" ", c, '="', u(d), '"');
              break;
            default:
              b.sanitizeURL && (d = "" + d), a.push(" ", c, '="', u(d), '"');
          }
        } else if (ka(c)) {
          switch (typeof d) {
            case "function":
            case "symbol":
              return;
            case "boolean":
              if (b = c.toLowerCase().slice(0, 5), b !== "data-" && b !== "aria-")
                return;
          }
          a.push(" ", c, '="', u(d), '"');
        }
      }
    }
    function x(a, b, c) {
      if (b != null) {
        if (c != null)
          throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof b != "object" || !("__html" in b))
          throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        b = b.__html, b != null && a.push("" + b);
      }
    }
    function va(a) {
      var b = "";
      return ea.Children.forEach(a, function(a2) {
        a2 != null && (b += a2);
      }), b;
    }
    function wa(a, b, c, d) {
      a.push(z(c));
      var f = c = null, e;
      for (e in b)
        if (n.call(b, e)) {
          var g = b[e];
          if (g != null)
            switch (e) {
              case "children":
                c = g;
                break;
              case "dangerouslySetInnerHTML":
                f = g;
                break;
              default:
                w(a, d, e, g);
            }
        }
      return a.push(">"), x(a, f, c), typeof c == "string" ? (a.push(u(c)), null) : c;
    }
    var xa = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, ya = /* @__PURE__ */ new Map();
    function z(a) {
      var b = ya.get(a);
      if (b === void 0) {
        if (!xa.test(a))
          throw Error("Invalid tag: " + a);
        b = "<" + a, ya.set(a, b);
      }
      return b;
    }
    function za(a, b, c, d, f) {
      switch (b) {
        case "select":
          a.push(z("select"));
          var e = null, g = null;
          for (l in c)
            if (n.call(c, l)) {
              var h = c[l];
              if (h != null)
                switch (l) {
                  case "children":
                    e = h;
                    break;
                  case "dangerouslySetInnerHTML":
                    g = h;
                    break;
                  case "defaultValue":
                  case "value":
                    break;
                  default:
                    w(a, d, l, h);
                }
            }
          return a.push(">"), x(a, g, e), e;
        case "option":
          g = f.selectedValue, a.push(z("option"));
          var k = h = null, m = null, l = null;
          for (e in c)
            if (n.call(c, e)) {
              var p = c[e];
              if (p != null)
                switch (e) {
                  case "children":
                    h = p;
                    break;
                  case "selected":
                    m = p;
                    break;
                  case "dangerouslySetInnerHTML":
                    l = p;
                    break;
                  case "value":
                    k = p;
                  default:
                    w(a, d, e, p);
                }
            }
          if (g != null)
            if (c = k !== null ? "" + k : va(h), ra(g)) {
              for (d = 0; d < g.length; d++)
                if ("" + g[d] === c) {
                  a.push(' selected=""');
                  break;
                }
            } else
              "" + g === c && a.push(' selected=""');
          else
            m && a.push(' selected=""');
          return a.push(">"), x(a, l, h), h;
        case "textarea":
          a.push(z("textarea")), l = g = e = null;
          for (h in c)
            if (n.call(c, h) && (k = c[h], k != null))
              switch (h) {
                case "children":
                  l = k;
                  break;
                case "value":
                  e = k;
                  break;
                case "defaultValue":
                  g = k;
                  break;
                case "dangerouslySetInnerHTML":
                  throw Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
                default:
                  w(a, d, h, k);
              }
          if (e === null && g !== null && (e = g), a.push(">"), l != null) {
            if (e != null)
              throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            if (ra(l) && 1 < l.length)
              throw Error("<textarea> can only have at most one child.");
            e = "" + l;
          }
          return typeof e == "string" && e[0] === `
` && a.push(`
`), e !== null && a.push(u("" + e)), null;
        case "input":
          a.push(z("input")), k = l = h = e = null;
          for (g in c)
            if (n.call(c, g) && (m = c[g], m != null))
              switch (g) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                case "defaultChecked":
                  k = m;
                  break;
                case "defaultValue":
                  h = m;
                  break;
                case "checked":
                  l = m;
                  break;
                case "value":
                  e = m;
                  break;
                default:
                  w(a, d, g, m);
              }
          return l !== null ? w(a, d, "checked", l) : k !== null && w(a, d, "checked", k), e !== null ? w(a, d, "value", e) : h !== null && w(a, d, "value", h), a.push("/>"), null;
        case "menuitem":
          a.push(z("menuitem"));
          for (var B in c)
            if (n.call(c, B) && (e = c[B], e != null))
              switch (B) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
                default:
                  w(
                    a,
                    d,
                    B,
                    e
                  );
              }
          return a.push(">"), null;
        case "title":
          a.push(z("title")), e = null;
          for (p in c)
            if (n.call(c, p) && (g = c[p], g != null))
              switch (p) {
                case "children":
                  e = g;
                  break;
                case "dangerouslySetInnerHTML":
                  throw Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
                default:
                  w(a, d, p, g);
              }
          return a.push(">"), e;
        case "listing":
        case "pre":
          a.push(z(b)), g = e = null;
          for (k in c)
            if (n.call(c, k) && (h = c[k], h != null))
              switch (k) {
                case "children":
                  e = h;
                  break;
                case "dangerouslySetInnerHTML":
                  g = h;
                  break;
                default:
                  w(a, d, k, h);
              }
          if (a.push(">"), g != null) {
            if (e != null)
              throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
            if (typeof g != "object" || !("__html" in g))
              throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
            c = g.__html, c != null && (typeof c == "string" && 0 < c.length && c[0] === `
` ? a.push(`
`, c) : a.push("" + c));
          }
          return typeof e == "string" && e[0] === `
` && a.push(`
`), e;
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          a.push(z(b));
          for (var C in c)
            if (n.call(c, C) && (e = c[C], e != null))
              switch (C) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(b + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                default:
                  w(a, d, C, e);
              }
          return a.push("/>"), null;
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return wa(a, c, b, d);
        case "html":
          return f.insertionMode === 0 && a.push("<!DOCTYPE html>"), wa(a, c, b, d);
        default:
          if (b.indexOf("-") === -1 && typeof c.is != "string")
            return wa(a, c, b, d);
          a.push(z(b)), g = e = null;
          for (m in c)
            if (n.call(c, m) && (h = c[m], h != null))
              switch (m) {
                case "children":
                  e = h;
                  break;
                case "dangerouslySetInnerHTML":
                  g = h;
                  break;
                case "style":
                  ua(a, d, h);
                  break;
                case "suppressContentEditableWarning":
                case "suppressHydrationWarning":
                  break;
                default:
                  ka(m) && typeof h != "function" && typeof h != "symbol" && a.push(" ", m, '="', u(h), '"');
              }
          return a.push(">"), x(a, g, e), e;
      }
    }
    function Aa(a, b, c) {
      if (a.push('<!--$?--><template id="'), c === null)
        throw Error("An ID must have been assigned before we can complete the boundary.");
      return a.push(c), a.push('"></template>');
    }
    function Ba(a, b, c, d) {
      switch (c.insertionMode) {
        case 0:
        case 1:
          return a.push('<div hidden id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');
        case 2:
          return a.push('<svg aria-hidden="true" style="display:none" id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');
        case 3:
          return a.push('<math aria-hidden="true" style="display:none" id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');
        case 4:
          return a.push('<table hidden id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');
        case 5:
          return a.push('<table hidden><tbody id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');
        case 6:
          return a.push('<table hidden><tr id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');
        case 7:
          return a.push('<table hidden><colgroup id="'), a.push(b.segmentPrefix), b = d.toString(16), a.push(b), a.push('">');
        default:
          throw Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    function Ca(a, b) {
      switch (b.insertionMode) {
        case 0:
        case 1:
          return a.push("</div>");
        case 2:
          return a.push("</svg>");
        case 3:
          return a.push("</math>");
        case 4:
          return a.push("</table>");
        case 5:
          return a.push("</tbody></table>");
        case 6:
          return a.push("</tr></table>");
        case 7:
          return a.push("</colgroup></table>");
        default:
          throw Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    var Da = /[<\u2028\u2029]/g;
    function Ea(a) {
      return JSON.stringify(a).replace(Da, function(a2) {
        switch (a2) {
          case "<":
            return "\\u003c";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          default:
            throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
        }
      });
    }
    function Fa(a, b) {
      return b = b === void 0 ? "" : b, { bootstrapChunks: [], startInlineScript: "<script>", placeholderPrefix: b + "P:", segmentPrefix: b + "S:", boundaryPrefix: b + "B:", idPrefix: b, nextSuspenseID: 0, sentCompleteSegmentFunction: !1, sentCompleteBoundaryFunction: !1, sentClientRenderFunction: !1, generateStaticMarkup: a };
    }
    function Ga() {
      return { insertionMode: 1, selectedValue: null };
    }
    function Ha(a, b, c, d) {
      return c.generateStaticMarkup ? (a.push(u(b)), !1) : (b === "" ? a = d : (d && a.push("<!-- -->"), a.push(u(b)), a = !0), a);
    }
    var A = Object.assign, Ia = Symbol.for("react.element"), Ja = Symbol.for("react.portal"), Ka = Symbol.for("react.fragment"), La = Symbol.for("react.strict_mode"), Ma = Symbol.for("react.profiler"), Na = Symbol.for("react.provider"), Oa = Symbol.for("react.context"), Pa = Symbol.for("react.forward_ref"), Qa = Symbol.for("react.suspense"), Ra = Symbol.for("react.suspense_list"), Sa = Symbol.for("react.memo"), Ta = Symbol.for("react.lazy"), Ua = Symbol.for("react.scope"), Va = Symbol.for("react.debug_trace_mode"), Wa = Symbol.for("react.legacy_hidden"), Xa = Symbol.for("react.default_value"), Ya = Symbol.iterator;
    function Za(a) {
      if (a == null)
        return null;
      if (typeof a == "function")
        return a.displayName || a.name || null;
      if (typeof a == "string")
        return a;
      switch (a) {
        case Ka:
          return "Fragment";
        case Ja:
          return "Portal";
        case Ma:
          return "Profiler";
        case La:
          return "StrictMode";
        case Qa:
          return "Suspense";
        case Ra:
          return "SuspenseList";
      }
      if (typeof a == "object")
        switch (a.$$typeof) {
          case Oa:
            return (a.displayName || "Context") + ".Consumer";
          case Na:
            return (a._context.displayName || "Context") + ".Provider";
          case Pa:
            var b = a.render;
            return a = a.displayName, a || (a = b.displayName || b.name || "", a = a !== "" ? "ForwardRef(" + a + ")" : "ForwardRef"), a;
          case Sa:
            return b = a.displayName || null, b !== null ? b : Za(a.type) || "Memo";
          case Ta:
            b = a._payload, a = a._init;
            try {
              return Za(a(b));
            } catch {
            }
        }
      return null;
    }
    var $a = {};
    function ab(a, b) {
      if (a = a.contextTypes, !a)
        return $a;
      var c = {}, d;
      for (d in a)
        c[d] = b[d];
      return c;
    }
    var D = null;
    function E(a, b) {
      if (a !== b) {
        a.context._currentValue2 = a.parentValue, a = a.parent;
        var c = b.parent;
        if (a === null) {
          if (c !== null)
            throw Error("The stacks must reach the root at the same time. This is a bug in React.");
        } else {
          if (c === null)
            throw Error("The stacks must reach the root at the same time. This is a bug in React.");
          E(a, c);
        }
        b.context._currentValue2 = b.value;
      }
    }
    function bb(a) {
      a.context._currentValue2 = a.parentValue, a = a.parent, a !== null && bb(a);
    }
    function cb(a) {
      var b = a.parent;
      b !== null && cb(b), a.context._currentValue2 = a.value;
    }
    function db(a, b) {
      if (a.context._currentValue2 = a.parentValue, a = a.parent, a === null)
        throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      a.depth === b.depth ? E(a, b) : db(a, b);
    }
    function eb(a, b) {
      var c = b.parent;
      if (c === null)
        throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      a.depth === c.depth ? E(a, c) : eb(a, c), b.context._currentValue2 = b.value;
    }
    function F(a) {
      var b = D;
      b !== a && (b === null ? cb(a) : a === null ? bb(b) : b.depth === a.depth ? E(b, a) : b.depth > a.depth ? db(b, a) : eb(b, a), D = a);
    }
    var fb = { isMounted: function() {
      return !1;
    }, enqueueSetState: function(a, b) {
      a = a._reactInternals, a.queue !== null && a.queue.push(b);
    }, enqueueReplaceState: function(a, b) {
      a = a._reactInternals, a.replace = !0, a.queue = [b];
    }, enqueueForceUpdate: function() {
    } };
    function gb(a, b, c, d) {
      var f = a.state !== void 0 ? a.state : null;
      a.updater = fb, a.props = c, a.state = f;
      var e = { queue: [], replace: !1 };
      a._reactInternals = e;
      var g = b.contextType;
      if (a.context = typeof g == "object" && g !== null ? g._currentValue2 : d, g = b.getDerivedStateFromProps, typeof g == "function" && (g = g(c, f), f = g == null ? f : A({}, f, g), a.state = f), typeof b.getDerivedStateFromProps != "function" && typeof a.getSnapshotBeforeUpdate != "function" && (typeof a.UNSAFE_componentWillMount == "function" || typeof a.componentWillMount == "function"))
        if (b = a.state, typeof a.componentWillMount == "function" && a.componentWillMount(), typeof a.UNSAFE_componentWillMount == "function" && a.UNSAFE_componentWillMount(), b !== a.state && fb.enqueueReplaceState(a, a.state, null), e.queue !== null && 0 < e.queue.length)
          if (b = e.queue, g = e.replace, e.queue = null, e.replace = !1, g && b.length === 1)
            a.state = b[0];
          else {
            for (e = g ? b[0] : a.state, f = !0, g = g ? 1 : 0; g < b.length; g++) {
              var h = b[g];
              h = typeof h == "function" ? h.call(a, e, c, d) : h, h != null && (f ? (f = !1, e = A({}, e, h)) : A(e, h));
            }
            a.state = e;
          }
        else
          e.queue = null;
    }
    var hb = { id: 1, overflow: "" };
    function ib(a, b, c) {
      var d = a.id;
      a = a.overflow;
      var f = 32 - G(d) - 1;
      d &= ~(1 << f), c += 1;
      var e = 32 - G(b) + f;
      if (30 < e) {
        var g = f - f % 5;
        return e = (d & (1 << g) - 1).toString(32), d >>= g, f -= g, { id: 1 << 32 - G(b) + f | c << f | d, overflow: e + a };
      }
      return { id: 1 << e | c << f | d, overflow: a };
    }
    var G = Math.clz32 ? Math.clz32 : jb, kb = Math.log, lb = Math.LN2;
    function jb(a) {
      return a >>>= 0, a === 0 ? 32 : 31 - (kb(a) / lb | 0) | 0;
    }
    function mb(a, b) {
      return a === b && (a !== 0 || 1 / a === 1 / b) || a !== a && b !== b;
    }
    var nb = typeof Object.is == "function" ? Object.is : mb, H = null, ob = null, I = null, J = null, K = !1, L = !1, M = 0, N = null, O = 0;
    function P() {
      if (H === null)
        throw Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
      return H;
    }
    function rb() {
      if (0 < O)
        throw Error("Rendered more hooks than during the previous render");
      return { memoizedState: null, queue: null, next: null };
    }
    function sb() {
      return J === null ? I === null ? (K = !1, I = J = rb()) : (K = !0, J = I) : J.next === null ? (K = !1, J = J.next = rb()) : (K = !0, J = J.next), J;
    }
    function tb() {
      ob = H = null, L = !1, I = null, O = 0, J = N = null;
    }
    function ub(a, b) {
      return typeof b == "function" ? b(a) : b;
    }
    function vb(a, b, c) {
      if (H = P(), J = sb(), K) {
        var d = J.queue;
        if (b = d.dispatch, N !== null && (c = N.get(d), c !== void 0)) {
          N.delete(d), d = J.memoizedState;
          do
            d = a(d, c.action), c = c.next;
          while (c !== null);
          return J.memoizedState = d, [d, b];
        }
        return [J.memoizedState, b];
      }
      return a = a === ub ? typeof b == "function" ? b() : b : c !== void 0 ? c(b) : b, J.memoizedState = a, a = J.queue = { last: null, dispatch: null }, a = a.dispatch = wb.bind(null, H, a), [J.memoizedState, a];
    }
    function xb(a, b) {
      if (H = P(), J = sb(), b = b === void 0 ? null : b, J !== null) {
        var c = J.memoizedState;
        if (c !== null && b !== null) {
          var d = c[1];
          a:
            if (d === null)
              d = !1;
            else {
              for (var f = 0; f < d.length && f < b.length; f++)
                if (!nb(b[f], d[f])) {
                  d = !1;
                  break a;
                }
              d = !0;
            }
          if (d)
            return c[0];
        }
      }
      return a = a(), J.memoizedState = [a, b], a;
    }
    function wb(a, b, c) {
      if (25 <= O)
        throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
      if (a === H)
        if (L = !0, a = { action: c, next: null }, N === null && (N = /* @__PURE__ */ new Map()), c = N.get(b), c === void 0)
          N.set(b, a);
        else {
          for (b = c; b.next !== null; )
            b = b.next;
          b.next = a;
        }
    }
    function yb() {
      throw Error("startTransition cannot be called during server rendering.");
    }
    function Q() {
    }
    var zb = { readContext: function(a) {
      return a._currentValue2;
    }, useContext: function(a) {
      return P(), a._currentValue2;
    }, useMemo: xb, useReducer: vb, useRef: function(a) {
      H = P(), J = sb();
      var b = J.memoizedState;
      return b === null ? (a = { current: a }, J.memoizedState = a) : b;
    }, useState: function(a) {
      return vb(ub, a);
    }, useInsertionEffect: Q, useLayoutEffect: function() {
    }, useCallback: function(a, b) {
      return xb(function() {
        return a;
      }, b);
    }, useImperativeHandle: Q, useEffect: Q, useDebugValue: Q, useDeferredValue: function(a) {
      return P(), a;
    }, useTransition: function() {
      return P(), [!1, yb];
    }, useId: function() {
      var a = ob.treeContext, b = a.overflow;
      a = a.id, a = (a & ~(1 << 32 - G(a) - 1)).toString(32) + b;
      var c = R;
      if (c === null)
        throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
      return b = M++, a = ":" + c.idPrefix + "R" + a, 0 < b && (a += "H" + b.toString(32)), a + ":";
    }, useMutableSource: function(a, b) {
      return P(), b(a._source);
    }, useSyncExternalStore: function(a, b, c) {
      if (c === void 0)
        throw Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
      return c();
    } }, R = null, Ab = ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
    function Bb(a) {
      return console.error(a), null;
    }
    function S() {
    }
    function Cb(a, b, c, d, f, e, g, h, k) {
      var m = [], l = /* @__PURE__ */ new Set();
      return b = { destination: null, responseState: b, progressiveChunkSize: d === void 0 ? 12800 : d, status: 0, fatalError: null, nextSegmentId: 0, allPendingTasks: 0, pendingRootTasks: 0, completedRootSegment: null, abortableTasks: l, pingedTasks: m, clientRenderedBoundaries: [], completedBoundaries: [], partialBoundaries: [], onError: f === void 0 ? Bb : f, onAllReady: e === void 0 ? S : e, onShellReady: g === void 0 ? S : g, onShellError: h === void 0 ? S : h, onFatalError: k === void 0 ? S : k }, c = T(b, 0, null, c, !1, !1), c.parentFlushed = !0, a = Db(b, a, null, c, l, $a, null, hb), m.push(a), b;
    }
    function Db(a, b, c, d, f, e, g, h) {
      a.allPendingTasks++, c === null ? a.pendingRootTasks++ : c.pendingTasks++;
      var k = { node: b, ping: function() {
        var b2 = a.pingedTasks;
        b2.push(k), b2.length === 1 && Eb(a);
      }, blockedBoundary: c, blockedSegment: d, abortSet: f, legacyContext: e, context: g, treeContext: h };
      return f.add(k), k;
    }
    function T(a, b, c, d, f, e) {
      return { status: 0, id: -1, index: b, parentFlushed: !1, chunks: [], children: [], formatContext: d, boundary: c, lastPushedText: f, textEmbedded: e };
    }
    function U(a, b) {
      if (a = a.onError(b), a != null && typeof a != "string")
        throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof a + '" instead');
      return a;
    }
    function V(a, b) {
      var c = a.onShellError;
      c(b), c = a.onFatalError, c(b), a.destination !== null ? (a.status = 2, a.destination.destroy(b)) : (a.status = 1, a.fatalError = b);
    }
    function Fb(a, b, c, d, f) {
      for (H = {}, ob = b, M = 0, a = c(d, f); L; )
        L = !1, M = 0, O += 1, J = null, a = c(d, f);
      return tb(), a;
    }
    function Gb(a, b, c, d) {
      var f = c.render(), e = d.childContextTypes;
      if (e != null) {
        var g = b.legacyContext;
        if (typeof c.getChildContext != "function")
          d = g;
        else {
          c = c.getChildContext();
          for (var h in c)
            if (!(h in e))
              throw Error((Za(d) || "Unknown") + '.getChildContext(): key "' + h + '" is not defined in childContextTypes.');
          d = A({}, g, c);
        }
        b.legacyContext = d, W(a, b, f), b.legacyContext = g;
      } else
        W(a, b, f);
    }
    function Hb(a, b) {
      if (a && a.defaultProps) {
        b = A({}, b), a = a.defaultProps;
        for (var c in a)
          b[c] === void 0 && (b[c] = a[c]);
        return b;
      }
      return b;
    }
    function Ib(a, b, c, d, f) {
      if (typeof c == "function")
        if (c.prototype && c.prototype.isReactComponent) {
          f = ab(c, b.legacyContext);
          var e = c.contextType;
          e = new c(d, typeof e == "object" && e !== null ? e._currentValue2 : f), gb(e, c, d, f), Gb(a, b, e, c);
        } else {
          e = ab(c, b.legacyContext), f = Fb(a, b, c, d, e);
          var g = M !== 0;
          if (typeof f == "object" && f !== null && typeof f.render == "function" && f.$$typeof === void 0)
            gb(f, c, d, e), Gb(a, b, f, c);
          else if (g) {
            d = b.treeContext, b.treeContext = ib(d, 1, 0);
            try {
              W(a, b, f);
            } finally {
              b.treeContext = d;
            }
          } else
            W(a, b, f);
        }
      else if (typeof c == "string") {
        switch (f = b.blockedSegment, e = za(f.chunks, c, d, a.responseState, f.formatContext), f.lastPushedText = !1, g = f.formatContext, f.formatContext = sa(g, c, d), Jb(a, b, e), f.formatContext = g, c) {
          case "area":
          case "base":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "img":
          case "input":
          case "keygen":
          case "link":
          case "meta":
          case "param":
          case "source":
          case "track":
          case "wbr":
            break;
          default:
            f.chunks.push("</", c, ">");
        }
        f.lastPushedText = !1;
      } else {
        switch (c) {
          case Wa:
          case Va:
          case La:
          case Ma:
          case Ka:
            W(a, b, d.children);
            return;
          case Ra:
            W(a, b, d.children);
            return;
          case Ua:
            throw Error("ReactDOMServer does not yet support scope components.");
          case Qa:
            a: {
              c = b.blockedBoundary, f = b.blockedSegment, e = d.fallback, d = d.children, g = /* @__PURE__ */ new Set();
              var h = { id: null, rootSegmentID: -1, parentFlushed: !1, pendingTasks: 0, forceClientRender: !1, completedSegments: [], byteSize: 0, fallbackAbortableTasks: g, errorDigest: null }, k = T(a, f.chunks.length, h, f.formatContext, !1, !1);
              f.children.push(k), f.lastPushedText = !1;
              var m = T(a, 0, null, f.formatContext, !1, !1);
              m.parentFlushed = !0, b.blockedBoundary = h, b.blockedSegment = m;
              try {
                if (Jb(a, b, d), a.responseState.generateStaticMarkup || m.lastPushedText && m.textEmbedded && m.chunks.push("<!-- -->"), m.status = 1, X(h, m), h.pendingTasks === 0)
                  break a;
              } catch (l) {
                m.status = 4, h.forceClientRender = !0, h.errorDigest = U(a, l);
              } finally {
                b.blockedBoundary = c, b.blockedSegment = f;
              }
              b = Db(a, e, c, k, g, b.legacyContext, b.context, b.treeContext), a.pingedTasks.push(b);
            }
            return;
        }
        if (typeof c == "object" && c !== null)
          switch (c.$$typeof) {
            case Pa:
              if (d = Fb(a, b, c.render, d, f), M !== 0) {
                c = b.treeContext, b.treeContext = ib(c, 1, 0);
                try {
                  W(a, b, d);
                } finally {
                  b.treeContext = c;
                }
              } else
                W(a, b, d);
              return;
            case Sa:
              c = c.type, d = Hb(c, d), Ib(a, b, c, d, f);
              return;
            case Na:
              if (f = d.children, c = c._context, d = d.value, e = c._currentValue2, c._currentValue2 = d, g = D, D = d = { parent: g, depth: g === null ? 0 : g.depth + 1, context: c, parentValue: e, value: d }, b.context = d, W(a, b, f), a = D, a === null)
                throw Error("Tried to pop a Context at the root of the app. This is a bug in React.");
              d = a.parentValue, a.context._currentValue2 = d === Xa ? a.context._defaultValue : d, a = D = a.parent, b.context = a;
              return;
            case Oa:
              d = d.children, d = d(c._currentValue2), W(a, b, d);
              return;
            case Ta:
              f = c._init, c = f(c._payload), d = Hb(c, d), Ib(a, b, c, d, void 0);
              return;
          }
        throw Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + ((c == null ? c : typeof c) + "."));
      }
    }
    function W(a, b, c) {
      if (b.node = c, typeof c == "object" && c !== null) {
        switch (c.$$typeof) {
          case Ia:
            Ib(a, b, c.type, c.props, c.ref);
            return;
          case Ja:
            throw Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
          case Ta:
            var d = c._init;
            c = d(c._payload), W(a, b, c);
            return;
        }
        if (ra(c)) {
          Kb(a, b, c);
          return;
        }
        if (c === null || typeof c != "object" ? d = null : (d = Ya && c[Ya] || c["@@iterator"], d = typeof d == "function" ? d : null), d && (d = d.call(c))) {
          if (c = d.next(), !c.done) {
            var f = [];
            do
              f.push(c.value), c = d.next();
            while (!c.done);
            Kb(a, b, f);
          }
          return;
        }
        throw a = Object.prototype.toString.call(c), Error("Objects are not valid as a React child (found: " + (a === "[object Object]" ? "object with keys {" + Object.keys(c).join(", ") + "}" : a) + "). If you meant to render a collection of children, use an array instead.");
      }
      typeof c == "string" ? (d = b.blockedSegment, d.lastPushedText = Ha(b.blockedSegment.chunks, c, a.responseState, d.lastPushedText)) : typeof c == "number" && (d = b.blockedSegment, d.lastPushedText = Ha(
        b.blockedSegment.chunks,
        "" + c,
        a.responseState,
        d.lastPushedText
      ));
    }
    function Kb(a, b, c) {
      for (var d = c.length, f = 0; f < d; f++) {
        var e = b.treeContext;
        b.treeContext = ib(e, d, f);
        try {
          Jb(a, b, c[f]);
        } finally {
          b.treeContext = e;
        }
      }
    }
    function Jb(a, b, c) {
      var d = b.blockedSegment.formatContext, f = b.legacyContext, e = b.context;
      try {
        return W(a, b, c);
      } catch (k) {
        if (tb(), typeof k == "object" && k !== null && typeof k.then == "function") {
          c = k;
          var g = b.blockedSegment, h = T(a, g.chunks.length, null, g.formatContext, g.lastPushedText, !0);
          g.children.push(h), g.lastPushedText = !1, a = Db(a, b.node, b.blockedBoundary, h, b.abortSet, b.legacyContext, b.context, b.treeContext).ping, c.then(a, a), b.blockedSegment.formatContext = d, b.legacyContext = f, b.context = e, F(e);
        } else
          throw b.blockedSegment.formatContext = d, b.legacyContext = f, b.context = e, F(e), k;
      }
    }
    function Lb(a) {
      var b = a.blockedBoundary;
      a = a.blockedSegment, a.status = 3, Mb(this, b, a);
    }
    function Nb(a, b, c) {
      var d = a.blockedBoundary;
      a.blockedSegment.status = 3, d === null ? (b.allPendingTasks--, b.status !== 2 && (b.status = 2, b.destination !== null && b.destination.push(null))) : (d.pendingTasks--, d.forceClientRender || (d.forceClientRender = !0, d.errorDigest = b.onError(c === void 0 ? Error("The render was aborted by the server without a reason.") : c), d.parentFlushed && b.clientRenderedBoundaries.push(d)), d.fallbackAbortableTasks.forEach(function(a2) {
        return Nb(a2, b, c);
      }), d.fallbackAbortableTasks.clear(), b.allPendingTasks--, b.allPendingTasks === 0 && (a = b.onAllReady, a()));
    }
    function X(a, b) {
      if (b.chunks.length === 0 && b.children.length === 1 && b.children[0].boundary === null) {
        var c = b.children[0];
        c.id = b.id, c.parentFlushed = !0, c.status === 1 && X(a, c);
      } else
        a.completedSegments.push(b);
    }
    function Mb(a, b, c) {
      if (b === null) {
        if (c.parentFlushed) {
          if (a.completedRootSegment !== null)
            throw Error("There can only be one root segment. This is a bug in React.");
          a.completedRootSegment = c;
        }
        a.pendingRootTasks--, a.pendingRootTasks === 0 && (a.onShellError = S, b = a.onShellReady, b());
      } else
        b.pendingTasks--, b.forceClientRender || (b.pendingTasks === 0 ? (c.parentFlushed && c.status === 1 && X(b, c), b.parentFlushed && a.completedBoundaries.push(b), b.fallbackAbortableTasks.forEach(Lb, a), b.fallbackAbortableTasks.clear()) : c.parentFlushed && c.status === 1 && (X(b, c), b.completedSegments.length === 1 && b.parentFlushed && a.partialBoundaries.push(b)));
      a.allPendingTasks--, a.allPendingTasks === 0 && (a = a.onAllReady, a());
    }
    function Eb(a) {
      if (a.status !== 2) {
        var b = D, c = Ab.current;
        Ab.current = zb;
        var d = R;
        R = a.responseState;
        try {
          var f = a.pingedTasks, e;
          for (e = 0; e < f.length; e++) {
            var g = f[e], h = a, k = g.blockedSegment;
            if (k.status === 0) {
              F(g.context);
              try {
                W(h, g, g.node), h.responseState.generateStaticMarkup || k.lastPushedText && k.textEmbedded && k.chunks.push("<!-- -->"), g.abortSet.delete(g), k.status = 1, Mb(h, g.blockedBoundary, k);
              } catch (y) {
                if (tb(), typeof y == "object" && y !== null && typeof y.then == "function") {
                  var m = g.ping;
                  y.then(m, m);
                } else {
                  g.abortSet.delete(g), k.status = 4;
                  var l = g.blockedBoundary, p = y, B = U(h, p);
                  if (l === null ? V(h, p) : (l.pendingTasks--, l.forceClientRender || (l.forceClientRender = !0, l.errorDigest = B, l.parentFlushed && h.clientRenderedBoundaries.push(l))), h.allPendingTasks--, h.allPendingTasks === 0) {
                    var C = h.onAllReady;
                    C();
                  }
                }
              } finally {
              }
            }
          }
          f.splice(0, e), a.destination !== null && Ob(a, a.destination);
        } catch (y) {
          U(a, y), V(a, y);
        } finally {
          R = d, Ab.current = c, c === zb && F(b);
        }
      }
    }
    function Y(a, b, c) {
      switch (c.parentFlushed = !0, c.status) {
        case 0:
          var d = c.id = a.nextSegmentId++;
          return c.lastPushedText = !1, c.textEmbedded = !1, a = a.responseState, b.push('<template id="'), b.push(a.placeholderPrefix), a = d.toString(16), b.push(a), b.push('"></template>');
        case 1:
          c.status = 2;
          var f = !0;
          d = c.chunks;
          var e = 0;
          c = c.children;
          for (var g = 0; g < c.length; g++) {
            for (f = c[g]; e < f.index; e++)
              b.push(d[e]);
            f = Z(a, b, f);
          }
          for (; e < d.length - 1; e++)
            b.push(d[e]);
          return e < d.length && (f = b.push(d[e])), f;
        default:
          throw Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
      }
    }
    function Z(a, b, c) {
      var d = c.boundary;
      if (d === null)
        return Y(a, b, c);
      if (d.parentFlushed = !0, d.forceClientRender)
        return a.responseState.generateStaticMarkup || (d = d.errorDigest, b.push("<!--$!-->"), b.push("<template"), d && (b.push(' data-dgst="'), d = u(d), b.push(d), b.push('"')), b.push("></template>")), Y(a, b, c), a = a.responseState.generateStaticMarkup ? !0 : b.push("<!--/$-->"), a;
      if (0 < d.pendingTasks) {
        d.rootSegmentID = a.nextSegmentId++, 0 < d.completedSegments.length && a.partialBoundaries.push(d);
        var f = a.responseState, e = f.nextSuspenseID++;
        return f = f.boundaryPrefix + e.toString(16), d = d.id = f, Aa(b, a.responseState, d), Y(a, b, c), b.push("<!--/$-->");
      }
      if (d.byteSize > a.progressiveChunkSize)
        return d.rootSegmentID = a.nextSegmentId++, a.completedBoundaries.push(d), Aa(b, a.responseState, d.id), Y(a, b, c), b.push("<!--/$-->");
      if (a.responseState.generateStaticMarkup || b.push("<!--$-->"), c = d.completedSegments, c.length !== 1)
        throw Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
      return Z(a, b, c[0]), a = a.responseState.generateStaticMarkup ? !0 : b.push("<!--/$-->"), a;
    }
    function Pb(a, b, c) {
      return Ba(b, a.responseState, c.formatContext, c.id), Z(a, b, c), Ca(b, c.formatContext);
    }
    function Qb(a, b, c) {
      for (var d = c.completedSegments, f = 0; f < d.length; f++)
        Rb(a, b, c, d[f]);
      if (d.length = 0, a = a.responseState, d = c.id, c = c.rootSegmentID, b.push(a.startInlineScript), a.sentCompleteBoundaryFunction ? b.push('$RC("') : (a.sentCompleteBoundaryFunction = !0, b.push('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("')), d === null)
        throw Error("An ID must have been assigned before we can complete the boundary.");
      return c = c.toString(16), b.push(d), b.push('","'), b.push(a.segmentPrefix), b.push(c), b.push('")</script>');
    }
    function Rb(a, b, c, d) {
      if (d.status === 2)
        return !0;
      var f = d.id;
      if (f === -1) {
        if ((d.id = c.rootSegmentID) === -1)
          throw Error("A root segment ID must have been assigned by now. This is a bug in React.");
        return Pb(a, b, d);
      }
      return Pb(a, b, d), a = a.responseState, b.push(a.startInlineScript), a.sentCompleteSegmentFunction ? b.push('$RS("') : (a.sentCompleteSegmentFunction = !0, b.push('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("')), b.push(a.segmentPrefix), f = f.toString(16), b.push(f), b.push('","'), b.push(a.placeholderPrefix), b.push(f), b.push('")</script>');
    }
    function Ob(a, b) {
      try {
        var c = a.completedRootSegment;
        if (c !== null && a.pendingRootTasks === 0) {
          Z(a, b, c), a.completedRootSegment = null;
          var d = a.responseState.bootstrapChunks;
          for (c = 0; c < d.length - 1; c++)
            b.push(d[c]);
          c < d.length && b.push(d[c]);
        }
        var f = a.clientRenderedBoundaries, e;
        for (e = 0; e < f.length; e++) {
          var g = f[e];
          d = b;
          var h = a.responseState, k = g.id, m = g.errorDigest, l = g.errorMessage, p = g.errorComponentStack;
          if (d.push(h.startInlineScript), h.sentClientRenderFunction ? d.push('$RX("') : (h.sentClientRenderFunction = !0, d.push('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("')), k === null)
            throw Error("An ID must have been assigned before we can complete the boundary.");
          if (d.push(k), d.push('"'), m || l || p) {
            d.push(",");
            var B = Ea(m || "");
            d.push(B);
          }
          if (l || p) {
            d.push(",");
            var C = Ea(l || "");
            d.push(C);
          }
          if (p) {
            d.push(",");
            var y = Ea(p);
            d.push(y);
          }
          if (!d.push(")</script>")) {
            a.destination = null, e++, f.splice(0, e);
            return;
          }
        }
        f.splice(0, e);
        var aa = a.completedBoundaries;
        for (e = 0; e < aa.length; e++)
          if (!Qb(a, b, aa[e])) {
            a.destination = null, e++, aa.splice(0, e);
            return;
          }
        aa.splice(0, e);
        var ba = a.partialBoundaries;
        for (e = 0; e < ba.length; e++) {
          var pb = ba[e];
          a: {
            f = a, g = b;
            var ca = pb.completedSegments;
            for (h = 0; h < ca.length; h++)
              if (!Rb(f, g, pb, ca[h])) {
                h++, ca.splice(0, h);
                var qb = !1;
                break a;
              }
            ca.splice(0, h), qb = !0;
          }
          if (!qb) {
            a.destination = null, e++, ba.splice(0, e);
            return;
          }
        }
        ba.splice(0, e);
        var da = a.completedBoundaries;
        for (e = 0; e < da.length; e++)
          if (!Qb(a, b, da[e])) {
            a.destination = null, e++, da.splice(0, e);
            return;
          }
        da.splice(0, e);
      } finally {
        a.allPendingTasks === 0 && a.pingedTasks.length === 0 && a.clientRenderedBoundaries.length === 0 && a.completedBoundaries.length === 0 && b.push(null);
      }
    }
    function Sb(a, b) {
      if (a.status === 1)
        a.status = 2, b.destroy(a.fatalError);
      else if (a.status !== 2 && a.destination === null) {
        a.destination = b;
        try {
          Ob(a, b);
        } catch (c) {
          U(a, c), V(a, c);
        }
      }
    }
    function Tb(a, b) {
      try {
        var c = a.abortableTasks;
        c.forEach(function(c2) {
          return Nb(c2, a, b);
        }), c.clear(), a.destination !== null && Ob(a, a.destination);
      } catch (d) {
        U(a, d), V(a, d);
      }
    }
    function Ub() {
    }
    function Vb(a, b, c, d) {
      var f = !1, e = null, g = "", h = !1;
      if (a = Cb(a, Fa(c, b ? b.identifierPrefix : void 0), Ga(), 1 / 0, Ub, void 0, function() {
        h = !0;
      }, void 0, void 0), Eb(a), Tb(a, d), Sb(a, { push: function(a2) {
        return a2 !== null && (g += a2), !0;
      }, destroy: function(a2) {
        f = !0, e = a2;
      } }), f)
        throw e;
      if (!h)
        throw Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
      return g;
    }
    function Wb(a, b) {
      a.prototype = Object.create(b.prototype), a.prototype.constructor = a, a.__proto__ = b;
    }
    var Xb = function(a) {
      function b() {
        var b2 = a.call(this, {}) || this;
        return b2.request = null, b2.startedFlowing = !1, b2;
      }
      Wb(b, a);
      var c = b.prototype;
      return c._destroy = function(a2, b2) {
        Tb(this.request), b2(a2);
      }, c._read = function() {
        this.startedFlowing && Sb(this.request, this);
      }, b;
    }(fa.Readable);
    function Yb() {
    }
    function Zb(a, b) {
      var c = new Xb(), d = Cb(a, Fa(!1, b ? b.identifierPrefix : void 0), Ga(), 1 / 0, Yb, function() {
        c.startedFlowing = !0, Sb(d, c);
      }, void 0, void 0);
      return c.request = d, Eb(d), c;
    }
    exports.renderToNodeStream = function(a, b) {
      return Zb(a, b);
    };
    exports.renderToStaticMarkup = function(a, b) {
      return Vb(a, b, !0, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToPipeableStream" which supports Suspense on the server');
    };
    exports.renderToStaticNodeStream = function(a, b) {
      return Zb(a, b);
    };
    exports.renderToString = function(a, b) {
      return Vb(a, b, !1, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToPipeableStream" which supports Suspense on the server');
    };
    exports.version = "18.2.0";
  }
});

// node_modules/react-dom/cjs/react-dom-server.node.production.min.js
var require_react_dom_server_node_production_min = __commonJS({
  "node_modules/react-dom/cjs/react-dom-server.node.production.min.js"(exports) {
    "use strict";
    var aa = require("util"), ba = require_react(), k = null, l = 0, q = !0;
    function r(a, b) {
      if (typeof b == "string") {
        if (b.length !== 0)
          if (2048 < 3 * b.length)
            0 < l && (t(a, k.subarray(0, l)), k = new Uint8Array(2048), l = 0), t(a, u.encode(b));
          else {
            var c = k;
            0 < l && (c = k.subarray(l)), c = u.encodeInto(b, c);
            var d = c.read;
            l += c.written, d < b.length && (t(a, k), k = new Uint8Array(2048), l = u.encodeInto(b.slice(d), k).written), l === 2048 && (t(a, k), k = new Uint8Array(2048), l = 0);
          }
      } else
        b.byteLength !== 0 && (2048 < b.byteLength ? (0 < l && (t(a, k.subarray(0, l)), k = new Uint8Array(2048), l = 0), t(a, b)) : (c = k.length - l, c < b.byteLength && (c === 0 ? t(
          a,
          k
        ) : (k.set(b.subarray(0, c), l), l += c, t(a, k), b = b.subarray(c)), k = new Uint8Array(2048), l = 0), k.set(b, l), l += b.byteLength, l === 2048 && (t(a, k), k = new Uint8Array(2048), l = 0)));
    }
    function t(a, b) {
      a = a.write(b), q = q && a;
    }
    function w(a, b) {
      return r(a, b), q;
    }
    function ca(a) {
      k && 0 < l && a.write(k.subarray(0, l)), k = null, l = 0, q = !0;
    }
    var u = new aa.TextEncoder();
    function x(a) {
      return u.encode(a);
    }
    var y = Object.prototype.hasOwnProperty, da = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, ea = {}, fa = {};
    function ha(a) {
      return y.call(fa, a) ? !0 : y.call(ea, a) ? !1 : da.test(a) ? fa[a] = !0 : (ea[a] = !0, !1);
    }
    function z(a, b, c, d, f, e, g) {
      this.acceptsBooleans = b === 2 || b === 3 || b === 4, this.attributeName = d, this.attributeNamespace = f, this.mustUseProperty = c, this.propertyName = a, this.type = b, this.sanitizeURL = e, this.removeEmptyString = g;
    }
    var A = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
      A[a] = new z(a, 0, !1, a, null, !1, !1);
    });
    [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
      var b = a[0];
      A[b] = new z(b, 1, !1, a[1], null, !1, !1);
    });
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
      A[a] = new z(a, 2, !1, a.toLowerCase(), null, !1, !1);
    });
    ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
      A[a] = new z(a, 2, !1, a, null, !1, !1);
    });
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
      A[a] = new z(a, 3, !1, a.toLowerCase(), null, !1, !1);
    });
    ["checked", "multiple", "muted", "selected"].forEach(function(a) {
      A[a] = new z(a, 3, !0, a, null, !1, !1);
    });
    ["capture", "download"].forEach(function(a) {
      A[a] = new z(a, 4, !1, a, null, !1, !1);
    });
    ["cols", "rows", "size", "span"].forEach(function(a) {
      A[a] = new z(a, 6, !1, a, null, !1, !1);
    });
    ["rowSpan", "start"].forEach(function(a) {
      A[a] = new z(a, 5, !1, a.toLowerCase(), null, !1, !1);
    });
    var ia = /[\-:]([a-z])/g;
    function ja(a) {
      return a[1].toUpperCase();
    }
    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
      var b = a.replace(
        ia,
        ja
      );
      A[b] = new z(b, 1, !1, a, null, !1, !1);
    });
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
      var b = a.replace(ia, ja);
      A[b] = new z(b, 1, !1, a, "http://www.w3.org/1999/xlink", !1, !1);
    });
    ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
      var b = a.replace(ia, ja);
      A[b] = new z(b, 1, !1, a, "http://www.w3.org/XML/1998/namespace", !1, !1);
    });
    ["tabIndex", "crossOrigin"].forEach(function(a) {
      A[a] = new z(a, 1, !1, a.toLowerCase(), null, !1, !1);
    });
    A.xlinkHref = new z("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
    ["src", "href", "action", "formAction"].forEach(function(a) {
      A[a] = new z(a, 1, !1, a.toLowerCase(), null, !0, !0);
    });
    var B = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    }, ka = ["Webkit", "ms", "Moz", "O"];
    Object.keys(B).forEach(function(a) {
      ka.forEach(function(b) {
        b = b + a.charAt(0).toUpperCase() + a.substring(1), B[b] = B[a];
      });
    });
    var la = /["'&<>]/;
    function F(a) {
      if (typeof a == "boolean" || typeof a == "number")
        return "" + a;
      a = "" + a;
      var b = la.exec(a);
      if (b) {
        var c = "", d, f = 0;
        for (d = b.index; d < a.length; d++) {
          switch (a.charCodeAt(d)) {
            case 34:
              b = "&quot;";
              break;
            case 38:
              b = "&amp;";
              break;
            case 39:
              b = "&#x27;";
              break;
            case 60:
              b = "&lt;";
              break;
            case 62:
              b = "&gt;";
              break;
            default:
              continue;
          }
          f !== d && (c += a.substring(f, d)), f = d + 1, c += b;
        }
        a = f !== d ? c + a.substring(f, d) : c;
      }
      return a;
    }
    var ma = /([A-Z])/g, pa = /^ms-/, qa = Array.isArray, ra = x("<script>"), sa = x("</script>"), ta = x('<script src="'), ua = x('<script type="module" src="'), va = x('" async=""></script>'), wa = /(<\/|<)(s)(cript)/gi;
    function xa(a, b, c, d) {
      return "" + b + (c === "s" ? "\\u0073" : "\\u0053") + d;
    }
    function G(a, b) {
      return { insertionMode: a, selectedValue: b };
    }
    function ya(a, b, c) {
      switch (b) {
        case "select":
          return G(1, c.value != null ? c.value : c.defaultValue);
        case "svg":
          return G(2, null);
        case "math":
          return G(3, null);
        case "foreignObject":
          return G(1, null);
        case "table":
          return G(4, null);
        case "thead":
        case "tbody":
        case "tfoot":
          return G(5, null);
        case "colgroup":
          return G(7, null);
        case "tr":
          return G(6, null);
      }
      return 4 <= a.insertionMode || a.insertionMode === 0 ? G(1, null) : a;
    }
    var za = x("<!-- -->");
    function Aa(a, b, c, d) {
      return b === "" ? d : (d && a.push(za), a.push(F(b)), !0);
    }
    var Ba = /* @__PURE__ */ new Map(), Ca = x(' style="'), Da = x(":"), Ea = x(";");
    function Fa(a, b, c) {
      if (typeof c != "object")
        throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      b = !0;
      for (var d in c)
        if (y.call(c, d)) {
          var f = c[d];
          if (f != null && typeof f != "boolean" && f !== "") {
            if (d.indexOf("--") === 0) {
              var e = F(d);
              f = F(("" + f).trim());
            } else {
              e = d;
              var g = Ba.get(e);
              g !== void 0 || (g = x(F(e.replace(ma, "-$1").toLowerCase().replace(pa, "-ms-"))), Ba.set(e, g)), e = g, f = typeof f == "number" ? f === 0 || y.call(
                B,
                d
              ) ? "" + f : f + "px" : F(("" + f).trim());
            }
            b ? (b = !1, a.push(Ca, e, Da, f)) : a.push(Ea, e, Da, f);
          }
        }
      b || a.push(H);
    }
    var I = x(" "), J = x('="'), H = x('"'), Ga = x('=""');
    function K(a, b, c, d) {
      switch (c) {
        case "style":
          Fa(a, b, d);
          return;
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
          return;
      }
      if (!(2 < c.length) || c[0] !== "o" && c[0] !== "O" || c[1] !== "n" && c[1] !== "N") {
        if (b = A.hasOwnProperty(c) ? A[c] : null, b !== null) {
          switch (typeof d) {
            case "function":
            case "symbol":
              return;
            case "boolean":
              if (!b.acceptsBooleans)
                return;
          }
          switch (c = b.attributeName, b.type) {
            case 3:
              d && a.push(I, c, Ga);
              break;
            case 4:
              d === !0 ? a.push(I, c, Ga) : d !== !1 && a.push(I, c, J, F(d), H);
              break;
            case 5:
              isNaN(d) || a.push(I, c, J, F(d), H);
              break;
            case 6:
              !isNaN(d) && 1 <= d && a.push(I, c, J, F(d), H);
              break;
            default:
              b.sanitizeURL && (d = "" + d), a.push(I, c, J, F(d), H);
          }
        } else if (ha(c)) {
          switch (typeof d) {
            case "function":
            case "symbol":
              return;
            case "boolean":
              if (b = c.toLowerCase().slice(0, 5), b !== "data-" && b !== "aria-")
                return;
          }
          a.push(I, c, J, F(d), H);
        }
      }
    }
    var L = x(">"), Ha = x("/>");
    function M(a, b, c) {
      if (b != null) {
        if (c != null)
          throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof b != "object" || !("__html" in b))
          throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        b = b.__html, b != null && a.push("" + b);
      }
    }
    function Ia(a) {
      var b = "";
      return ba.Children.forEach(a, function(a2) {
        a2 != null && (b += a2);
      }), b;
    }
    var Ja = x(' selected=""');
    function Ka(a, b, c, d) {
      a.push(N(c));
      var f = c = null, e;
      for (e in b)
        if (y.call(b, e)) {
          var g = b[e];
          if (g != null)
            switch (e) {
              case "children":
                c = g;
                break;
              case "dangerouslySetInnerHTML":
                f = g;
                break;
              default:
                K(a, d, e, g);
            }
        }
      return a.push(L), M(a, f, c), typeof c == "string" ? (a.push(F(c)), null) : c;
    }
    var La = x(`
`), Ma = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, Na = /* @__PURE__ */ new Map();
    function N(a) {
      var b = Na.get(a);
      if (b === void 0) {
        if (!Ma.test(a))
          throw Error("Invalid tag: " + a);
        b = x("<" + a), Na.set(a, b);
      }
      return b;
    }
    var Oa = x("<!DOCTYPE html>");
    function Pa(a, b, c, d, f) {
      switch (b) {
        case "select":
          a.push(N("select"));
          var e = null, g = null;
          for (p in c)
            if (y.call(c, p)) {
              var h = c[p];
              if (h != null)
                switch (p) {
                  case "children":
                    e = h;
                    break;
                  case "dangerouslySetInnerHTML":
                    g = h;
                    break;
                  case "defaultValue":
                  case "value":
                    break;
                  default:
                    K(a, d, p, h);
                }
            }
          return a.push(L), M(a, g, e), e;
        case "option":
          g = f.selectedValue, a.push(N("option"));
          var m = h = null, n = null, p = null;
          for (e in c)
            if (y.call(c, e)) {
              var v = c[e];
              if (v != null)
                switch (e) {
                  case "children":
                    h = v;
                    break;
                  case "selected":
                    n = v;
                    break;
                  case "dangerouslySetInnerHTML":
                    p = v;
                    break;
                  case "value":
                    m = v;
                  default:
                    K(a, d, e, v);
                }
            }
          if (g != null)
            if (c = m !== null ? "" + m : Ia(h), qa(g)) {
              for (d = 0; d < g.length; d++)
                if ("" + g[d] === c) {
                  a.push(Ja);
                  break;
                }
            } else
              "" + g === c && a.push(Ja);
          else
            n && a.push(Ja);
          return a.push(L), M(a, p, h), h;
        case "textarea":
          a.push(N("textarea")), p = g = e = null;
          for (h in c)
            if (y.call(c, h) && (m = c[h], m != null))
              switch (h) {
                case "children":
                  p = m;
                  break;
                case "value":
                  e = m;
                  break;
                case "defaultValue":
                  g = m;
                  break;
                case "dangerouslySetInnerHTML":
                  throw Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
                default:
                  K(a, d, h, m);
              }
          if (e === null && g !== null && (e = g), a.push(L), p != null) {
            if (e != null)
              throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            if (qa(p) && 1 < p.length)
              throw Error("<textarea> can only have at most one child.");
            e = "" + p;
          }
          return typeof e == "string" && e[0] === `
` && a.push(La), e !== null && a.push(F("" + e)), null;
        case "input":
          a.push(N("input")), m = p = h = e = null;
          for (g in c)
            if (y.call(c, g) && (n = c[g], n != null))
              switch (g) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                case "defaultChecked":
                  m = n;
                  break;
                case "defaultValue":
                  h = n;
                  break;
                case "checked":
                  p = n;
                  break;
                case "value":
                  e = n;
                  break;
                default:
                  K(a, d, g, n);
              }
          return p !== null ? K(a, d, "checked", p) : m !== null && K(a, d, "checked", m), e !== null ? K(a, d, "value", e) : h !== null && K(a, d, "value", h), a.push(Ha), null;
        case "menuitem":
          a.push(N("menuitem"));
          for (var C in c)
            if (y.call(c, C) && (e = c[C], e != null))
              switch (C) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
                default:
                  K(a, d, C, e);
              }
          return a.push(L), null;
        case "title":
          a.push(N("title")), e = null;
          for (v in c)
            if (y.call(c, v) && (g = c[v], g != null))
              switch (v) {
                case "children":
                  e = g;
                  break;
                case "dangerouslySetInnerHTML":
                  throw Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
                default:
                  K(a, d, v, g);
              }
          return a.push(L), e;
        case "listing":
        case "pre":
          a.push(N(b)), g = e = null;
          for (m in c)
            if (y.call(c, m) && (h = c[m], h != null))
              switch (m) {
                case "children":
                  e = h;
                  break;
                case "dangerouslySetInnerHTML":
                  g = h;
                  break;
                default:
                  K(a, d, m, h);
              }
          if (a.push(L), g != null) {
            if (e != null)
              throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
            if (typeof g != "object" || !("__html" in g))
              throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
            c = g.__html, c != null && (typeof c == "string" && 0 < c.length && c[0] === `
` ? a.push(La, c) : a.push("" + c));
          }
          return typeof e == "string" && e[0] === `
` && a.push(La), e;
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          a.push(N(b));
          for (var D in c)
            if (y.call(c, D) && (e = c[D], e != null))
              switch (D) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(b + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                default:
                  K(a, d, D, e);
              }
          return a.push(Ha), null;
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return Ka(a, c, b, d);
        case "html":
          return f.insertionMode === 0 && a.push(Oa), Ka(
            a,
            c,
            b,
            d
          );
        default:
          if (b.indexOf("-") === -1 && typeof c.is != "string")
            return Ka(a, c, b, d);
          a.push(N(b)), g = e = null;
          for (n in c)
            if (y.call(c, n) && (h = c[n], h != null))
              switch (n) {
                case "children":
                  e = h;
                  break;
                case "dangerouslySetInnerHTML":
                  g = h;
                  break;
                case "style":
                  Fa(a, d, h);
                  break;
                case "suppressContentEditableWarning":
                case "suppressHydrationWarning":
                  break;
                default:
                  ha(n) && typeof h != "function" && typeof h != "symbol" && a.push(I, n, J, F(h), H);
              }
          return a.push(L), M(a, g, e), e;
      }
    }
    var Qa = x("</"), Ra = x(">"), Sa = x('<template id="'), Ta = x('"></template>'), Ua = x("<!--$-->"), Va = x('<!--$?--><template id="'), Wa = x('"></template>'), Xa = x("<!--$!-->"), Ya = x("<!--/$-->"), Za = x("<template"), $a = x('"'), ab = x(' data-dgst="');
    x(' data-msg="');
    x(' data-stck="');
    var bb = x("></template>");
    function cb(a, b, c) {
      if (r(a, Va), c === null)
        throw Error("An ID must have been assigned before we can complete the boundary.");
      return r(a, c), w(a, Wa);
    }
    var db = x('<div hidden id="'), eb = x('">'), fb = x("</div>"), gb = x('<svg aria-hidden="true" style="display:none" id="'), hb = x('">'), ib = x("</svg>"), jb = x('<math aria-hidden="true" style="display:none" id="'), kb = x('">'), lb = x("</math>"), mb = x('<table hidden id="'), nb = x('">'), ob = x("</table>"), pb = x('<table hidden><tbody id="'), qb = x('">'), rb = x("</tbody></table>"), sb = x('<table hidden><tr id="'), tb = x('">'), ub = x("</tr></table>"), vb = x('<table hidden><colgroup id="'), wb = x('">'), xb = x("</colgroup></table>");
    function yb(a, b, c, d) {
      switch (c.insertionMode) {
        case 0:
        case 1:
          return r(a, db), r(a, b.segmentPrefix), r(a, d.toString(16)), w(a, eb);
        case 2:
          return r(a, gb), r(a, b.segmentPrefix), r(a, d.toString(16)), w(a, hb);
        case 3:
          return r(a, jb), r(a, b.segmentPrefix), r(a, d.toString(16)), w(a, kb);
        case 4:
          return r(a, mb), r(a, b.segmentPrefix), r(a, d.toString(16)), w(a, nb);
        case 5:
          return r(a, pb), r(a, b.segmentPrefix), r(a, d.toString(16)), w(a, qb);
        case 6:
          return r(a, sb), r(a, b.segmentPrefix), r(a, d.toString(16)), w(a, tb);
        case 7:
          return r(a, vb), r(
            a,
            b.segmentPrefix
          ), r(a, d.toString(16)), w(a, wb);
        default:
          throw Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    function zb(a, b) {
      switch (b.insertionMode) {
        case 0:
        case 1:
          return w(a, fb);
        case 2:
          return w(a, ib);
        case 3:
          return w(a, lb);
        case 4:
          return w(a, ob);
        case 5:
          return w(a, rb);
        case 6:
          return w(a, ub);
        case 7:
          return w(a, xb);
        default:
          throw Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    var Ab = x('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("'), Bb = x('$RS("'), Cb = x('","'), Db = x('")</script>'), Fb = x('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("'), Gb = x('$RC("'), Hb = x('","'), Ib = x('")</script>'), Jb = x('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("'), Kb = x('$RX("'), Lb = x('"'), Mb = x(")</script>"), Nb = x(","), Ob = /[<\u2028\u2029]/g;
    function Pb(a) {
      return JSON.stringify(a).replace(Ob, function(a2) {
        switch (a2) {
          case "<":
            return "\\u003c";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          default:
            throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
        }
      });
    }
    var O = Object.assign, Qb = Symbol.for("react.element"), Rb = Symbol.for("react.portal"), Sb = Symbol.for("react.fragment"), Tb = Symbol.for("react.strict_mode"), Ub = Symbol.for("react.profiler"), Vb = Symbol.for("react.provider"), Wb = Symbol.for("react.context"), Xb = Symbol.for("react.forward_ref"), Yb = Symbol.for("react.suspense"), Zb = Symbol.for("react.suspense_list"), $b = Symbol.for("react.memo"), ac = Symbol.for("react.lazy"), bc = Symbol.for("react.scope"), cc = Symbol.for("react.debug_trace_mode"), dc = Symbol.for("react.legacy_hidden"), ec = Symbol.for("react.default_value"), fc = Symbol.iterator;
    function gc(a) {
      if (a == null)
        return null;
      if (typeof a == "function")
        return a.displayName || a.name || null;
      if (typeof a == "string")
        return a;
      switch (a) {
        case Sb:
          return "Fragment";
        case Rb:
          return "Portal";
        case Ub:
          return "Profiler";
        case Tb:
          return "StrictMode";
        case Yb:
          return "Suspense";
        case Zb:
          return "SuspenseList";
      }
      if (typeof a == "object")
        switch (a.$$typeof) {
          case Wb:
            return (a.displayName || "Context") + ".Consumer";
          case Vb:
            return (a._context.displayName || "Context") + ".Provider";
          case Xb:
            var b = a.render;
            return a = a.displayName, a || (a = b.displayName || b.name || "", a = a !== "" ? "ForwardRef(" + a + ")" : "ForwardRef"), a;
          case $b:
            return b = a.displayName || null, b !== null ? b : gc(a.type) || "Memo";
          case ac:
            b = a._payload, a = a._init;
            try {
              return gc(a(b));
            } catch {
            }
        }
      return null;
    }
    var hc = {};
    function ic(a, b) {
      if (a = a.contextTypes, !a)
        return hc;
      var c = {}, d;
      for (d in a)
        c[d] = b[d];
      return c;
    }
    var P = null;
    function Q(a, b) {
      if (a !== b) {
        a.context._currentValue = a.parentValue, a = a.parent;
        var c = b.parent;
        if (a === null) {
          if (c !== null)
            throw Error("The stacks must reach the root at the same time. This is a bug in React.");
        } else {
          if (c === null)
            throw Error("The stacks must reach the root at the same time. This is a bug in React.");
          Q(a, c);
        }
        b.context._currentValue = b.value;
      }
    }
    function jc(a) {
      a.context._currentValue = a.parentValue, a = a.parent, a !== null && jc(a);
    }
    function kc(a) {
      var b = a.parent;
      b !== null && kc(b), a.context._currentValue = a.value;
    }
    function lc(a, b) {
      if (a.context._currentValue = a.parentValue, a = a.parent, a === null)
        throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      a.depth === b.depth ? Q(a, b) : lc(a, b);
    }
    function mc(a, b) {
      var c = b.parent;
      if (c === null)
        throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      a.depth === c.depth ? Q(a, c) : mc(a, c), b.context._currentValue = b.value;
    }
    function nc(a) {
      var b = P;
      b !== a && (b === null ? kc(a) : a === null ? jc(b) : b.depth === a.depth ? Q(b, a) : b.depth > a.depth ? lc(b, a) : mc(b, a), P = a);
    }
    var oc = { isMounted: function() {
      return !1;
    }, enqueueSetState: function(a, b) {
      a = a._reactInternals, a.queue !== null && a.queue.push(b);
    }, enqueueReplaceState: function(a, b) {
      a = a._reactInternals, a.replace = !0, a.queue = [b];
    }, enqueueForceUpdate: function() {
    } };
    function pc(a, b, c, d) {
      var f = a.state !== void 0 ? a.state : null;
      a.updater = oc, a.props = c, a.state = f;
      var e = { queue: [], replace: !1 };
      a._reactInternals = e;
      var g = b.contextType;
      if (a.context = typeof g == "object" && g !== null ? g._currentValue : d, g = b.getDerivedStateFromProps, typeof g == "function" && (g = g(c, f), f = g == null ? f : O({}, f, g), a.state = f), typeof b.getDerivedStateFromProps != "function" && typeof a.getSnapshotBeforeUpdate != "function" && (typeof a.UNSAFE_componentWillMount == "function" || typeof a.componentWillMount == "function"))
        if (b = a.state, typeof a.componentWillMount == "function" && a.componentWillMount(), typeof a.UNSAFE_componentWillMount == "function" && a.UNSAFE_componentWillMount(), b !== a.state && oc.enqueueReplaceState(a, a.state, null), e.queue !== null && 0 < e.queue.length)
          if (b = e.queue, g = e.replace, e.queue = null, e.replace = !1, g && b.length === 1)
            a.state = b[0];
          else {
            for (e = g ? b[0] : a.state, f = !0, g = g ? 1 : 0; g < b.length; g++) {
              var h = b[g];
              h = typeof h == "function" ? h.call(a, e, c, d) : h, h != null && (f ? (f = !1, e = O({}, e, h)) : O(e, h));
            }
            a.state = e;
          }
        else
          e.queue = null;
    }
    var qc = { id: 1, overflow: "" };
    function rc(a, b, c) {
      var d = a.id;
      a = a.overflow;
      var f = 32 - sc(d) - 1;
      d &= ~(1 << f), c += 1;
      var e = 32 - sc(b) + f;
      if (30 < e) {
        var g = f - f % 5;
        return e = (d & (1 << g) - 1).toString(32), d >>= g, f -= g, { id: 1 << 32 - sc(b) + f | c << f | d, overflow: e + a };
      }
      return { id: 1 << e | c << f | d, overflow: a };
    }
    var sc = Math.clz32 ? Math.clz32 : tc, uc = Math.log, vc = Math.LN2;
    function tc(a) {
      return a >>>= 0, a === 0 ? 32 : 31 - (uc(a) / vc | 0) | 0;
    }
    function wc(a, b) {
      return a === b && (a !== 0 || 1 / a === 1 / b) || a !== a && b !== b;
    }
    var xc = typeof Object.is == "function" ? Object.is : wc, R = null, yc = null, zc = null, S = null, T = !1, Ac = !1, U = 0, V = null, Bc = 0;
    function W() {
      if (R === null)
        throw Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
      return R;
    }
    function Cc() {
      if (0 < Bc)
        throw Error("Rendered more hooks than during the previous render");
      return { memoizedState: null, queue: null, next: null };
    }
    function Dc() {
      return S === null ? zc === null ? (T = !1, zc = S = Cc()) : (T = !0, S = zc) : S.next === null ? (T = !1, S = S.next = Cc()) : (T = !0, S = S.next), S;
    }
    function Ec() {
      yc = R = null, Ac = !1, zc = null, Bc = 0, S = V = null;
    }
    function Fc(a, b) {
      return typeof b == "function" ? b(a) : b;
    }
    function Gc(a, b, c) {
      if (R = W(), S = Dc(), T) {
        var d = S.queue;
        if (b = d.dispatch, V !== null && (c = V.get(d), c !== void 0)) {
          V.delete(d), d = S.memoizedState;
          do
            d = a(d, c.action), c = c.next;
          while (c !== null);
          return S.memoizedState = d, [d, b];
        }
        return [S.memoizedState, b];
      }
      return a = a === Fc ? typeof b == "function" ? b() : b : c !== void 0 ? c(b) : b, S.memoizedState = a, a = S.queue = { last: null, dispatch: null }, a = a.dispatch = Hc.bind(null, R, a), [S.memoizedState, a];
    }
    function Ic(a, b) {
      if (R = W(), S = Dc(), b = b === void 0 ? null : b, S !== null) {
        var c = S.memoizedState;
        if (c !== null && b !== null) {
          var d = c[1];
          a:
            if (d === null)
              d = !1;
            else {
              for (var f = 0; f < d.length && f < b.length; f++)
                if (!xc(b[f], d[f])) {
                  d = !1;
                  break a;
                }
              d = !0;
            }
          if (d)
            return c[0];
        }
      }
      return a = a(), S.memoizedState = [a, b], a;
    }
    function Hc(a, b, c) {
      if (25 <= Bc)
        throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
      if (a === R)
        if (Ac = !0, a = { action: c, next: null }, V === null && (V = /* @__PURE__ */ new Map()), c = V.get(b), c === void 0)
          V.set(b, a);
        else {
          for (b = c; b.next !== null; )
            b = b.next;
          b.next = a;
        }
    }
    function Jc() {
      throw Error("startTransition cannot be called during server rendering.");
    }
    function Kc() {
    }
    var Mc = { readContext: function(a) {
      return a._currentValue;
    }, useContext: function(a) {
      return W(), a._currentValue;
    }, useMemo: Ic, useReducer: Gc, useRef: function(a) {
      R = W(), S = Dc();
      var b = S.memoizedState;
      return b === null ? (a = { current: a }, S.memoizedState = a) : b;
    }, useState: function(a) {
      return Gc(Fc, a);
    }, useInsertionEffect: Kc, useLayoutEffect: function() {
    }, useCallback: function(a, b) {
      return Ic(function() {
        return a;
      }, b);
    }, useImperativeHandle: Kc, useEffect: Kc, useDebugValue: Kc, useDeferredValue: function(a) {
      return W(), a;
    }, useTransition: function() {
      return W(), [!1, Jc];
    }, useId: function() {
      var a = yc.treeContext, b = a.overflow;
      a = a.id, a = (a & ~(1 << 32 - sc(a) - 1)).toString(32) + b;
      var c = Lc;
      if (c === null)
        throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
      return b = U++, a = ":" + c.idPrefix + "R" + a, 0 < b && (a += "H" + b.toString(32)), a + ":";
    }, useMutableSource: function(a, b) {
      return W(), b(a._source);
    }, useSyncExternalStore: function(a, b, c) {
      if (c === void 0)
        throw Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
      return c();
    } }, Lc = null, Nc = ba.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
    function Oc(a) {
      return console.error(a), null;
    }
    function X() {
    }
    function Pc(a, b) {
      var c = a.pingedTasks;
      c.push(b), c.length === 1 && setImmediate(function() {
        return Qc(a);
      });
    }
    function Rc(a, b, c, d, f, e, g, h) {
      a.allPendingTasks++, c === null ? a.pendingRootTasks++ : c.pendingTasks++;
      var m = { node: b, ping: function() {
        return Pc(a, m);
      }, blockedBoundary: c, blockedSegment: d, abortSet: f, legacyContext: e, context: g, treeContext: h };
      return f.add(m), m;
    }
    function Sc(a, b, c, d, f, e) {
      return { status: 0, id: -1, index: b, parentFlushed: !1, chunks: [], children: [], formatContext: d, boundary: c, lastPushedText: f, textEmbedded: e };
    }
    function Y(a, b) {
      if (a = a.onError(b), a != null && typeof a != "string")
        throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof a + '" instead');
      return a;
    }
    function Tc(a, b) {
      var c = a.onShellError;
      c(b), c = a.onFatalError, c(b), a.destination !== null ? (a.status = 2, a.destination.destroy(b)) : (a.status = 1, a.fatalError = b);
    }
    function Uc(a, b, c, d, f) {
      for (R = {}, yc = b, U = 0, a = c(d, f); Ac; )
        Ac = !1, U = 0, Bc += 1, S = null, a = c(d, f);
      return Ec(), a;
    }
    function Vc(a, b, c, d) {
      var f = c.render(), e = d.childContextTypes;
      if (e != null) {
        var g = b.legacyContext;
        if (typeof c.getChildContext != "function")
          d = g;
        else {
          c = c.getChildContext();
          for (var h in c)
            if (!(h in e))
              throw Error((gc(d) || "Unknown") + '.getChildContext(): key "' + h + '" is not defined in childContextTypes.');
          d = O({}, g, c);
        }
        b.legacyContext = d, Z(a, b, f), b.legacyContext = g;
      } else
        Z(a, b, f);
    }
    function Wc(a, b) {
      if (a && a.defaultProps) {
        b = O({}, b), a = a.defaultProps;
        for (var c in a)
          b[c] === void 0 && (b[c] = a[c]);
        return b;
      }
      return b;
    }
    function Xc(a, b, c, d, f) {
      if (typeof c == "function")
        if (c.prototype && c.prototype.isReactComponent) {
          f = ic(c, b.legacyContext);
          var e = c.contextType;
          e = new c(d, typeof e == "object" && e !== null ? e._currentValue : f), pc(e, c, d, f), Vc(a, b, e, c);
        } else {
          e = ic(c, b.legacyContext), f = Uc(a, b, c, d, e);
          var g = U !== 0;
          if (typeof f == "object" && f !== null && typeof f.render == "function" && f.$$typeof === void 0)
            pc(f, c, d, e), Vc(a, b, f, c);
          else if (g) {
            d = b.treeContext, b.treeContext = rc(d, 1, 0);
            try {
              Z(a, b, f);
            } finally {
              b.treeContext = d;
            }
          } else
            Z(a, b, f);
        }
      else if (typeof c == "string") {
        switch (f = b.blockedSegment, e = Pa(f.chunks, c, d, a.responseState, f.formatContext), f.lastPushedText = !1, g = f.formatContext, f.formatContext = ya(g, c, d), Yc(a, b, e), f.formatContext = g, c) {
          case "area":
          case "base":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "img":
          case "input":
          case "keygen":
          case "link":
          case "meta":
          case "param":
          case "source":
          case "track":
          case "wbr":
            break;
          default:
            f.chunks.push(Qa, c, Ra);
        }
        f.lastPushedText = !1;
      } else {
        switch (c) {
          case dc:
          case cc:
          case Tb:
          case Ub:
          case Sb:
            Z(a, b, d.children);
            return;
          case Zb:
            Z(
              a,
              b,
              d.children
            );
            return;
          case bc:
            throw Error("ReactDOMServer does not yet support scope components.");
          case Yb:
            a: {
              c = b.blockedBoundary, f = b.blockedSegment, e = d.fallback, d = d.children, g = /* @__PURE__ */ new Set();
              var h = { id: null, rootSegmentID: -1, parentFlushed: !1, pendingTasks: 0, forceClientRender: !1, completedSegments: [], byteSize: 0, fallbackAbortableTasks: g, errorDigest: null }, m = Sc(a, f.chunks.length, h, f.formatContext, !1, !1);
              f.children.push(m), f.lastPushedText = !1;
              var n = Sc(a, 0, null, f.formatContext, !1, !1);
              n.parentFlushed = !0, b.blockedBoundary = h, b.blockedSegment = n;
              try {
                if (Yc(a, b, d), n.lastPushedText && n.textEmbedded && n.chunks.push(za), n.status = 1, Zc(h, n), h.pendingTasks === 0)
                  break a;
              } catch (p) {
                n.status = 4, h.forceClientRender = !0, h.errorDigest = Y(a, p);
              } finally {
                b.blockedBoundary = c, b.blockedSegment = f;
              }
              b = Rc(a, e, c, m, g, b.legacyContext, b.context, b.treeContext), a.pingedTasks.push(b);
            }
            return;
        }
        if (typeof c == "object" && c !== null)
          switch (c.$$typeof) {
            case Xb:
              if (d = Uc(a, b, c.render, d, f), U !== 0) {
                c = b.treeContext, b.treeContext = rc(c, 1, 0);
                try {
                  Z(a, b, d);
                } finally {
                  b.treeContext = c;
                }
              } else
                Z(
                  a,
                  b,
                  d
                );
              return;
            case $b:
              c = c.type, d = Wc(c, d), Xc(a, b, c, d, f);
              return;
            case Vb:
              if (f = d.children, c = c._context, d = d.value, e = c._currentValue, c._currentValue = d, g = P, P = d = { parent: g, depth: g === null ? 0 : g.depth + 1, context: c, parentValue: e, value: d }, b.context = d, Z(a, b, f), a = P, a === null)
                throw Error("Tried to pop a Context at the root of the app. This is a bug in React.");
              d = a.parentValue, a.context._currentValue = d === ec ? a.context._defaultValue : d, a = P = a.parent, b.context = a;
              return;
            case Wb:
              d = d.children, d = d(c._currentValue), Z(a, b, d);
              return;
            case ac:
              f = c._init, c = f(c._payload), d = Wc(c, d), Xc(a, b, c, d, void 0);
              return;
          }
        throw Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + ((c == null ? c : typeof c) + "."));
      }
    }
    function Z(a, b, c) {
      if (b.node = c, typeof c == "object" && c !== null) {
        switch (c.$$typeof) {
          case Qb:
            Xc(a, b, c.type, c.props, c.ref);
            return;
          case Rb:
            throw Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
          case ac:
            var d = c._init;
            c = d(c._payload), Z(a, b, c);
            return;
        }
        if (qa(c)) {
          $c(a, b, c);
          return;
        }
        if (c === null || typeof c != "object" ? d = null : (d = fc && c[fc] || c["@@iterator"], d = typeof d == "function" ? d : null), d && (d = d.call(c))) {
          if (c = d.next(), !c.done) {
            var f = [];
            do
              f.push(c.value), c = d.next();
            while (!c.done);
            $c(a, b, f);
          }
          return;
        }
        throw a = Object.prototype.toString.call(c), Error("Objects are not valid as a React child (found: " + (a === "[object Object]" ? "object with keys {" + Object.keys(c).join(", ") + "}" : a) + "). If you meant to render a collection of children, use an array instead.");
      }
      typeof c == "string" ? (d = b.blockedSegment, d.lastPushedText = Aa(b.blockedSegment.chunks, c, a.responseState, d.lastPushedText)) : typeof c == "number" && (d = b.blockedSegment, d.lastPushedText = Aa(
        b.blockedSegment.chunks,
        "" + c,
        a.responseState,
        d.lastPushedText
      ));
    }
    function $c(a, b, c) {
      for (var d = c.length, f = 0; f < d; f++) {
        var e = b.treeContext;
        b.treeContext = rc(e, d, f);
        try {
          Yc(a, b, c[f]);
        } finally {
          b.treeContext = e;
        }
      }
    }
    function Yc(a, b, c) {
      var d = b.blockedSegment.formatContext, f = b.legacyContext, e = b.context;
      try {
        return Z(a, b, c);
      } catch (m) {
        if (Ec(), typeof m == "object" && m !== null && typeof m.then == "function") {
          c = m;
          var g = b.blockedSegment, h = Sc(a, g.chunks.length, null, g.formatContext, g.lastPushedText, !0);
          g.children.push(h), g.lastPushedText = !1, a = Rc(a, b.node, b.blockedBoundary, h, b.abortSet, b.legacyContext, b.context, b.treeContext).ping, c.then(a, a), b.blockedSegment.formatContext = d, b.legacyContext = f, b.context = e, nc(e);
        } else
          throw b.blockedSegment.formatContext = d, b.legacyContext = f, b.context = e, nc(e), m;
      }
    }
    function ad(a) {
      var b = a.blockedBoundary;
      a = a.blockedSegment, a.status = 3, bd(this, b, a);
    }
    function cd(a, b, c) {
      var d = a.blockedBoundary;
      a.blockedSegment.status = 3, d === null ? (b.allPendingTasks--, b.status !== 2 && (b.status = 2, b.destination !== null && b.destination.end())) : (d.pendingTasks--, d.forceClientRender || (d.forceClientRender = !0, d.errorDigest = b.onError(c === void 0 ? Error("The render was aborted by the server without a reason.") : c), d.parentFlushed && b.clientRenderedBoundaries.push(d)), d.fallbackAbortableTasks.forEach(function(a2) {
        return cd(a2, b, c);
      }), d.fallbackAbortableTasks.clear(), b.allPendingTasks--, b.allPendingTasks === 0 && (a = b.onAllReady, a()));
    }
    function Zc(a, b) {
      if (b.chunks.length === 0 && b.children.length === 1 && b.children[0].boundary === null) {
        var c = b.children[0];
        c.id = b.id, c.parentFlushed = !0, c.status === 1 && Zc(a, c);
      } else
        a.completedSegments.push(b);
    }
    function bd(a, b, c) {
      if (b === null) {
        if (c.parentFlushed) {
          if (a.completedRootSegment !== null)
            throw Error("There can only be one root segment. This is a bug in React.");
          a.completedRootSegment = c;
        }
        a.pendingRootTasks--, a.pendingRootTasks === 0 && (a.onShellError = X, b = a.onShellReady, b());
      } else
        b.pendingTasks--, b.forceClientRender || (b.pendingTasks === 0 ? (c.parentFlushed && c.status === 1 && Zc(b, c), b.parentFlushed && a.completedBoundaries.push(b), b.fallbackAbortableTasks.forEach(ad, a), b.fallbackAbortableTasks.clear()) : c.parentFlushed && c.status === 1 && (Zc(b, c), b.completedSegments.length === 1 && b.parentFlushed && a.partialBoundaries.push(b)));
      a.allPendingTasks--, a.allPendingTasks === 0 && (a = a.onAllReady, a());
    }
    function Qc(a) {
      if (a.status !== 2) {
        var b = P, c = Nc.current;
        Nc.current = Mc;
        var d = Lc;
        Lc = a.responseState;
        try {
          var f = a.pingedTasks, e;
          for (e = 0; e < f.length; e++) {
            var g = f[e], h = a, m = g.blockedSegment;
            if (m.status === 0) {
              nc(g.context);
              try {
                Z(h, g, g.node), m.lastPushedText && m.textEmbedded && m.chunks.push(za), g.abortSet.delete(g), m.status = 1, bd(h, g.blockedBoundary, m);
              } catch (E) {
                if (Ec(), typeof E == "object" && E !== null && typeof E.then == "function") {
                  var n = g.ping;
                  E.then(n, n);
                } else {
                  g.abortSet.delete(g), m.status = 4;
                  var p = g.blockedBoundary, v = E, C = Y(h, v);
                  if (p === null ? Tc(h, v) : (p.pendingTasks--, p.forceClientRender || (p.forceClientRender = !0, p.errorDigest = C, p.parentFlushed && h.clientRenderedBoundaries.push(p))), h.allPendingTasks--, h.allPendingTasks === 0) {
                    var D = h.onAllReady;
                    D();
                  }
                }
              } finally {
              }
            }
          }
          f.splice(0, e), a.destination !== null && dd(a, a.destination);
        } catch (E) {
          Y(a, E), Tc(a, E);
        } finally {
          Lc = d, Nc.current = c, c === Mc && nc(b);
        }
      }
    }
    function ed(a, b, c) {
      switch (c.parentFlushed = !0, c.status) {
        case 0:
          var d = c.id = a.nextSegmentId++;
          return c.lastPushedText = !1, c.textEmbedded = !1, a = a.responseState, r(b, Sa), r(b, a.placeholderPrefix), a = d.toString(16), r(b, a), w(b, Ta);
        case 1:
          c.status = 2;
          var f = !0;
          d = c.chunks;
          var e = 0;
          c = c.children;
          for (var g = 0; g < c.length; g++) {
            for (f = c[g]; e < f.index; e++)
              r(b, d[e]);
            f = fd(a, b, f);
          }
          for (; e < d.length - 1; e++)
            r(b, d[e]);
          return e < d.length && (f = w(b, d[e])), f;
        default:
          throw Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
      }
    }
    function fd(a, b, c) {
      var d = c.boundary;
      if (d === null)
        return ed(a, b, c);
      if (d.parentFlushed = !0, d.forceClientRender)
        d = d.errorDigest, w(b, Xa), r(b, Za), d && (r(b, ab), r(b, F(d)), r(b, $a)), w(b, bb), ed(a, b, c);
      else if (0 < d.pendingTasks) {
        d.rootSegmentID = a.nextSegmentId++, 0 < d.completedSegments.length && a.partialBoundaries.push(d);
        var f = a.responseState, e = f.nextSuspenseID++;
        f = x(f.boundaryPrefix + e.toString(16)), d = d.id = f, cb(b, a.responseState, d), ed(a, b, c);
      } else if (d.byteSize > a.progressiveChunkSize)
        d.rootSegmentID = a.nextSegmentId++, a.completedBoundaries.push(d), cb(b, a.responseState, d.id), ed(a, b, c);
      else {
        if (w(b, Ua), c = d.completedSegments, c.length !== 1)
          throw Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
        fd(a, b, c[0]);
      }
      return w(b, Ya);
    }
    function gd(a, b, c) {
      return yb(b, a.responseState, c.formatContext, c.id), fd(a, b, c), zb(b, c.formatContext);
    }
    function hd(a, b, c) {
      for (var d = c.completedSegments, f = 0; f < d.length; f++)
        id(a, b, c, d[f]);
      if (d.length = 0, a = a.responseState, d = c.id, c = c.rootSegmentID, r(b, a.startInlineScript), a.sentCompleteBoundaryFunction ? r(b, Gb) : (a.sentCompleteBoundaryFunction = !0, r(b, Fb)), d === null)
        throw Error("An ID must have been assigned before we can complete the boundary.");
      return c = c.toString(16), r(b, d), r(b, Hb), r(b, a.segmentPrefix), r(b, c), w(b, Ib);
    }
    function id(a, b, c, d) {
      if (d.status === 2)
        return !0;
      var f = d.id;
      if (f === -1) {
        if ((d.id = c.rootSegmentID) === -1)
          throw Error("A root segment ID must have been assigned by now. This is a bug in React.");
        return gd(a, b, d);
      }
      return gd(a, b, d), a = a.responseState, r(b, a.startInlineScript), a.sentCompleteSegmentFunction ? r(b, Bb) : (a.sentCompleteSegmentFunction = !0, r(b, Ab)), r(b, a.segmentPrefix), f = f.toString(16), r(b, f), r(b, Cb), r(b, a.placeholderPrefix), r(b, f), w(b, Db);
    }
    function dd(a, b) {
      k = new Uint8Array(2048), l = 0, q = !0;
      try {
        var c = a.completedRootSegment;
        if (c !== null && a.pendingRootTasks === 0) {
          fd(a, b, c), a.completedRootSegment = null;
          var d = a.responseState.bootstrapChunks;
          for (c = 0; c < d.length - 1; c++)
            r(b, d[c]);
          c < d.length && w(b, d[c]);
        }
        var f = a.clientRenderedBoundaries, e;
        for (e = 0; e < f.length; e++) {
          var g = f[e];
          d = b;
          var h = a.responseState, m = g.id, n = g.errorDigest, p = g.errorMessage, v = g.errorComponentStack;
          if (r(d, h.startInlineScript), h.sentClientRenderFunction ? r(d, Kb) : (h.sentClientRenderFunction = !0, r(d, Jb)), m === null)
            throw Error("An ID must have been assigned before we can complete the boundary.");
          if (r(d, m), r(d, Lb), (n || p || v) && (r(d, Nb), r(d, Pb(n || ""))), (p || v) && (r(d, Nb), r(d, Pb(p || ""))), v && (r(d, Nb), r(d, Pb(v))), !w(d, Mb)) {
            a.destination = null, e++, f.splice(0, e);
            return;
          }
        }
        f.splice(0, e);
        var C = a.completedBoundaries;
        for (e = 0; e < C.length; e++)
          if (!hd(a, b, C[e])) {
            a.destination = null, e++, C.splice(0, e);
            return;
          }
        C.splice(0, e), ca(b), k = new Uint8Array(2048), l = 0, q = !0;
        var D = a.partialBoundaries;
        for (e = 0; e < D.length; e++) {
          var E = D[e];
          a: {
            f = a, g = b;
            var na = E.completedSegments;
            for (h = 0; h < na.length; h++)
              if (!id(f, g, E, na[h])) {
                h++, na.splice(0, h);
                var Eb = !1;
                break a;
              }
            na.splice(0, h), Eb = !0;
          }
          if (!Eb) {
            a.destination = null, e++, D.splice(0, e);
            return;
          }
        }
        D.splice(0, e);
        var oa = a.completedBoundaries;
        for (e = 0; e < oa.length; e++)
          if (!hd(a, b, oa[e])) {
            a.destination = null, e++, oa.splice(0, e);
            return;
          }
        oa.splice(0, e);
      } finally {
        ca(b), typeof b.flush == "function" && b.flush(), a.allPendingTasks === 0 && a.pingedTasks.length === 0 && a.clientRenderedBoundaries.length === 0 && a.completedBoundaries.length === 0 && b.end();
      }
    }
    function jd(a) {
      setImmediate(function() {
        return Qc(a);
      });
    }
    function kd(a, b) {
      if (a.status === 1)
        a.status = 2, b.destroy(a.fatalError);
      else if (a.status !== 2 && a.destination === null) {
        a.destination = b;
        try {
          dd(a, b);
        } catch (c) {
          Y(a, c), Tc(a, c);
        }
      }
    }
    function ld(a, b) {
      try {
        var c = a.abortableTasks;
        c.forEach(function(c2) {
          return cd(c2, a, b);
        }), c.clear(), a.destination !== null && dd(a, a.destination);
      } catch (d) {
        Y(a, d), Tc(a, d);
      }
    }
    function md(a, b) {
      return function() {
        return kd(b, a);
      };
    }
    function nd(a, b) {
      return function() {
        return ld(a, b);
      };
    }
    function od(a, b) {
      var c = b ? b.identifierPrefix : void 0, d = b ? b.nonce : void 0, f = b ? b.bootstrapScriptContent : void 0, e = b ? b.bootstrapScripts : void 0, g = b ? b.bootstrapModules : void 0;
      c = c === void 0 ? "" : c, d = d === void 0 ? ra : x('<script nonce="' + F(d) + '">');
      var h = [];
      if (f !== void 0 && h.push(d, ("" + f).replace(wa, xa), sa), e !== void 0)
        for (f = 0; f < e.length; f++)
          h.push(ta, F(e[f]), va);
      if (g !== void 0)
        for (e = 0; e < g.length; e++)
          h.push(ua, F(g[e]), va);
      g = {
        bootstrapChunks: h,
        startInlineScript: d,
        placeholderPrefix: x(c + "P:"),
        segmentPrefix: x(c + "S:"),
        boundaryPrefix: c + "B:",
        idPrefix: c,
        nextSuspenseID: 0,
        sentCompleteSegmentFunction: !1,
        sentCompleteBoundaryFunction: !1,
        sentClientRenderFunction: !1
      }, e = b ? b.namespaceURI : void 0, e = G(e === "http://www.w3.org/2000/svg" ? 2 : e === "http://www.w3.org/1998/Math/MathML" ? 3 : 0, null), f = b ? b.progressiveChunkSize : void 0, d = b ? b.onError : void 0, h = b ? b.onAllReady : void 0;
      var m = b ? b.onShellReady : void 0, n = b ? b.onShellError : void 0;
      return b = [], c = /* @__PURE__ */ new Set(), g = {
        destination: null,
        responseState: g,
        progressiveChunkSize: f === void 0 ? 12800 : f,
        status: 0,
        fatalError: null,
        nextSegmentId: 0,
        allPendingTasks: 0,
        pendingRootTasks: 0,
        completedRootSegment: null,
        abortableTasks: c,
        pingedTasks: b,
        clientRenderedBoundaries: [],
        completedBoundaries: [],
        partialBoundaries: [],
        onError: d === void 0 ? Oc : d,
        onAllReady: h === void 0 ? X : h,
        onShellReady: m === void 0 ? X : m,
        onShellError: n === void 0 ? X : n,
        onFatalError: X
      }, e = Sc(g, 0, null, e, !1, !1), e.parentFlushed = !0, a = Rc(g, a, null, e, c, hc, null, qc), b.push(a), g;
    }
    exports.renderToPipeableStream = function(a, b) {
      var c = od(a, b), d = !1;
      return jd(c), { pipe: function(a2) {
        if (d)
          throw Error("React currently only supports piping to one writable stream.");
        return d = !0, kd(c, a2), a2.on("drain", md(a2, c)), a2.on("error", nd(c, Error("The destination stream errored while writing data."))), a2.on("close", nd(c, Error("The destination stream closed early."))), a2;
      }, abort: function(a2) {
        ld(c, a2);
      } };
    };
    exports.version = "18.2.0";
  }
});

// node_modules/react-dom/server.node.js
var require_server_node = __commonJS({
  "node_modules/react-dom/server.node.js"(exports) {
    "use strict";
    var l, s;
    l = require_react_dom_server_legacy_node_production_min(), s = require_react_dom_server_node_production_min();
    exports.version = l.version;
    exports.renderToString = l.renderToString;
    exports.renderToStaticMarkup = l.renderToStaticMarkup;
    exports.renderToNodeStream = l.renderToNodeStream;
    exports.renderToStaticNodeStream = l.renderToStaticNodeStream;
    exports.renderToPipeableStream = s.renderToPipeableStream;
  }
});

// node_modules/react/cjs/react-jsx-runtime.production.min.js
var require_react_jsx_runtime_production_min = __commonJS({
  "node_modules/react/cjs/react-jsx-runtime.production.min.js"(exports) {
    "use strict";
    var f = require_react(), k = Symbol.for("react.element"), l = Symbol.for("react.fragment"), m = Object.prototype.hasOwnProperty, n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p = { key: !0, ref: !0, __self: !0, __source: !0 };
    function q(c, a, g) {
      var b, d = {}, e = null, h = null;
      g !== void 0 && (e = "" + g), a.key !== void 0 && (e = "" + a.key), a.ref !== void 0 && (h = a.ref);
      for (b in a)
        m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
      if (c && c.defaultProps)
        for (b in a = c.defaultProps, a)
          d[b] === void 0 && (d[b] = a[b]);
      return { $$typeof: k, type: c, key: e, ref: h, props: d, _owner: n.current };
    }
    exports.Fragment = l;
    exports.jsx = q;
    exports.jsxs = q;
  }
});

// node_modules/react/jsx-runtime.js
var require_jsx_runtime = __commonJS({
  "node_modules/react/jsx-runtime.js"(exports, module2) {
    "use strict";
    module2.exports = require_react_jsx_runtime_production_min();
  }
});

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports, module2) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols, hasOwnProperty2 = Object.prototype.hasOwnProperty, propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val == null)
        throw new TypeError("Object.assign cannot be called with null or undefined");
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign)
          return !1;
        var test1 = new String("abc");
        if (test1[5] = "de", Object.getOwnPropertyNames(test1)[0] === "5")
          return !1;
        for (var test2 = {}, i = 0; i < 10; i++)
          test2["_" + String.fromCharCode(i)] = i;
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789")
          return !1;
        var test3 = {};
        return "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        }), Object.keys(Object.assign({}, test3)).join("") === "abcdefghijklmnopqrst";
      } catch {
        return !1;
      }
    }
    module2.exports = shouldUseNative() ? Object.assign : function(target, source) {
      for (var from, to = toObject(target), symbols, s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from)
          hasOwnProperty2.call(from, key) && (to[key] = from[key]);
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i = 0; i < symbols.length; i++)
            propIsEnumerable.call(from, symbols[i]) && (to[symbols[i]] = from[symbols[i]]);
        }
      }
      return to;
    };
  }
});

// node_modules/react-star-ratings/node_modules/react/cjs/react.production.min.js
var require_react_production_min2 = __commonJS({
  "node_modules/react-star-ratings/node_modules/react/cjs/react.production.min.js"(exports) {
    "use strict";
    var l = require_object_assign(), n = typeof Symbol == "function" && Symbol.for, p = n ? Symbol.for("react.element") : 60103, q = n ? Symbol.for("react.portal") : 60106, r = n ? Symbol.for("react.fragment") : 60107, t = n ? Symbol.for("react.strict_mode") : 60108, u = n ? Symbol.for("react.profiler") : 60114, v = n ? Symbol.for("react.provider") : 60109, w = n ? Symbol.for("react.context") : 60110, x = n ? Symbol.for("react.forward_ref") : 60112, y = n ? Symbol.for("react.suspense") : 60113, z = n ? Symbol.for("react.memo") : 60115, A = n ? Symbol.for("react.lazy") : 60116, B = typeof Symbol == "function" && Symbol.iterator;
    function C(a) {
      for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++)
        b += "&args[]=" + encodeURIComponent(arguments[c]);
      return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    var D = { isMounted: function() {
      return !1;
    }, enqueueForceUpdate: function() {
    }, enqueueReplaceState: function() {
    }, enqueueSetState: function() {
    } }, E = {};
    function F(a, b, c) {
      this.props = a, this.context = b, this.refs = E, this.updater = c || D;
    }
    F.prototype.isReactComponent = {};
    F.prototype.setState = function(a, b) {
      if (typeof a != "object" && typeof a != "function" && a != null)
        throw Error(C(85));
      this.updater.enqueueSetState(this, a, b, "setState");
    };
    F.prototype.forceUpdate = function(a) {
      this.updater.enqueueForceUpdate(this, a, "forceUpdate");
    };
    function G() {
    }
    G.prototype = F.prototype;
    function H(a, b, c) {
      this.props = a, this.context = b, this.refs = E, this.updater = c || D;
    }
    var I = H.prototype = new G();
    I.constructor = H;
    l(I, F.prototype);
    I.isPureReactComponent = !0;
    var J = { current: null }, K = Object.prototype.hasOwnProperty, L = { key: !0, ref: !0, __self: !0, __source: !0 };
    function M(a, b, c) {
      var e, d = {}, g = null, k = null;
      if (b != null)
        for (e in b.ref !== void 0 && (k = b.ref), b.key !== void 0 && (g = "" + b.key), b)
          K.call(b, e) && !L.hasOwnProperty(e) && (d[e] = b[e]);
      var f = arguments.length - 2;
      if (f === 1)
        d.children = c;
      else if (1 < f) {
        for (var h = Array(f), m = 0; m < f; m++)
          h[m] = arguments[m + 2];
        d.children = h;
      }
      if (a && a.defaultProps)
        for (e in f = a.defaultProps, f)
          d[e] === void 0 && (d[e] = f[e]);
      return { $$typeof: p, type: a, key: g, ref: k, props: d, _owner: J.current };
    }
    function N(a, b) {
      return { $$typeof: p, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
    }
    function O(a) {
      return typeof a == "object" && a !== null && a.$$typeof === p;
    }
    function escape2(a) {
      var b = { "=": "=0", ":": "=2" };
      return "$" + ("" + a).replace(/[=:]/g, function(a2) {
        return b[a2];
      });
    }
    var P = /\/+/g, Q = [];
    function R(a, b, c, e) {
      if (Q.length) {
        var d = Q.pop();
        return d.result = a, d.keyPrefix = b, d.func = c, d.context = e, d.count = 0, d;
      }
      return { result: a, keyPrefix: b, func: c, context: e, count: 0 };
    }
    function S(a) {
      a.result = null, a.keyPrefix = null, a.func = null, a.context = null, a.count = 0, 10 > Q.length && Q.push(a);
    }
    function T(a, b, c, e) {
      var d = typeof a;
      (d === "undefined" || d === "boolean") && (a = null);
      var g = !1;
      if (a === null)
        g = !0;
      else
        switch (d) {
          case "string":
          case "number":
            g = !0;
            break;
          case "object":
            switch (a.$$typeof) {
              case p:
              case q:
                g = !0;
            }
        }
      if (g)
        return c(e, a, b === "" ? "." + U(a, 0) : b), 1;
      if (g = 0, b = b === "" ? "." : b + ":", Array.isArray(a))
        for (var k = 0; k < a.length; k++) {
          d = a[k];
          var f = b + U(d, k);
          g += T(d, f, c, e);
        }
      else if (a === null || typeof a != "object" ? f = null : (f = B && a[B] || a["@@iterator"], f = typeof f == "function" ? f : null), typeof f == "function")
        for (a = f.call(a), k = 0; !(d = a.next()).done; )
          d = d.value, f = b + U(d, k++), g += T(d, f, c, e);
      else if (d === "object")
        throw c = "" + a, Error(C(31, c === "[object Object]" ? "object with keys {" + Object.keys(a).join(", ") + "}" : c, ""));
      return g;
    }
    function V(a, b, c) {
      return a == null ? 0 : T(a, "", b, c);
    }
    function U(a, b) {
      return typeof a == "object" && a !== null && a.key != null ? escape2(a.key) : b.toString(36);
    }
    function W(a, b) {
      a.func.call(a.context, b, a.count++);
    }
    function aa(a, b, c) {
      var e = a.result, d = a.keyPrefix;
      a = a.func.call(a.context, b, a.count++), Array.isArray(a) ? X(a, e, c, function(a2) {
        return a2;
      }) : a != null && (O(a) && (a = N(a, d + (!a.key || b && b.key === a.key ? "" : ("" + a.key).replace(P, "$&/") + "/") + c)), e.push(a));
    }
    function X(a, b, c, e, d) {
      var g = "";
      c != null && (g = ("" + c).replace(P, "$&/") + "/"), b = R(b, g, e, d), V(a, aa, b), S(b);
    }
    var Y = { current: null };
    function Z() {
      var a = Y.current;
      if (a === null)
        throw Error(C(321));
      return a;
    }
    var ba = { ReactCurrentDispatcher: Y, ReactCurrentBatchConfig: { suspense: null }, ReactCurrentOwner: J, IsSomeRendererActing: { current: !1 }, assign: l };
    exports.Children = { map: function(a, b, c) {
      if (a == null)
        return a;
      var e = [];
      return X(a, e, null, b, c), e;
    }, forEach: function(a, b, c) {
      if (a == null)
        return a;
      b = R(null, null, b, c), V(a, W, b), S(b);
    }, count: function(a) {
      return V(a, function() {
        return null;
      }, null);
    }, toArray: function(a) {
      var b = [];
      return X(a, b, null, function(a2) {
        return a2;
      }), b;
    }, only: function(a) {
      if (!O(a))
        throw Error(C(143));
      return a;
    } };
    exports.Component = F;
    exports.Fragment = r;
    exports.Profiler = u;
    exports.PureComponent = H;
    exports.StrictMode = t;
    exports.Suspense = y;
    exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ba;
    exports.cloneElement = function(a, b, c) {
      if (a == null)
        throw Error(C(267, a));
      var e = l({}, a.props), d = a.key, g = a.ref, k = a._owner;
      if (b != null) {
        if (b.ref !== void 0 && (g = b.ref, k = J.current), b.key !== void 0 && (d = "" + b.key), a.type && a.type.defaultProps)
          var f = a.type.defaultProps;
        for (h in b)
          K.call(b, h) && !L.hasOwnProperty(h) && (e[h] = b[h] === void 0 && f !== void 0 ? f[h] : b[h]);
      }
      var h = arguments.length - 2;
      if (h === 1)
        e.children = c;
      else if (1 < h) {
        f = Array(h);
        for (var m = 0; m < h; m++)
          f[m] = arguments[m + 2];
        e.children = f;
      }
      return {
        $$typeof: p,
        type: a.type,
        key: d,
        ref: g,
        props: e,
        _owner: k
      };
    };
    exports.createContext = function(a, b) {
      return b === void 0 && (b = null), a = { $$typeof: w, _calculateChangedBits: b, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null }, a.Provider = { $$typeof: v, _context: a }, a.Consumer = a;
    };
    exports.createElement = M;
    exports.createFactory = function(a) {
      var b = M.bind(null, a);
      return b.type = a, b;
    };
    exports.createRef = function() {
      return { current: null };
    };
    exports.forwardRef = function(a) {
      return { $$typeof: x, render: a };
    };
    exports.isValidElement = O;
    exports.lazy = function(a) {
      return { $$typeof: A, _ctor: a, _status: -1, _result: null };
    };
    exports.memo = function(a, b) {
      return { $$typeof: z, type: a, compare: b === void 0 ? null : b };
    };
    exports.useCallback = function(a, b) {
      return Z().useCallback(a, b);
    };
    exports.useContext = function(a, b) {
      return Z().useContext(a, b);
    };
    exports.useDebugValue = function() {
    };
    exports.useEffect = function(a, b) {
      return Z().useEffect(a, b);
    };
    exports.useImperativeHandle = function(a, b, c) {
      return Z().useImperativeHandle(a, b, c);
    };
    exports.useLayoutEffect = function(a, b) {
      return Z().useLayoutEffect(a, b);
    };
    exports.useMemo = function(a, b) {
      return Z().useMemo(a, b);
    };
    exports.useReducer = function(a, b, c) {
      return Z().useReducer(a, b, c);
    };
    exports.useRef = function(a) {
      return Z().useRef(a);
    };
    exports.useState = function(a) {
      return Z().useState(a);
    };
    exports.version = "16.14.0";
  }
});

// node_modules/react-star-ratings/node_modules/react/index.js
var require_react2 = __commonJS({
  "node_modules/react-star-ratings/node_modules/react/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_react_production_min2();
  }
});

// node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module2) {
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module2.exports = ReactPropTypesSecret;
  }
});

// node_modules/prop-types/factoryWithThrowingShims.js
var require_factoryWithThrowingShims = __commonJS({
  "node_modules/prop-types/factoryWithThrowingShims.js"(exports, module2) {
    "use strict";
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    function emptyFunction() {
    }
    function emptyFunctionWithReset() {
    }
    emptyFunctionWithReset.resetWarningCache = emptyFunction;
    module2.exports = function() {
      function shim(props, propName, componentName, location, propFullName, secret) {
        if (secret !== ReactPropTypesSecret) {
          var err = new Error(
            "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
          );
          throw err.name = "Invariant Violation", err;
        }
      }
      shim.isRequired = shim;
      function getShim() {
        return shim;
      }
      var ReactPropTypes = {
        array: shim,
        bigint: shim,
        bool: shim,
        func: shim,
        number: shim,
        object: shim,
        string: shim,
        symbol: shim,
        any: shim,
        arrayOf: getShim,
        element: shim,
        elementType: shim,
        instanceOf: getShim,
        node: shim,
        objectOf: getShim,
        oneOf: getShim,
        oneOfType: getShim,
        shape: getShim,
        exact: getShim,
        checkPropTypes: emptyFunctionWithReset,
        resetWarningCache: emptyFunction
      };
      return ReactPropTypes.PropTypes = ReactPropTypes, ReactPropTypes;
    };
  }
});

// node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  "node_modules/prop-types/index.js"(exports, module2) {
    module2.exports = require_factoryWithThrowingShims()();
    var ReactIs, throwOnDirectAccess;
  }
});

// node_modules/classnames/index.js
var require_classnames = __commonJS({
  "node_modules/classnames/index.js"(exports, module2) {
    (function() {
      "use strict";
      var hasOwn = {}.hasOwnProperty, nativeCodeString = "[native code]";
      function classNames() {
        for (var classes = [], i = 0; i < arguments.length; i++) {
          var arg = arguments[i];
          if (arg) {
            var argType = typeof arg;
            if (argType === "string" || argType === "number")
              classes.push(arg);
            else if (Array.isArray(arg)) {
              if (arg.length) {
                var inner = classNames.apply(null, arg);
                inner && classes.push(inner);
              }
            } else if (argType === "object") {
              if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
                classes.push(arg.toString());
                continue;
              }
              for (var key in arg)
                hasOwn.call(arg, key) && arg[key] && classes.push(key);
            }
          }
        }
        return classes.join(" ");
      }
      typeof module2 < "u" && module2.exports ? (classNames.default = classNames, module2.exports = classNames) : typeof define == "function" && typeof define.amd == "object" && define.amd ? define("classnames", [], function() {
        return classNames;
      }) : window.classNames = classNames;
    })();
  }
});

// node_modules/react-star-ratings/build/star.js
var require_star = __commonJS({
  "node_modules/react-star-ratings/build/star.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    var _createClass = function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor;
      };
    }(), _react = require_react2(), _react2 = _interopRequireDefault(_react), _classnames = require_classnames(), _classnames2 = _interopRequireDefault(_classnames), _propTypes = require_prop_types(), _propTypes2 = _interopRequireDefault(_propTypes);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _possibleConstructorReturn(self2, call) {
      if (!self2)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return call && (typeof call == "object" || typeof call == "function") ? call : self2;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: !1, writable: !0, configurable: !0 } }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
    }
    var Star = function(_React$Component) {
      _inherits(Star2, _React$Component);
      function Star2() {
        return _classCallCheck(this, Star2), _possibleConstructorReturn(this, (Star2.__proto__ || Object.getPrototypeOf(Star2)).apply(this, arguments));
      }
      return _createClass(Star2, [{
        key: "render",
        value: function() {
          var _props = this.props, changeRating = _props.changeRating, hoverOverStar = _props.hoverOverStar, unHoverOverStar = _props.unHoverOverStar, svgIconViewBox = _props.svgIconViewBox, svgIconPath = _props.svgIconPath;
          return _react2.default.createElement(
            "div",
            {
              className: "star-container",
              style: this.starContainerStyle,
              onMouseEnter: hoverOverStar,
              onMouseLeave: unHoverOverStar,
              onClick: changeRating
            },
            _react2.default.createElement(
              "svg",
              {
                viewBox: svgIconViewBox,
                className: this.starClasses,
                style: this.starSvgStyle
              },
              _react2.default.createElement("path", {
                className: "star",
                style: this.pathStyle,
                d: svgIconPath
              })
            )
          );
        }
      }, {
        key: "starContainerStyle",
        get: function() {
          var _props2 = this.props, changeRating = _props2.changeRating, starSpacing = _props2.starSpacing, isFirstStar = _props2.isFirstStar, isLastStar = _props2.isLastStar, ignoreInlineStyles = _props2.ignoreInlineStyles, starContainerStyle = {
            position: "relative",
            display: "inline-block",
            verticalAlign: "middle",
            paddingLeft: isFirstStar ? void 0 : starSpacing,
            paddingRight: isLastStar ? void 0 : starSpacing,
            cursor: changeRating ? "pointer" : void 0
          };
          return ignoreInlineStyles ? {} : starContainerStyle;
        }
      }, {
        key: "starSvgStyle",
        get: function() {
          var _props3 = this.props, ignoreInlineStyles = _props3.ignoreInlineStyles, isCurrentHoveredStar = _props3.isCurrentHoveredStar, starDimension = _props3.starDimension, starSvgStyle = {
            width: starDimension,
            height: starDimension,
            transition: "transform .2s ease-in-out",
            transform: isCurrentHoveredStar ? "scale(1.1)" : void 0
          };
          return ignoreInlineStyles ? {} : starSvgStyle;
        }
      }, {
        key: "pathStyle",
        get: function() {
          var _props4 = this.props, isStarred = _props4.isStarred, isPartiallyFullStar = _props4.isPartiallyFullStar, isHovered = _props4.isHovered, hoverMode = _props4.hoverMode, starEmptyColor = _props4.starEmptyColor, starRatedColor = _props4.starRatedColor, starHoverColor = _props4.starHoverColor, gradientPathName = _props4.gradientPathName, fillId = _props4.fillId, ignoreInlineStyles = _props4.ignoreInlineStyles, fill = void 0;
          hoverMode ? isHovered ? fill = starHoverColor : fill = starEmptyColor : isPartiallyFullStar ? fill = "url('" + gradientPathName + "#" + fillId + "')" : isStarred ? fill = starRatedColor : fill = starEmptyColor;
          var pathStyle = {
            fill,
            transition: "fill .2s ease-in-out"
          };
          return ignoreInlineStyles ? {} : pathStyle;
        }
      }, {
        key: "starClasses",
        get: function() {
          var _props5 = this.props, isSelected = _props5.isSelected, isPartiallyFullStar = _props5.isPartiallyFullStar, isHovered = _props5.isHovered, isCurrentHoveredStar = _props5.isCurrentHoveredStar, ignoreInlineStyles = _props5.ignoreInlineStyles, starClasses = (0, _classnames2.default)({
            "widget-svg": !0,
            "widget-selected": isSelected,
            "multi-widget-selected": isPartiallyFullStar,
            hovered: isHovered,
            "current-hovered": isCurrentHoveredStar
          });
          return ignoreInlineStyles ? {} : starClasses;
        }
      }]), Star2;
    }(_react2.default.Component);
    Star.propTypes = {
      fillId: _propTypes2.default.string.isRequired,
      changeRating: _propTypes2.default.func,
      hoverOverStar: _propTypes2.default.func,
      unHoverOverStar: _propTypes2.default.func,
      isStarred: _propTypes2.default.bool.isRequired,
      isPartiallyFullStar: _propTypes2.default.bool.isRequired,
      isHovered: _propTypes2.default.bool.isRequired,
      hoverMode: _propTypes2.default.bool.isRequired,
      isCurrentHoveredStar: _propTypes2.default.bool.isRequired,
      isFirstStar: _propTypes2.default.bool.isRequired,
      isLastStar: _propTypes2.default.bool.isRequired,
      starDimension: _propTypes2.default.string.isRequired,
      starSpacing: _propTypes2.default.string.isRequired,
      starHoverColor: _propTypes2.default.string.isRequired,
      starRatedColor: _propTypes2.default.string.isRequired,
      starEmptyColor: _propTypes2.default.string.isRequired,
      gradientPathName: _propTypes2.default.string.isRequired,
      ignoreInlineStyles: _propTypes2.default.bool.isRequired,
      svgIconPath: _propTypes2.default.string.isRequired,
      svgIconViewBox: _propTypes2.default.string.isRequired
    };
    exports.default = Star;
  }
});

// node_modules/react-star-ratings/build/star-ratings.js
var require_star_ratings = __commonJS({
  "node_modules/react-star-ratings/build/star-ratings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    var _createClass = function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor;
      };
    }(), _react = require_react2(), _react2 = _interopRequireDefault(_react), _propTypes = require_prop_types(), _propTypes2 = _interopRequireDefault(_propTypes), _star = require_star(), _star2 = _interopRequireDefault(_star);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor))
        throw new TypeError("Cannot call a class as a function");
    }
    function _possibleConstructorReturn(self2, call) {
      if (!self2)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return call && (typeof call == "object" || typeof call == "function") ? call : self2;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass != "function" && superClass !== null)
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: !1, writable: !0, configurable: !0 } }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
    }
    var StarRatings2 = function(_React$Component) {
      _inherits(StarRatings3, _React$Component);
      function StarRatings3() {
        var _ref, _temp, _this, _ret;
        _classCallCheck(this, StarRatings3);
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++)
          args[_key] = arguments[_key];
        return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = StarRatings3.__proto__ || Object.getPrototypeOf(StarRatings3)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
          highestStarHovered: -1 / 0
        }, _this.fillId = "starGrad" + Math.random().toFixed(15).slice(2), _this.hoverOverStar = function(starRating) {
          return function() {
            _this.setState({
              highestStarHovered: starRating
            });
          };
        }, _this.unHoverOverStar = function() {
          _this.setState({
            highestStarHovered: -1 / 0
          });
        }, _temp), _possibleConstructorReturn(_this, _ret);
      }
      return _createClass(StarRatings3, [{
        key: "stopColorStyle",
        value: function(color) {
          var stopColorStyle2 = {
            stopColor: color,
            stopOpacity: "1"
          };
          return this.props.ignoreInlineStyles ? {} : stopColorStyle2;
        }
      }, {
        key: "render",
        value: function() {
          var _props = this.props, starRatedColor = _props.starRatedColor, starEmptyColor = _props.starEmptyColor;
          return _react2.default.createElement(
            "div",
            {
              className: "star-ratings",
              title: this.titleText,
              style: this.starRatingsStyle
            },
            _react2.default.createElement(
              "svg",
              {
                className: "star-grad",
                style: this.starGradientStyle
              },
              _react2.default.createElement(
                "defs",
                null,
                _react2.default.createElement(
                  "linearGradient",
                  { id: this.fillId, x1: "0%", y1: "0%", x2: "100%", y2: "0%" },
                  _react2.default.createElement("stop", { offset: "0%", className: "stop-color-first", style: this.stopColorStyle(starRatedColor) }),
                  _react2.default.createElement("stop", { offset: this.offsetValue, className: "stop-color-first", style: this.stopColorStyle(starRatedColor) }),
                  _react2.default.createElement("stop", { offset: this.offsetValue, className: "stop-color-final", style: this.stopColorStyle(starEmptyColor) }),
                  _react2.default.createElement("stop", { offset: "100%", className: "stop-color-final", style: this.stopColorStyle(starEmptyColor) })
                )
              )
            ),
            this.renderStars
          );
        }
      }, {
        key: "starRatingsStyle",
        get: function() {
          var starRatingsStyle = {
            position: "relative",
            boxSizing: "border-box",
            display: "inline-block"
          };
          return this.props.ignoreInlineStyles ? {} : starRatingsStyle;
        }
      }, {
        key: "starGradientStyle",
        get: function() {
          var starGradientStyle = {
            position: "absolute",
            zIndex: "0",
            width: "0",
            height: "0",
            visibility: "hidden"
          };
          return this.props.ignoreInlineStyles ? {} : starGradientStyle;
        }
      }, {
        key: "titleText",
        get: function() {
          var _props2 = this.props, typeOfWidget = _props2.typeOfWidget, selectedRating = _props2.rating, hoveredRating = this.state.highestStarHovered, currentRating = hoveredRating > 0 ? hoveredRating : selectedRating, formattedRating = parseFloat(currentRating.toFixed(2)).toString();
          Number.isInteger(currentRating) && (formattedRating = String(currentRating));
          var starText = typeOfWidget + "s";
          return formattedRating === "1" && (starText = typeOfWidget), formattedRating + " " + starText;
        }
      }, {
        key: "offsetValue",
        get: function() {
          var rating = this.props.rating, ratingIsInteger = Number.isInteger(rating), offsetValue = "0%";
          if (!ratingIsInteger) {
            var firstTwoDecimals = rating.toFixed(2).split(".")[1].slice(0, 2);
            offsetValue = firstTwoDecimals + "%";
          }
          return offsetValue;
        }
      }, {
        key: "renderStars",
        get: function() {
          var _this2 = this, _props3 = this.props, changeRating = _props3.changeRating, selectedRating = _props3.rating, numberOfStars = _props3.numberOfStars, starDimension = _props3.starDimension, starSpacing = _props3.starSpacing, starRatedColor = _props3.starRatedColor, starEmptyColor = _props3.starEmptyColor, starHoverColor = _props3.starHoverColor, gradientPathName = _props3.gradientPathName, ignoreInlineStyles = _props3.ignoreInlineStyles, svgIconPath = _props3.svgIconPath, svgIconViewBox = _props3.svgIconViewBox, name = _props3.name, highestStarHovered = this.state.highestStarHovered, numberOfStarsArray = Array.apply(null, Array(numberOfStars));
          return numberOfStarsArray.map(function(_, index) {
            var starRating = index + 1, isStarred = starRating <= selectedRating, hoverMode = highestStarHovered > 0, isHovered = starRating <= highestStarHovered, isCurrentHoveredStar = starRating === highestStarHovered, isPartiallyFullStar = starRating > selectedRating && starRating - 1 < selectedRating, isFirstStar = starRating === 1, isLastStar = starRating === numberOfStars;
            return _react2.default.createElement(_star2.default, {
              key: starRating,
              fillId: _this2.fillId,
              changeRating: changeRating ? function() {
                return changeRating(starRating, name);
              } : null,
              hoverOverStar: changeRating ? _this2.hoverOverStar(starRating) : null,
              unHoverOverStar: changeRating ? _this2.unHoverOverStar : null,
              isStarred,
              isPartiallyFullStar,
              isHovered,
              hoverMode,
              isCurrentHoveredStar,
              isFirstStar,
              isLastStar,
              starDimension,
              starSpacing,
              starHoverColor,
              starRatedColor,
              starEmptyColor,
              gradientPathName,
              ignoreInlineStyles,
              svgIconPath,
              svgIconViewBox
            });
          });
        }
      }]), StarRatings3;
    }(_react2.default.Component);
    StarRatings2.propTypes = {
      rating: _propTypes2.default.number.isRequired,
      numberOfStars: _propTypes2.default.number.isRequired,
      changeRating: _propTypes2.default.func,
      starHoverColor: _propTypes2.default.string.isRequired,
      starRatedColor: _propTypes2.default.string.isRequired,
      starEmptyColor: _propTypes2.default.string.isRequired,
      starDimension: _propTypes2.default.string.isRequired,
      starSpacing: _propTypes2.default.string.isRequired,
      gradientPathName: _propTypes2.default.string.isRequired,
      ignoreInlineStyles: _propTypes2.default.bool.isRequired,
      svgIconPath: _propTypes2.default.string.isRequired,
      svgIconViewBox: _propTypes2.default.string.isRequired,
      name: _propTypes2.default.string
    };
    StarRatings2.defaultProps = {
      rating: 0,
      typeOfWidget: "Star",
      numberOfStars: 5,
      changeRating: null,
      starHoverColor: "rgb(230, 67, 47)",
      starRatedColor: "rgb(109, 122, 130)",
      starEmptyColor: "rgb(203, 211, 227)",
      starDimension: "50px",
      starSpacing: "7px",
      gradientPathName: "",
      ignoreInlineStyles: !1,
      svgIconPath: "m25,1 6,17h18l-14,11 5,17-15-10-15,10 5-17-14-11h18z",
      svgIconViewBox: "0 0 51 48"
    };
    exports.default = StarRatings2;
  }
});

// node_modules/react-star-ratings/build/index.js
var require_build = __commonJS({
  "node_modules/react-star-ratings/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    var _starRatings = require_star_ratings(), _starRatings2 = _interopRequireDefault(_starRatings);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    Number.isInteger = Number.isInteger || function(value) {
      return typeof value == "number" && isFinite(value) && Math.floor(value) === value;
    };
    exports.default = _starRatings2.default;
  }
});

// node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS({
  "node_modules/delayed-stream/lib/delayed_stream.js"(exports, module2) {
    var Stream = require("stream").Stream, util2 = require("util");
    module2.exports = DelayedStream;
    function DelayedStream() {
      this.source = null, this.dataSize = 0, this.maxDataSize = 1024 * 1024, this.pauseStream = !0, this._maxDataSizeExceeded = !1, this._released = !1, this._bufferedEvents = [];
    }
    util2.inherits(DelayedStream, Stream);
    DelayedStream.create = function(source, options) {
      var delayedStream = new this();
      options = options || {};
      for (var option in options)
        delayedStream[option] = options[option];
      delayedStream.source = source;
      var realEmit = source.emit;
      return source.emit = function() {
        return delayedStream._handleEmit(arguments), realEmit.apply(source, arguments);
      }, source.on("error", function() {
      }), delayedStream.pauseStream && source.pause(), delayedStream;
    };
    Object.defineProperty(DelayedStream.prototype, "readable", {
      configurable: !0,
      enumerable: !0,
      get: function() {
        return this.source.readable;
      }
    });
    DelayedStream.prototype.setEncoding = function() {
      return this.source.setEncoding.apply(this.source, arguments);
    };
    DelayedStream.prototype.resume = function() {
      this._released || this.release(), this.source.resume();
    };
    DelayedStream.prototype.pause = function() {
      this.source.pause();
    };
    DelayedStream.prototype.release = function() {
      this._released = !0, this._bufferedEvents.forEach(function(args) {
        this.emit.apply(this, args);
      }.bind(this)), this._bufferedEvents = [];
    };
    DelayedStream.prototype.pipe = function() {
      var r = Stream.prototype.pipe.apply(this, arguments);
      return this.resume(), r;
    };
    DelayedStream.prototype._handleEmit = function(args) {
      if (this._released) {
        this.emit.apply(this, args);
        return;
      }
      args[0] === "data" && (this.dataSize += args[1].length, this._checkIfMaxDataSizeExceeded()), this._bufferedEvents.push(args);
    };
    DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
      if (!this._maxDataSizeExceeded && !(this.dataSize <= this.maxDataSize)) {
        this._maxDataSizeExceeded = !0;
        var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
        this.emit("error", new Error(message));
      }
    };
  }
});

// node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS({
  "node_modules/combined-stream/lib/combined_stream.js"(exports, module2) {
    var util2 = require("util"), Stream = require("stream").Stream, DelayedStream = require_delayed_stream();
    module2.exports = CombinedStream;
    function CombinedStream() {
      this.writable = !1, this.readable = !0, this.dataSize = 0, this.maxDataSize = 2 * 1024 * 1024, this.pauseStreams = !0, this._released = !1, this._streams = [], this._currentStream = null, this._insideLoop = !1, this._pendingNext = !1;
    }
    util2.inherits(CombinedStream, Stream);
    CombinedStream.create = function(options) {
      var combinedStream = new this();
      options = options || {};
      for (var option in options)
        combinedStream[option] = options[option];
      return combinedStream;
    };
    CombinedStream.isStreamLike = function(stream4) {
      return typeof stream4 != "function" && typeof stream4 != "string" && typeof stream4 != "boolean" && typeof stream4 != "number" && !Buffer.isBuffer(stream4);
    };
    CombinedStream.prototype.append = function(stream4) {
      var isStreamLike = CombinedStream.isStreamLike(stream4);
      if (isStreamLike) {
        if (!(stream4 instanceof DelayedStream)) {
          var newStream = DelayedStream.create(stream4, {
            maxDataSize: 1 / 0,
            pauseStream: this.pauseStreams
          });
          stream4.on("data", this._checkDataSize.bind(this)), stream4 = newStream;
        }
        this._handleErrors(stream4), this.pauseStreams && stream4.pause();
      }
      return this._streams.push(stream4), this;
    };
    CombinedStream.prototype.pipe = function(dest, options) {
      return Stream.prototype.pipe.call(this, dest, options), this.resume(), dest;
    };
    CombinedStream.prototype._getNext = function() {
      if (this._currentStream = null, this._insideLoop) {
        this._pendingNext = !0;
        return;
      }
      this._insideLoop = !0;
      try {
        do
          this._pendingNext = !1, this._realGetNext();
        while (this._pendingNext);
      } finally {
        this._insideLoop = !1;
      }
    };
    CombinedStream.prototype._realGetNext = function() {
      var stream4 = this._streams.shift();
      if (typeof stream4 > "u") {
        this.end();
        return;
      }
      if (typeof stream4 != "function") {
        this._pipeNext(stream4);
        return;
      }
      var getStream = stream4;
      getStream(function(stream5) {
        var isStreamLike = CombinedStream.isStreamLike(stream5);
        isStreamLike && (stream5.on("data", this._checkDataSize.bind(this)), this._handleErrors(stream5)), this._pipeNext(stream5);
      }.bind(this));
    };
    CombinedStream.prototype._pipeNext = function(stream4) {
      this._currentStream = stream4;
      var isStreamLike = CombinedStream.isStreamLike(stream4);
      if (isStreamLike) {
        stream4.on("end", this._getNext.bind(this)), stream4.pipe(this, { end: !1 });
        return;
      }
      var value = stream4;
      this.write(value), this._getNext();
    };
    CombinedStream.prototype._handleErrors = function(stream4) {
      var self2 = this;
      stream4.on("error", function(err) {
        self2._emitError(err);
      });
    };
    CombinedStream.prototype.write = function(data) {
      this.emit("data", data);
    };
    CombinedStream.prototype.pause = function() {
      this.pauseStreams && (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function" && this._currentStream.pause(), this.emit("pause"));
    };
    CombinedStream.prototype.resume = function() {
      this._released || (this._released = !0, this.writable = !0, this._getNext()), this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function" && this._currentStream.resume(), this.emit("resume");
    };
    CombinedStream.prototype.end = function() {
      this._reset(), this.emit("end");
    };
    CombinedStream.prototype.destroy = function() {
      this._reset(), this.emit("close");
    };
    CombinedStream.prototype._reset = function() {
      this.writable = !1, this._streams = [], this._currentStream = null;
    };
    CombinedStream.prototype._checkDataSize = function() {
      if (this._updateDataSize(), !(this.dataSize <= this.maxDataSize)) {
        var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
        this._emitError(new Error(message));
      }
    };
    CombinedStream.prototype._updateDataSize = function() {
      this.dataSize = 0;
      var self2 = this;
      this._streams.forEach(function(stream4) {
        stream4.dataSize && (self2.dataSize += stream4.dataSize);
      }), this._currentStream && this._currentStream.dataSize && (this.dataSize += this._currentStream.dataSize);
    };
    CombinedStream.prototype._emitError = function(err) {
      this._reset(), this.emit("error", err);
    };
  }
});

// node_modules/mime-db/db.json
var require_db = __commonJS({
  "node_modules/mime-db/db.json"(exports, module2) {
    module2.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: !0
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: !0
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: !0
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: !0
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: !0
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: !0
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: !0
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: !0
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: !0
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: !0
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: !0
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: !0
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: !0
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: !0
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: !0
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: !0
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: !0
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: !0
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: !0
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: !1
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: !1,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: !0
      },
      "application/calendar+json": {
        source: "iana",
        compressible: !0
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: !0
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: !0
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: !0
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: !0
      },
      "application/cfw": {
        source: "iana"
      },
      "application/city+json": {
        source: "iana",
        compressible: !0
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: !0
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: !0
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: !0
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: !0
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: !0
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["cpl"]
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: !0
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: !0
      },
      "application/csvm+json": {
        source: "iana",
        compressible: !0
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: !0
      },
      "application/dash+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["mpd"]
      },
      "application/dash-patch+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["mpp"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: !0
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: !0
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: !0
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: !0
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: !0,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: !0
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: !0,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: !1
      },
      "application/edifact": {
        source: "iana",
        compressible: !1
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: !0
      },
      "application/elm+xml": {
        source: "iana",
        compressible: !0
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: !0
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: !0
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: !0
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: !0
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: !0
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: !0
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: !0
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: !0
      },
      "application/emma+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: !0
      },
      "application/epub+zip": {
        source: "iana",
        compressible: !1,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: !0
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: !0
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: !0
      },
      "application/fido.trusted-apps+json": {
        compressible: !0
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: !1
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: !0
      },
      "application/geo+json": {
        source: "iana",
        compressible: !0,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: !0
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: !0,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: !1,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: !0
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: !0
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: !0
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: !0
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: !1,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: !1,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: !1,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: !0,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: !0
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: !0
      },
      "application/jrd+json": {
        source: "iana",
        compressible: !0
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: !0
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: !0,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: !0
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: !0,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: !0
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: !0
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: !0
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: !0
      },
      "application/ld+json": {
        source: "iana",
        compressible: !0,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: !0
      },
      "application/lost+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: !0
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: !1
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: !0,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: !0
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: !0
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: !0
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: !0
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: !0
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: !0
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: !0
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: !0
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: !0
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: !0
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: !0
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: !0
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: !0
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["mpf"]
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: !0
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: !0
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: !0,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: !0
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: !0
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: !0
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: !0
      },
      "application/msword": {
        source: "iana",
        compressible: !1,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: !0
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: !0
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/oblivious-dns-message": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: !1,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: !0
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: !1,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: !0,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: !0
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: !1
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: !1,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: !1,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana",
        extensions: ["asc"]
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: !0
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: !0
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: !0
      },
      "application/postscript": {
        source: "iana",
        compressible: !0,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: !0
      },
      "application/problem+json": {
        source: "iana",
        compressible: !0
      },
      "application/problem+xml": {
        source: "iana",
        compressible: !0
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: !1
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: !0
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: !0
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: !0,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: !0
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: !0
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: !0
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: !0
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: !0,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: !0,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: !0,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: !0
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: !0
      },
      "application/sarif+json": {
        source: "iana",
        compressible: !0
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: !0
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: !0
      },
      "application/scim+json": {
        source: "iana",
        compressible: !0
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: !0
      },
      "application/senml+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: !0
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: !0
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: !0
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: !0
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: !0
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["srx"]
      },
      "application/spdx+json": {
        source: "iana",
        compressible: !0
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: !0
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: !0,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: !0
      },
      "application/swid+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: !0
      },
      "application/taxii+json": {
        source: "iana",
        compressible: !0
      },
      "application/td+json": {
        source: "iana",
        compressible: !0
      },
      "application/tei+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: !0
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        compressible: !0,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: !1,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: !0
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vcard+json": {
        source: "iana",
        compressible: !0
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: !1,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.age": {
        source: "iana",
        extensions: ["age"]
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: !1,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: !1,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: !1
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: !1
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: !0,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.eclipse.ditto+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: !1
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: !1
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: !1
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eu.kasparian.car+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: !1
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.familysearch.gedcom+zip": {
        source: "iana",
        compressible: !1
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: !1
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: !1,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: !1,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: !1,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: !1,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: !1
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hl7cda+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: !0
      },
      "application/vnd.hl7v2+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: !0
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: !1
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: !1
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: !1
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: !1
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.maxar.archive.3tz+zip": {
        source: "iana",
        compressible: !1
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: !1,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: !0,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: !0
      },
      "application/vnd.ms-outlook": {
        compressible: !1,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: !1,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: !0
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: !1,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.nacamar.ybrid+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: !1,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: !1,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: !1,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: !1,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: !0
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: !0
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: !0
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: !1,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: !1,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: !1,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.syft+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: !0,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: !0,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: !0,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: !0
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: !0
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: !0
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: !0,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["wif"]
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: !0
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: !1,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: !1,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: !1,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: !1,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: !1,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: !1
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: !0,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: !0,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: !0,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: !1,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: !0,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: !1,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: !0
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: !1,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: !1
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: !0,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: !1,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: !1,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: !0,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: !1,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: !1,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: !0,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: !0,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: !0,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: !0,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: !0,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: !1,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: !0,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: !0,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: !0,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: !0,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: !0
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: !0,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: !1,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: !0
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: !0,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: !0
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: !0
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: !0
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: !0
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: !0,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: !0,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: !0
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: !0
      },
      "application/xop+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: !0,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: !0,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: !0
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: !0
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: !0
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: !0
      },
      "application/yin+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: !1,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: !1,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: !1,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: !1
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: !1,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: !1,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: !1,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: !1,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: !1
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: !1
      },
      "audio/vorbis": {
        source: "iana",
        compressible: !1
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: !1,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: !1,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: !1,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: !1,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: !1,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: !0,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: !0,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: !1,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana",
        extensions: ["avci"]
      },
      "image/avcs": {
        source: "iana",
        extensions: ["avcs"]
      },
      "image/avif": {
        source: "iana",
        compressible: !1,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: !0,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: !1,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: !1,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: !1,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: !1,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: !1,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: !1
      },
      "image/png": {
        source: "iana",
        compressible: !1,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: !1,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: !0,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: !0,
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        compressible: !0,
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: !0,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: !0,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: !1
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: !1
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: !0
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: !1
      },
      "message/rfc822": {
        source: "iana",
        compressible: !0,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: !0,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: !0,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: !1,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: !1,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/step": {
        source: "iana"
      },
      "model/step+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: !1,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: !1,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: !0
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: !1,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: !1,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: !1,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: !1,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: !0,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: !1
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: !1
      },
      "multipart/form-data": {
        source: "iana",
        compressible: !1
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: !1
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: !1
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: !0,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: !0
      },
      "text/cmd": {
        compressible: !0
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: !0,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: !0,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: !0,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: !0
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: !0,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: !0,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: !0,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: !0,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: !0,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: !0,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: !0,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: !0,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: !0,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: !0,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: !0,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: ["ged"]
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: !0,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: !0
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: !0
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: !0,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: !0,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: !0,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: !0,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: !0,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: !0,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: !1,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: !1,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: !1,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: !1,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: !1,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: !1,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: !1,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: !1,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: !0
      },
      "x-shader/x-vertex": {
        compressible: !0
      }
    };
  }
});

// node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  "node_modules/mime-db/index.js"(exports, module2) {
    module2.exports = require_db();
  }
});

// node_modules/mime-types/index.js
var require_mime_types = __commonJS({
  "node_modules/mime-types/index.js"(exports) {
    "use strict";
    var db = require_mime_db(), extname = require("path").extname, EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/, TEXT_TYPE_REGEXP = /^text\//i;
    exports.charset = charset;
    exports.charsets = { lookup: charset };
    exports.contentType = contentType;
    exports.extension = extension;
    exports.extensions = /* @__PURE__ */ Object.create(null);
    exports.lookup = lookup;
    exports.types = /* @__PURE__ */ Object.create(null);
    populateMaps(exports.extensions, exports.types);
    function charset(type) {
      if (!type || typeof type != "string")
        return !1;
      var match = EXTRACT_TYPE_REGEXP.exec(type), mime = match && db[match[1].toLowerCase()];
      return mime && mime.charset ? mime.charset : match && TEXT_TYPE_REGEXP.test(match[1]) ? "UTF-8" : !1;
    }
    function contentType(str) {
      if (!str || typeof str != "string")
        return !1;
      var mime = str.indexOf("/") === -1 ? exports.lookup(str) : str;
      if (!mime)
        return !1;
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports.charset(mime);
        charset2 && (mime += "; charset=" + charset2.toLowerCase());
      }
      return mime;
    }
    function extension(type) {
      if (!type || typeof type != "string")
        return !1;
      var match = EXTRACT_TYPE_REGEXP.exec(type), exts = match && exports.extensions[match[1].toLowerCase()];
      return !exts || !exts.length ? !1 : exts[0];
    }
    function lookup(path) {
      if (!path || typeof path != "string")
        return !1;
      var extension2 = extname("x." + path).toLowerCase().substr(1);
      return extension2 && exports.types[extension2] || !1;
    }
    function populateMaps(extensions, types) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function(type) {
        var mime = db[type], exts = mime.extensions;
        if (!(!exts || !exts.length)) {
          extensions[type] = exts;
          for (var i = 0; i < exts.length; i++) {
            var extension2 = exts[i];
            if (types[extension2]) {
              var from = preference.indexOf(db[types[extension2]].source), to = preference.indexOf(mime.source);
              if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/"))
                continue;
            }
            types[extension2] = type;
          }
        }
      });
    }
  }
});

// node_modules/asynckit/lib/defer.js
var require_defer = __commonJS({
  "node_modules/asynckit/lib/defer.js"(exports, module2) {
    module2.exports = defer;
    function defer(fn) {
      var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
      nextTick ? nextTick(fn) : setTimeout(fn, 0);
    }
  }
});

// node_modules/asynckit/lib/async.js
var require_async = __commonJS({
  "node_modules/asynckit/lib/async.js"(exports, module2) {
    var defer = require_defer();
    module2.exports = async;
    function async(callback) {
      var isAsync = !1;
      return defer(function() {
        isAsync = !0;
      }), function(err, result) {
        isAsync ? callback(err, result) : defer(function() {
          callback(err, result);
        });
      };
    }
  }
});

// node_modules/asynckit/lib/abort.js
var require_abort = __commonJS({
  "node_modules/asynckit/lib/abort.js"(exports, module2) {
    module2.exports = abort;
    function abort(state) {
      Object.keys(state.jobs).forEach(clean.bind(state)), state.jobs = {};
    }
    function clean(key) {
      typeof this.jobs[key] == "function" && this.jobs[key]();
    }
  }
});

// node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS({
  "node_modules/asynckit/lib/iterate.js"(exports, module2) {
    var async = require_async(), abort = require_abort();
    module2.exports = iterate;
    function iterate(list2, iterator, state, callback) {
      var key = state.keyedList ? state.keyedList[state.index] : state.index;
      state.jobs[key] = runJob(iterator, key, list2[key], function(error, output) {
        key in state.jobs && (delete state.jobs[key], error ? abort(state) : state.results[key] = output, callback(error, state.results));
      });
    }
    function runJob(iterator, key, item, callback) {
      var aborter;
      return iterator.length == 2 ? aborter = iterator(item, async(callback)) : aborter = iterator(item, key, async(callback)), aborter;
    }
  }
});

// node_modules/asynckit/lib/state.js
var require_state = __commonJS({
  "node_modules/asynckit/lib/state.js"(exports, module2) {
    module2.exports = state;
    function state(list2, sortMethod) {
      var isNamedList = !Array.isArray(list2), initState = {
        index: 0,
        keyedList: isNamedList || sortMethod ? Object.keys(list2) : null,
        jobs: {},
        results: isNamedList ? {} : [],
        size: isNamedList ? Object.keys(list2).length : list2.length
      };
      return sortMethod && initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
        return sortMethod(list2[a], list2[b]);
      }), initState;
    }
  }
});

// node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS({
  "node_modules/asynckit/lib/terminator.js"(exports, module2) {
    var abort = require_abort(), async = require_async();
    module2.exports = terminator;
    function terminator(callback) {
      Object.keys(this.jobs).length && (this.index = this.size, abort(this), async(callback)(null, this.results));
    }
  }
});

// node_modules/asynckit/parallel.js
var require_parallel = __commonJS({
  "node_modules/asynckit/parallel.js"(exports, module2) {
    var iterate = require_iterate(), initState = require_state(), terminator = require_terminator();
    module2.exports = parallel;
    function parallel(list2, iterator, callback) {
      for (var state = initState(list2); state.index < (state.keyedList || list2).length; )
        iterate(list2, iterator, state, function(error, result) {
          if (error) {
            callback(error, result);
            return;
          }
          if (Object.keys(state.jobs).length === 0) {
            callback(null, state.results);
            return;
          }
        }), state.index++;
      return terminator.bind(state, callback);
    }
  }
});

// node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS({
  "node_modules/asynckit/serialOrdered.js"(exports, module2) {
    var iterate = require_iterate(), initState = require_state(), terminator = require_terminator();
    module2.exports = serialOrdered;
    module2.exports.ascending = ascending;
    module2.exports.descending = descending;
    function serialOrdered(list2, iterator, sortMethod, callback) {
      var state = initState(list2, sortMethod);
      return iterate(list2, iterator, state, function iteratorHandler(error, result) {
        if (error) {
          callback(error, result);
          return;
        }
        if (state.index++, state.index < (state.keyedList || list2).length) {
          iterate(list2, iterator, state, iteratorHandler);
          return;
        }
        callback(null, state.results);
      }), terminator.bind(state, callback);
    }
    function ascending(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }
    function descending(a, b) {
      return -1 * ascending(a, b);
    }
  }
});

// node_modules/asynckit/serial.js
var require_serial = __commonJS({
  "node_modules/asynckit/serial.js"(exports, module2) {
    var serialOrdered = require_serialOrdered();
    module2.exports = serial;
    function serial(list2, iterator, callback) {
      return serialOrdered(list2, iterator, null, callback);
    }
  }
});

// node_modules/asynckit/index.js
var require_asynckit = __commonJS({
  "node_modules/asynckit/index.js"(exports, module2) {
    module2.exports = {
      parallel: require_parallel(),
      serial: require_serial(),
      serialOrdered: require_serialOrdered()
    };
  }
});

// node_modules/form-data/lib/populate.js
var require_populate = __commonJS({
  "node_modules/form-data/lib/populate.js"(exports, module2) {
    module2.exports = function(dst, src) {
      return Object.keys(src).forEach(function(prop) {
        dst[prop] = dst[prop] || src[prop];
      }), dst;
    };
  }
});

// node_modules/form-data/lib/form_data.js
var require_form_data2 = __commonJS({
  "node_modules/form-data/lib/form_data.js"(exports, module2) {
    var CombinedStream = require_combined_stream(), util2 = require("util"), path = require("path"), http2 = require("http"), https2 = require("https"), parseUrl = require("url").parse, fs = require("fs"), Stream = require("stream").Stream, mime = require_mime_types(), asynckit = require_asynckit(), populate = require_populate();
    module2.exports = FormData3;
    util2.inherits(FormData3, CombinedStream);
    function FormData3(options) {
      if (!(this instanceof FormData3))
        return new FormData3(options);
      this._overheadLength = 0, this._valueLength = 0, this._valuesToMeasure = [], CombinedStream.call(this), options = options || {};
      for (var option in options)
        this[option] = options[option];
    }
    FormData3.LINE_BREAK = `\r
`;
    FormData3.DEFAULT_CONTENT_TYPE = "application/octet-stream";
    FormData3.prototype.append = function(field, value, options) {
      options = options || {}, typeof options == "string" && (options = { filename: options });
      var append2 = CombinedStream.prototype.append.bind(this);
      if (typeof value == "number" && (value = "" + value), util2.isArray(value)) {
        this._error(new Error("Arrays are not supported."));
        return;
      }
      var header = this._multiPartHeader(field, value, options), footer = this._multiPartFooter();
      append2(header), append2(value), append2(footer), this._trackLength(header, value, options);
    };
    FormData3.prototype._trackLength = function(header, value, options) {
      var valueLength = 0;
      options.knownLength != null ? valueLength += +options.knownLength : Buffer.isBuffer(value) ? valueLength = value.length : typeof value == "string" && (valueLength = Buffer.byteLength(value)), this._valueLength += valueLength, this._overheadLength += Buffer.byteLength(header) + FormData3.LINE_BREAK.length, !(!value || !value.path && !(value.readable && value.hasOwnProperty("httpVersion")) && !(value instanceof Stream)) && (options.knownLength || this._valuesToMeasure.push(value));
    };
    FormData3.prototype._lengthRetriever = function(value, callback) {
      value.hasOwnProperty("fd") ? value.end != null && value.end != 1 / 0 && value.start != null ? callback(null, value.end + 1 - (value.start ? value.start : 0)) : fs.stat(value.path, function(err, stat) {
        var fileSize;
        if (err) {
          callback(err);
          return;
        }
        fileSize = stat.size - (value.start ? value.start : 0), callback(null, fileSize);
      }) : value.hasOwnProperty("httpVersion") ? callback(null, +value.headers["content-length"]) : value.hasOwnProperty("httpModule") ? (value.on("response", function(response) {
        value.pause(), callback(null, +response.headers["content-length"]);
      }), value.resume()) : callback("Unknown stream");
    };
    FormData3.prototype._multiPartHeader = function(field, value, options) {
      if (typeof options.header == "string")
        return options.header;
      var contentDisposition = this._getContentDisposition(value, options), contentType = this._getContentType(value, options), contents = "", headers = {
        // add custom disposition as third element or keep it two elements if not
        "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
        // if no content type. allow it to be empty array
        "Content-Type": [].concat(contentType || [])
      };
      typeof options.header == "object" && populate(headers, options.header);
      var header;
      for (var prop in headers)
        headers.hasOwnProperty(prop) && (header = headers[prop], header != null && (Array.isArray(header) || (header = [header]), header.length && (contents += prop + ": " + header.join("; ") + FormData3.LINE_BREAK)));
      return "--" + this.getBoundary() + FormData3.LINE_BREAK + contents + FormData3.LINE_BREAK;
    };
    FormData3.prototype._getContentDisposition = function(value, options) {
      var filename, contentDisposition;
      return typeof options.filepath == "string" ? filename = path.normalize(options.filepath).replace(/\\/g, "/") : options.filename || value.name || value.path ? filename = path.basename(options.filename || value.name || value.path) : value.readable && value.hasOwnProperty("httpVersion") && (filename = path.basename(value.client._httpMessage.path || "")), filename && (contentDisposition = 'filename="' + filename + '"'), contentDisposition;
    };
    FormData3.prototype._getContentType = function(value, options) {
      var contentType = options.contentType;
      return !contentType && value.name && (contentType = mime.lookup(value.name)), !contentType && value.path && (contentType = mime.lookup(value.path)), !contentType && value.readable && value.hasOwnProperty("httpVersion") && (contentType = value.headers["content-type"]), !contentType && (options.filepath || options.filename) && (contentType = mime.lookup(options.filepath || options.filename)), !contentType && typeof value == "object" && (contentType = FormData3.DEFAULT_CONTENT_TYPE), contentType;
    };
    FormData3.prototype._multiPartFooter = function() {
      return function(next) {
        var footer = FormData3.LINE_BREAK, lastPart = this._streams.length === 0;
        lastPart && (footer += this._lastBoundary()), next(footer);
      }.bind(this);
    };
    FormData3.prototype._lastBoundary = function() {
      return "--" + this.getBoundary() + "--" + FormData3.LINE_BREAK;
    };
    FormData3.prototype.getHeaders = function(userHeaders) {
      var header, formHeaders = {
        "content-type": "multipart/form-data; boundary=" + this.getBoundary()
      };
      for (header in userHeaders)
        userHeaders.hasOwnProperty(header) && (formHeaders[header.toLowerCase()] = userHeaders[header]);
      return formHeaders;
    };
    FormData3.prototype.setBoundary = function(boundary) {
      this._boundary = boundary;
    };
    FormData3.prototype.getBoundary = function() {
      return this._boundary || this._generateBoundary(), this._boundary;
    };
    FormData3.prototype.getBuffer = function() {
      for (var dataBuffer = new Buffer.alloc(0), boundary = this.getBoundary(), i = 0, len = this._streams.length; i < len; i++)
        typeof this._streams[i] != "function" && (Buffer.isBuffer(this._streams[i]) ? dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]) : dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]), (typeof this._streams[i] != "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) && (dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData3.LINE_BREAK)])));
      return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
    };
    FormData3.prototype._generateBoundary = function() {
      for (var boundary = "--------------------------", i = 0; i < 24; i++)
        boundary += Math.floor(Math.random() * 10).toString(16);
      this._boundary = boundary;
    };
    FormData3.prototype.getLengthSync = function() {
      var knownLength = this._overheadLength + this._valueLength;
      return this._streams.length && (knownLength += this._lastBoundary().length), this.hasKnownLength() || this._error(new Error("Cannot calculate proper length in synchronous way.")), knownLength;
    };
    FormData3.prototype.hasKnownLength = function() {
      var hasKnownLength = !0;
      return this._valuesToMeasure.length && (hasKnownLength = !1), hasKnownLength;
    };
    FormData3.prototype.getLength = function(cb) {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length && (knownLength += this._lastBoundary().length), !this._valuesToMeasure.length) {
        process.nextTick(cb.bind(this, null, knownLength));
        return;
      }
      asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
        if (err) {
          cb(err);
          return;
        }
        values.forEach(function(length) {
          knownLength += length;
        }), cb(null, knownLength);
      });
    };
    FormData3.prototype.submit = function(params, cb) {
      var request, options, defaults2 = { method: "post" };
      return typeof params == "string" ? (params = parseUrl(params), options = populate({
        port: params.port,
        path: params.pathname,
        host: params.hostname,
        protocol: params.protocol
      }, defaults2)) : (options = populate(params, defaults2), options.port || (options.port = options.protocol == "https:" ? 443 : 80)), options.headers = this.getHeaders(params.headers), options.protocol == "https:" ? request = https2.request(options) : request = http2.request(options), this.getLength(function(err, length) {
        if (err && err !== "Unknown stream") {
          this._error(err);
          return;
        }
        if (length && request.setHeader("Content-Length", length), this.pipe(request), cb) {
          var onResponse, callback = function(error, responce) {
            return request.removeListener("error", callback), request.removeListener("response", onResponse), cb.call(this, error, responce);
          };
          onResponse = callback.bind(this, null), request.on("error", callback), request.on("response", onResponse);
        }
      }.bind(this)), request;
    };
    FormData3.prototype._error = function(err) {
      this.error || (this.error = err, this.pause(), this.emit("error", err));
    };
    FormData3.prototype.toString = function() {
      return "[object FormData]";
    };
  }
});

// node_modules/proxy-from-env/index.js
var require_proxy_from_env = __commonJS({
  "node_modules/proxy-from-env/index.js"(exports) {
    "use strict";
    var parseUrl = require("url").parse, DEFAULT_PORTS = {
      ftp: 21,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    }, stringEndsWith = String.prototype.endsWith || function(s) {
      return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
    };
    function getProxyForUrl2(url2) {
      var parsedUrl = typeof url2 == "string" ? parseUrl(url2) : url2 || {}, proto = parsedUrl.protocol, hostname = parsedUrl.host, port = parsedUrl.port;
      if (typeof hostname != "string" || !hostname || typeof proto != "string" || (proto = proto.split(":", 1)[0], hostname = hostname.replace(/:\d*$/, ""), port = parseInt(port) || DEFAULT_PORTS[proto] || 0, !shouldProxy(hostname, port)))
        return "";
      var proxy = getEnv("npm_config_" + proto + "_proxy") || getEnv(proto + "_proxy") || getEnv("npm_config_proxy") || getEnv("all_proxy");
      return proxy && proxy.indexOf("://") === -1 && (proxy = proto + "://" + proxy), proxy;
    }
    function shouldProxy(hostname, port) {
      var NO_PROXY = (getEnv("npm_config_no_proxy") || getEnv("no_proxy")).toLowerCase();
      return NO_PROXY ? NO_PROXY === "*" ? !1 : NO_PROXY.split(/[,\s]/).every(function(proxy) {
        if (!proxy)
          return !0;
        var parsedProxy = proxy.match(/^(.+):(\d+)$/), parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy, parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
        return parsedProxyPort && parsedProxyPort !== port ? !0 : /^[.*]/.test(parsedProxyHostname) ? (parsedProxyHostname.charAt(0) === "*" && (parsedProxyHostname = parsedProxyHostname.slice(1)), !stringEndsWith.call(hostname, parsedProxyHostname)) : hostname !== parsedProxyHostname;
      }) : !0;
    }
    function getEnv(key) {
      return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || "";
    }
    exports.getProxyForUrl = getProxyForUrl2;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module2) {
    var s = 1e3, m = s * 60, h = m * 60, d = h * 24, w = d * 7, y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0)
        return parse(val);
      if (type === "number" && isFinite(val))
        return options.long ? fmtLong(val) : fmtShort(val);
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      if (str = String(str), !(str.length > 100)) {
        var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
          str
        );
        if (match) {
          var n = parseFloat(match[1]), type = (match[2] || "ms").toLowerCase();
          switch (type) {
            case "years":
            case "year":
            case "yrs":
            case "yr":
            case "y":
              return n * y;
            case "weeks":
            case "week":
            case "w":
              return n * w;
            case "days":
            case "day":
            case "d":
              return n * d;
            case "hours":
            case "hour":
            case "hrs":
            case "hr":
            case "h":
              return n * h;
            case "minutes":
            case "minute":
            case "mins":
            case "min":
            case "m":
              return n * m;
            case "seconds":
            case "second":
            case "secs":
            case "sec":
            case "s":
              return n * s;
            case "milliseconds":
            case "millisecond":
            case "msecs":
            case "msec":
            case "ms":
              return n;
            default:
              return;
          }
        }
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      return msAbs >= d ? Math.round(ms / d) + "d" : msAbs >= h ? Math.round(ms / h) + "h" : msAbs >= m ? Math.round(ms / m) + "m" : msAbs >= s ? Math.round(ms / s) + "s" : ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      return msAbs >= d ? plural(ms, msAbs, d, "day") : msAbs >= h ? plural(ms, msAbs, h, "hour") : msAbs >= m ? plural(ms, msAbs, m, "minute") : msAbs >= s ? plural(ms, msAbs, s, "second") : ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module2) {
    function setup(env) {
      createDebug.debug = createDebug, createDebug.default = createDebug, createDebug.coerce = coerce, createDebug.disable = disable, createDebug.enable = enable, createDebug.enabled = enabled, createDebug.humanize = require_ms(), createDebug.destroy = destroy, Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      }), createDebug.names = [], createDebug.skips = [], createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++)
          hash = (hash << 5) - hash + namespace.charCodeAt(i), hash |= 0;
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime, enableOverride = null, namespacesCache, enabledCache;
        function debug(...args) {
          if (!debug.enabled)
            return;
          let self2 = debug, curr = Number(/* @__PURE__ */ new Date()), ms = curr - (prevTime || curr);
          self2.diff = ms, self2.prev = prevTime, self2.curr = curr, prevTime = curr, args[0] = createDebug.coerce(args[0]), typeof args[0] != "string" && args.unshift("%O");
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%")
              return "%";
            index++;
            let formatter = createDebug.formatters[format];
            if (typeof formatter == "function") {
              let val = args[index];
              match = formatter.call(self2, val), args.splice(index, 1), index--;
            }
            return match;
          }), createDebug.formatArgs.call(self2, args), (self2.log || createDebug.log).apply(self2, args);
        }
        return debug.namespace = namespace, debug.useColors = createDebug.useColors(), debug.color = createDebug.selectColor(namespace), debug.extend = extend2, debug.destroy = createDebug.destroy, Object.defineProperty(debug, "enabled", {
          enumerable: !0,
          configurable: !1,
          get: () => enableOverride !== null ? enableOverride : (namespacesCache !== createDebug.namespaces && (namespacesCache = createDebug.namespaces, enabledCache = createDebug.enabled(namespace)), enabledCache),
          set: (v) => {
            enableOverride = v;
          }
        }), typeof createDebug.init == "function" && createDebug.init(debug), debug;
      }
      function extend2(namespace, delimiter) {
        let newDebug = createDebug(this.namespace + (typeof delimiter > "u" ? ":" : delimiter) + namespace);
        return newDebug.log = this.log, newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces), createDebug.namespaces = namespaces, createDebug.names = [], createDebug.skips = [];
        let i, split = (typeof namespaces == "string" ? namespaces : "").split(/[\s,]+/), len = split.length;
        for (i = 0; i < len; i++)
          split[i] && (namespaces = split[i].replace(/\*/g, ".*?"), namespaces[0] === "-" ? createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$")) : createDebug.names.push(new RegExp("^" + namespaces + "$")));
      }
      function disable() {
        let namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        return createDebug.enable(""), namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*")
          return !0;
        let i, len;
        for (i = 0, len = createDebug.skips.length; i < len; i++)
          if (createDebug.skips[i].test(name))
            return !1;
        for (i = 0, len = createDebug.names.length; i < len; i++)
          if (createDebug.names[i].test(name))
            return !0;
        return !1;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        return val instanceof Error ? val.stack || val.message : val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      return createDebug.enable(createDebug.load()), createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser2 = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module2) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = !1;
      return () => {
        warned || (warned = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      if (args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff), !this.useColors)
        return;
      let c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0, lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        match !== "%%" && (index++, match === "%c" && (lastC = index));
      }), args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        namespaces ? exports.storage.setItem("debug", namespaces) : exports.storage.removeItem("debug");
      } catch {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch {
      }
      return !r && typeof process < "u" && "env" in process && (r = process.env.DEBUG), r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch {
      }
    }
    module2.exports = require_common()(exports);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/has-flag/index.js"(exports, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      let prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--", position = argv.indexOf(prefix + flag), terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports, module2) {
    "use strict";
    var os = require("os"), tty = require("tty"), hasFlag = require_has_flag(), { env } = process, forceColor;
    hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never") ? forceColor = 0 : (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) && (forceColor = 1);
    "FORCE_COLOR" in env && (env.FORCE_COLOR === "true" ? forceColor = 1 : env.FORCE_COLOR === "false" ? forceColor = 0 : forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3));
    function translateLevel(level) {
      return level === 0 ? !1 : {
        level,
        hasBasic: !0,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0)
        return 0;
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor"))
        return 3;
      if (hasFlag("color=256"))
        return 2;
      if (haveStream && !streamIsTTY && forceColor === void 0)
        return 0;
      let min = forceColor || 0;
      if (env.TERM === "dumb")
        return min;
      if (process.platform === "win32") {
        let osRelease = os.release().split(".");
        return Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586 ? Number(osRelease[2]) >= 14931 ? 3 : 2 : 1;
      }
      if ("CI" in env)
        return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship" ? 1 : min;
      if ("TEAMCITY_VERSION" in env)
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      if (env.COLORTERM === "truecolor")
        return 3;
      if ("TERM_PROGRAM" in env) {
        let version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      return /-256(color)?$/i.test(env.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM) || "COLORTERM" in env ? 1 : min;
    }
    function getSupportLevel(stream4) {
      let level = supportsColor(stream4, stream4 && stream4.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(!0, tty.isatty(1))),
      stderr: translateLevel(supportsColor(!0, tty.isatty(2)))
    };
  }
});

// node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/debug/src/node.js"(exports, module2) {
    var tty = require("tty"), util2 = require("util");
    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util2.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      let supportsColor = require_supports_color();
      supportsColor && (supportsColor.stderr || supportsColor).level >= 2 && (exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ]);
    } catch {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => /^debug_/i.test(key)).reduce((obj, key) => {
      let prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => k.toUpperCase()), val = process.env[key];
      return /^(yes|on|true|enabled)$/i.test(val) ? val = !0 : /^(no|off|false|disabled)$/i.test(val) ? val = !1 : val === "null" ? val = null : val = Number(val), obj[prop] = val, obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      let { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        let c = this.color, colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c), prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split(`
`).join(`
` + prefix), args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else
        args[0] = getDate() + name + " " + args[0];
    }
    function getDate() {
      return exports.inspectOpts.hideDate ? "" : (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util2.format(...args) + `
`);
    }
    function save(namespaces) {
      namespaces ? process.env.DEBUG = namespaces : delete process.env.DEBUG;
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      let keys = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys.length; i++)
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
    module2.exports = require_common()(exports);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      return this.inspectOpts.colors = this.useColors, util2.inspect(v, this.inspectOpts).split(`
`).map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      return this.inspectOpts.colors = this.useColors, util2.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src3 = __commonJS({
  "node_modules/debug/src/index.js"(exports, module2) {
    typeof process > "u" || process.type === "renderer" || process.browser === !0 || process.__nwjs ? module2.exports = require_browser2() : module2.exports = require_node();
  }
});

// node_modules/follow-redirects/debug.js
var require_debug = __commonJS({
  "node_modules/follow-redirects/debug.js"(exports, module2) {
    var debug;
    module2.exports = function() {
      if (!debug) {
        try {
          debug = require_src3()("follow-redirects");
        } catch {
        }
        typeof debug != "function" && (debug = function() {
        });
      }
      debug.apply(null, arguments);
    };
  }
});

// node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS({
  "node_modules/follow-redirects/index.js"(exports, module2) {
    var url2 = require("url"), URL2 = url2.URL, http2 = require("http"), https2 = require("https"), Writable = require("stream").Writable, assert = require("assert"), debug = require_debug(), events = ["abort", "aborted", "connect", "error", "socket", "timeout"], eventHandlers = /* @__PURE__ */ Object.create(null);
    events.forEach(function(event) {
      eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      };
    });
    var InvalidUrlError = createErrorType(
      "ERR_INVALID_URL",
      "Invalid URL",
      TypeError
    ), RedirectionError = createErrorType(
      "ERR_FR_REDIRECTION_FAILURE",
      "Redirected request failed"
    ), TooManyRedirectsError = createErrorType(
      "ERR_FR_TOO_MANY_REDIRECTS",
      "Maximum number of redirects exceeded"
    ), MaxBodyLengthExceededError = createErrorType(
      "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
      "Request body larger than maxBodyLength limit"
    ), WriteAfterEndError = createErrorType(
      "ERR_STREAM_WRITE_AFTER_END",
      "write after end"
    );
    function RedirectableRequest(options, responseCallback) {
      Writable.call(this), this._sanitizeOptions(options), this._options = options, this._ended = !1, this._ending = !1, this._redirectCount = 0, this._redirects = [], this._requestBodyLength = 0, this._requestBodyBuffers = [], responseCallback && this.on("response", responseCallback);
      var self2 = this;
      this._onNativeResponse = function(response) {
        self2._processResponse(response);
      }, this._performRequest();
    }
    RedirectableRequest.prototype = Object.create(Writable.prototype);
    RedirectableRequest.prototype.abort = function() {
      abortRequest(this._currentRequest), this.emit("abort");
    };
    RedirectableRequest.prototype.write = function(data, encoding, callback) {
      if (this._ending)
        throw new WriteAfterEndError();
      if (!isString2(data) && !isBuffer2(data))
        throw new TypeError("data should be a string, Buffer or Uint8Array");
      if (isFunction2(encoding) && (callback = encoding, encoding = null), data.length === 0) {
        callback && callback();
        return;
      }
      this._requestBodyLength + data.length <= this._options.maxBodyLength ? (this._requestBodyLength += data.length, this._requestBodyBuffers.push({ data, encoding }), this._currentRequest.write(data, encoding, callback)) : (this.emit("error", new MaxBodyLengthExceededError()), this.abort());
    };
    RedirectableRequest.prototype.end = function(data, encoding, callback) {
      if (isFunction2(data) ? (callback = data, data = encoding = null) : isFunction2(encoding) && (callback = encoding, encoding = null), !data)
        this._ended = this._ending = !0, this._currentRequest.end(null, null, callback);
      else {
        var self2 = this, currentRequest = this._currentRequest;
        this.write(data, encoding, function() {
          self2._ended = !0, currentRequest.end(null, null, callback);
        }), this._ending = !0;
      }
    };
    RedirectableRequest.prototype.setHeader = function(name, value) {
      this._options.headers[name] = value, this._currentRequest.setHeader(name, value);
    };
    RedirectableRequest.prototype.removeHeader = function(name) {
      delete this._options.headers[name], this._currentRequest.removeHeader(name);
    };
    RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
      var self2 = this;
      function destroyOnTimeout(socket) {
        socket.setTimeout(msecs), socket.removeListener("timeout", socket.destroy), socket.addListener("timeout", socket.destroy);
      }
      function startTimer(socket) {
        self2._timeout && clearTimeout(self2._timeout), self2._timeout = setTimeout(function() {
          self2.emit("timeout"), clearTimer();
        }, msecs), destroyOnTimeout(socket);
      }
      function clearTimer() {
        self2._timeout && (clearTimeout(self2._timeout), self2._timeout = null), self2.removeListener("abort", clearTimer), self2.removeListener("error", clearTimer), self2.removeListener("response", clearTimer), callback && self2.removeListener("timeout", callback), self2.socket || self2._currentRequest.removeListener("socket", startTimer);
      }
      return callback && this.on("timeout", callback), this.socket ? startTimer(this.socket) : this._currentRequest.once("socket", startTimer), this.on("socket", destroyOnTimeout), this.on("abort", clearTimer), this.on("error", clearTimer), this.on("response", clearTimer), this;
    };
    [
      "flushHeaders",
      "getHeader",
      "setNoDelay",
      "setSocketKeepAlive"
    ].forEach(function(method) {
      RedirectableRequest.prototype[method] = function(a, b) {
        return this._currentRequest[method](a, b);
      };
    });
    ["aborted", "connection", "socket"].forEach(function(property) {
      Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function() {
          return this._currentRequest[property];
        }
      });
    });
    RedirectableRequest.prototype._sanitizeOptions = function(options) {
      if (options.headers || (options.headers = {}), options.host && (options.hostname || (options.hostname = options.host), delete options.host), !options.pathname && options.path) {
        var searchPos = options.path.indexOf("?");
        searchPos < 0 ? options.pathname = options.path : (options.pathname = options.path.substring(0, searchPos), options.search = options.path.substring(searchPos));
      }
    };
    RedirectableRequest.prototype._performRequest = function() {
      var protocol = this._options.protocol, nativeProtocol = this._options.nativeProtocols[protocol];
      if (!nativeProtocol) {
        this.emit("error", new TypeError("Unsupported protocol " + protocol));
        return;
      }
      if (this._options.agents) {
        var scheme = protocol.slice(0, -1);
        this._options.agent = this._options.agents[scheme];
      }
      var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
      request._redirectable = this;
      for (var event of events)
        request.on(event, eventHandlers[event]);
      if (this._currentUrl = /^\//.test(this._options.path) ? url2.format(this._options) : (
        // When making a request to a proxy, []
        // a client MUST send the target URI in absolute-form [].
        this._options.path
      ), this._isRedirect) {
        var i = 0, self2 = this, buffers = this._requestBodyBuffers;
        (function writeNext(error) {
          if (request === self2._currentRequest)
            if (error)
              self2.emit("error", error);
            else if (i < buffers.length) {
              var buffer = buffers[i++];
              request.finished || request.write(buffer.data, buffer.encoding, writeNext);
            } else
              self2._ended && request.end();
        })();
      }
    };
    RedirectableRequest.prototype._processResponse = function(response) {
      var statusCode = response.statusCode;
      this._options.trackRedirects && this._redirects.push({
        url: this._currentUrl,
        headers: response.headers,
        statusCode
      });
      var location = response.headers.location;
      if (!location || this._options.followRedirects === !1 || statusCode < 300 || statusCode >= 400) {
        response.responseUrl = this._currentUrl, response.redirects = this._redirects, this.emit("response", response), this._requestBodyBuffers = [];
        return;
      }
      if (abortRequest(this._currentRequest), response.destroy(), ++this._redirectCount > this._options.maxRedirects) {
        this.emit("error", new TooManyRedirectsError());
        return;
      }
      var requestHeaders, beforeRedirect = this._options.beforeRedirect;
      beforeRedirect && (requestHeaders = Object.assign({
        // The Host header was set by nativeProtocol.request
        Host: response.req.getHeader("host")
      }, this._options.headers));
      var method = this._options.method;
      ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC72316.4.4: The 303 (See Other) status code indicates that
      // the server is redirecting the user agent to a different resource []
      // A user agent can perform a retrieval request targeting that URI
      // (a GET or HEAD request if using HTTP) []
      statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) && (this._options.method = "GET", this._requestBodyBuffers = [], removeMatchingHeaders(/^content-/i, this._options.headers));
      var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers), currentUrlParts = url2.parse(this._currentUrl), currentHost = currentHostHeader || currentUrlParts.host, currentUrl = /^\w+:/.test(location) ? this._currentUrl : url2.format(Object.assign(currentUrlParts, { host: currentHost })), redirectUrl;
      try {
        redirectUrl = url2.resolve(currentUrl, location);
      } catch (cause) {
        this.emit("error", new RedirectionError({ cause }));
        return;
      }
      debug("redirecting to", redirectUrl), this._isRedirect = !0;
      var redirectUrlParts = url2.parse(redirectUrl);
      if (Object.assign(this._options, redirectUrlParts), (redirectUrlParts.protocol !== currentUrlParts.protocol && redirectUrlParts.protocol !== "https:" || redirectUrlParts.host !== currentHost && !isSubdomain(redirectUrlParts.host, currentHost)) && removeMatchingHeaders(/^(?:authorization|cookie)$/i, this._options.headers), isFunction2(beforeRedirect)) {
        var responseDetails = {
          headers: response.headers,
          statusCode
        }, requestDetails = {
          url: currentUrl,
          method,
          headers: requestHeaders
        };
        try {
          beforeRedirect(this._options, responseDetails, requestDetails);
        } catch (err) {
          this.emit("error", err);
          return;
        }
        this._sanitizeOptions(this._options);
      }
      try {
        this._performRequest();
      } catch (cause) {
        this.emit("error", new RedirectionError({ cause }));
      }
    };
    function wrap(protocols) {
      var exports2 = {
        maxRedirects: 21,
        maxBodyLength: 10485760
      }, nativeProtocols = {};
      return Object.keys(protocols).forEach(function(scheme) {
        var protocol = scheme + ":", nativeProtocol = nativeProtocols[protocol] = protocols[scheme], wrappedProtocol = exports2[scheme] = Object.create(nativeProtocol);
        function request(input, options, callback) {
          if (isString2(input)) {
            var parsed;
            try {
              parsed = urlToOptions(new URL2(input));
            } catch {
              parsed = url2.parse(input);
            }
            if (!isString2(parsed.protocol))
              throw new InvalidUrlError({ input });
            input = parsed;
          } else
            URL2 && input instanceof URL2 ? input = urlToOptions(input) : (callback = options, options = input, input = { protocol });
          return isFunction2(options) && (callback = options, options = null), options = Object.assign({
            maxRedirects: exports2.maxRedirects,
            maxBodyLength: exports2.maxBodyLength
          }, input, options), options.nativeProtocols = nativeProtocols, !isString2(options.host) && !isString2(options.hostname) && (options.hostname = "::1"), assert.equal(options.protocol, protocol, "protocol mismatch"), debug("options", options), new RedirectableRequest(options, callback);
        }
        function get(input, options, callback) {
          var wrappedRequest = wrappedProtocol.request(input, options, callback);
          return wrappedRequest.end(), wrappedRequest;
        }
        Object.defineProperties(wrappedProtocol, {
          request: { value: request, configurable: !0, enumerable: !0, writable: !0 },
          get: { value: get, configurable: !0, enumerable: !0, writable: !0 }
        });
      }), exports2;
    }
    function noop2() {
    }
    function urlToOptions(urlObject) {
      var options = {
        protocol: urlObject.protocol,
        hostname: urlObject.hostname.startsWith("[") ? (
          /* istanbul ignore next */
          urlObject.hostname.slice(1, -1)
        ) : urlObject.hostname,
        hash: urlObject.hash,
        search: urlObject.search,
        pathname: urlObject.pathname,
        path: urlObject.pathname + urlObject.search,
        href: urlObject.href
      };
      return urlObject.port !== "" && (options.port = Number(urlObject.port)), options;
    }
    function removeMatchingHeaders(regex, headers) {
      var lastValue;
      for (var header in headers)
        regex.test(header) && (lastValue = headers[header], delete headers[header]);
      return lastValue === null || typeof lastValue > "u" ? void 0 : String(lastValue).trim();
    }
    function createErrorType(code, message, baseClass) {
      function CustomError(properties) {
        Error.captureStackTrace(this, this.constructor), Object.assign(this, properties || {}), this.code = code, this.message = this.cause ? message + ": " + this.cause.message : message;
      }
      return CustomError.prototype = new (baseClass || Error)(), CustomError.prototype.constructor = CustomError, CustomError.prototype.name = "Error [" + code + "]", CustomError;
    }
    function abortRequest(request) {
      for (var event of events)
        request.removeListener(event, eventHandlers[event]);
      request.on("error", noop2), request.abort();
    }
    function isSubdomain(subdomain, domain) {
      assert(isString2(subdomain) && isString2(domain));
      var dot = subdomain.length - domain.length - 1;
      return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
    }
    function isString2(value) {
      return typeof value == "string" || value instanceof String;
    }
    function isFunction2(value) {
      return typeof value == "function";
    }
    function isBuffer2(value) {
      return typeof value == "object" && "length" in value;
    }
    module2.exports = wrap({ http: http2, https: https2 });
    module2.exports.wrap = wrap;
  }
});

// <stdin>
var stdin_exports = {};
__export(stdin_exports, {
  assets: () => assets_manifest_default,
  assetsBuildDirectory: () => assetsBuildDirectory,
  entry: () => entry,
  future: () => future,
  publicPath: () => publicPath,
  routes: () => routes
});
module.exports = __toCommonJS(stdin_exports);

// node_modules/@remix-run/dev/dist/config/defaults/node/entry.server.react-stream.tsx
var entry_server_react_stream_exports = {};
__export(entry_server_react_stream_exports, {
  default: () => handleRequest
});
var import_stream = require("stream"), import_node = __toESM(require_dist2()), import_react = __toESM(require_dist3());

// node_modules/isbot/index.mjs
function _classPrivateFieldGet(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");
  return _classApplyDescriptorGet(receiver, descriptor);
}
function _classPrivateFieldSet(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");
  return _classApplyDescriptorSet(receiver, descriptor, value), value;
}
function _classExtractFieldDescriptor(receiver, privateMap, action) {
  if (!privateMap.has(receiver))
    throw new TypeError("attempted to " + action + " private field on non-instance");
  return privateMap.get(receiver);
}
function _classApplyDescriptorGet(receiver, descriptor) {
  return descriptor.get ? descriptor.get.call(receiver) : descriptor.value;
}
function _classApplyDescriptorSet(receiver, descriptor, value) {
  if (descriptor.set)
    descriptor.set.call(receiver, value);
  else {
    if (!descriptor.writable)
      throw new TypeError("attempted to set read only private field");
    descriptor.value = value;
  }
}
function _classPrivateMethodGet(receiver, privateSet, fn) {
  if (!privateSet.has(receiver))
    throw new TypeError("attempted to get private field on non-instance");
  return fn;
}
function _checkPrivateRedeclaration(obj, privateCollection) {
  if (privateCollection.has(obj))
    throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function _classPrivateFieldInitSpec(obj, privateMap, value) {
  _checkPrivateRedeclaration(obj, privateMap), privateMap.set(obj, value);
}
function _classPrivateMethodInitSpec(obj, privateSet) {
  _checkPrivateRedeclaration(obj, privateSet), privateSet.add(obj);
}
var list = [
  " daum[ /]",
  " deusu/",
  "(?:^| )site",
  "@[a-z]",
  "\\(at\\)[a-z]",
  "\\(github\\.com/",
  "\\[at\\][a-z]",
  "^12345",
  "^<",
  "^[\\w \\.\\-\\(\\)]+(/v?\\d+(\\.\\d+)?(\\.\\d{1,10})?)?$",
  "^[^ ]{50,}$",
  "^active",
  "^ad muncher",
  "^anglesharp/",
  "^anonymous",
  "^avsdevicesdk/",
  "^axios/",
  "^bidtellect/",
  "^biglotron",
  "^btwebclient/",
  "^castro",
  "^clamav[ /]",
  "^client/",
  "^cobweb/",
  "^coccoc",
  "^custom",
  "^ddg[_-]android",
  "^discourse",
  "^dispatch/\\d",
  "^downcast/",
  "^duckduckgo",
  "^facebook",
  "^fdm[ /]\\d",
  "^getright/",
  "^gozilla/",
  "^hatena",
  "^hobbit",
  "^hotzonu",
  "^hwcdn/",
  "^jeode/",
  "^jetty/",
  "^jigsaw",
  "^linkdex",
  "^lwp[-: ]",
  "^metauri",
  "^microsoft bits",
  "^movabletype",
  "^mozilla/\\d\\.\\d \\(compatible;?\\)$",
  "^mozilla/\\d\\.\\d \\w*$",
  "^navermailapp",
  "^netsurf",
  "^offline explorer",
  "^php",
  "^postman",
  "^postrank",
  "^python",
  "^read",
  "^reed",
  "^restsharp/",
  "^snapchat",
  "^space bison",
  "^svn",
  "^swcd ",
  "^taringa",
  "^test certificate info",
  "^thumbor/",
  "^tumblr/",
  "^user-agent:mozilla",
  "^valid",
  "^venus/fedoraplanet",
  "^w3c",
  "^webbandit/",
  "^webcopier",
  "^wget",
  "^whatsapp",
  "^xenu link sleuth",
  "^yahoo",
  "^yandex",
  "^zdm/\\d",
  "^zoom marketplace/",
  "^{{.*}}$",
  "adbeat\\.com",
  "appinsights",
  "archive",
  "ask jeeves/teoma",
  "bit\\.ly/",
  "bluecoat drtr",
  "bot",
  "browsex",
  "burpcollaborator",
  "capture",
  "catch",
  "check",
  "chrome-lighthouse",
  "chromeframe",
  "cloud",
  "crawl",
  "cryptoapi",
  "dareboost",
  "datanyze",
  "dataprovider",
  "dejaclick",
  "dmbrowser",
  "download",
  "evc-batch/",
  "feed",
  "firephp",
  "freesafeip",
  "ghost",
  "gomezagent",
  "google",
  "headlesschrome/",
  "http",
  "httrack",
  "hubspot marketing grader",
  "hydra",
  "ibisbrowser",
  "images",
  "iplabel",
  "ips-agent",
  "java",
  "library",
  "mail\\.ru/",
  "manager",
  "monitor",
  "morningscore/",
  "neustar wpm",
  "news",
  "nutch",
  "offbyone",
  "optimize",
  "pageburst",
  "pagespeed",
  "perl",
  "phantom",
  "pingdom",
  "powermarks",
  "preview",
  "proxy",
  "ptst[ /]\\d",
  "reader",
  "rexx;",
  "rigor",
  "rss",
  "scan",
  "scrape",
  "search",
  "serp ?reputation ?management",
  "server",
  "sogou",
  "sparkler/",
  "speedcurve",
  "spider",
  "statuscake",
  "stumbleupon\\.com",
  "supercleaner",
  "synapse",
  "synthetic",
  "taginspector/",
  "torrent",
  "tracemyfile",
  "transcoder",
  "trendsmapresolver",
  "twingly recon",
  "url",
  "virtuoso",
  "wappalyzer",
  "webglance",
  "webkit2png",
  "websitemetadataretriever",
  "whatcms/",
  "wordpress",
  "zgrab"
];
function amend(list2) {
  try {
    new RegExp("(?<! cu)bot").test("dangerbot");
  } catch {
    return list2;
  }
  return [
    // Addresses: Cubot device
    ["bot", "(?<! cu)bot"],
    // Addresses: Android webview
    ["google", "(?<! (?:channel/|google/))google(?!(app|/google| pixel))"],
    // Addresses: libhttp browser
    ["http", "(?<!(?:lib))http"],
    // Addresses: java based browsers
    ["java", "java(?!;)"],
    // Addresses: Yandex Search App
    ["search", "(?<! ya(?:yandex)?)search"]
  ].forEach((_ref) => {
    let [search, replace] = _ref, index = list2.lastIndexOf(search);
    ~index && list2.splice(index, 1, replace);
  }), list2;
}
amend(list);
var flags = "i", _list = /* @__PURE__ */ new WeakMap(), _pattern = /* @__PURE__ */ new WeakMap(), _update = /* @__PURE__ */ new WeakSet(), _index = /* @__PURE__ */ new WeakSet(), Isbot = class {
  constructor(patterns) {
    return _classPrivateMethodInitSpec(this, _index), _classPrivateMethodInitSpec(this, _update), _classPrivateFieldInitSpec(this, _list, {
      writable: !0,
      value: void 0
    }), _classPrivateFieldInitSpec(this, _pattern, {
      writable: !0,
      value: void 0
    }), _classPrivateFieldSet(this, _list, patterns || list.slice()), _classPrivateMethodGet(this, _update, _update2).call(this), Object.defineProperties((ua) => this.test(ua), Object.entries(Object.getOwnPropertyDescriptors(Isbot.prototype)).reduce((accumulator, _ref) => {
      let [prop, descriptor] = _ref;
      return typeof descriptor.value == "function" && Object.assign(accumulator, {
        [prop]: {
          value: this[prop].bind(this)
        }
      }), typeof descriptor.get == "function" && Object.assign(accumulator, {
        [prop]: {
          get: () => this[prop]
        }
      }), accumulator;
    }, {}));
  }
  /**
   * Get a clone of the pattern
   * @type RegExp
   */
  get pattern() {
    return new RegExp(_classPrivateFieldGet(this, _pattern));
  }
  /**
   * Match given string against out pattern
   * @param  {string} ua User Agent string
   * @returns {boolean}
   */
  test(ua) {
    return Boolean(ua) && _classPrivateFieldGet(this, _pattern).test(ua);
  }
  /**
   * Get the match for strings' known crawler pattern
   * @param  {string} ua User Agent string
   * @returns {string|null}
   */
  find() {
    let match = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "").match(_classPrivateFieldGet(this, _pattern));
    return match && match[0];
  }
  /**
   * Get the patterns that match user agent string if any
   * @param  {string} ua User Agent string
   * @returns {string[]}
   */
  matches() {
    let ua = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    return _classPrivateFieldGet(this, _list).filter((entry2) => new RegExp(entry2, flags).test(ua));
  }
  /**
   * Clear all patterns that match user agent
   * @param  {string} ua User Agent string
   * @returns {void}
   */
  clear() {
    let ua = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    this.exclude(this.matches(ua));
  }
  /**
   * Extent patterns for known crawlers
   * @param  {string[]} filters
   * @returns {void}
   */
  extend() {
    let filters = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    [].push.apply(_classPrivateFieldGet(this, _list), filters.filter((rule) => _classPrivateMethodGet(this, _index, _index2).call(this, rule) === -1).map((filter2) => filter2.toLowerCase())), _classPrivateMethodGet(this, _update, _update2).call(this);
  }
  /**
   * Exclude patterns from bot pattern rule
   * @param  {string[]} filters
   * @returns {void}
   */
  exclude() {
    let filters = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], {
      length
    } = filters;
    for (; length--; ) {
      let index = _classPrivateMethodGet(this, _index, _index2).call(this, filters[length]);
      index > -1 && _classPrivateFieldGet(this, _list).splice(index, 1);
    }
    _classPrivateMethodGet(this, _update, _update2).call(this);
  }
  /**
   * Create a new Isbot instance using given list or self's list
   * @param  {string[]} [list]
   * @returns {Isbot}
   */
  spawn(list2) {
    return new Isbot(list2 || _classPrivateFieldGet(this, _list));
  }
};
function _update2() {
  _classPrivateFieldSet(this, _pattern, new RegExp(_classPrivateFieldGet(this, _list).join("|"), flags));
}
function _index2(rule) {
  return _classPrivateFieldGet(this, _list).indexOf(rule.toLowerCase());
}
var isbot = new Isbot();

// node_modules/@remix-run/dev/dist/config/defaults/node/entry.server.react-stream.tsx
var import_server = __toESM(require_server_node()), import_jsx_runtime = __toESM(require_jsx_runtime()), ABORT_DELAY = 5e3;
function handleRequest(request, responseStatusCode, responseHeaders, remixContext) {
  return isbot(request.headers.get("user-agent")) ? handleBotRequest(
    request,
    responseStatusCode,
    responseHeaders,
    remixContext
  ) : handleBrowserRequest(
    request,
    responseStatusCode,
    responseHeaders,
    remixContext
  );
}
function handleBotRequest(request, responseStatusCode, responseHeaders, remixContext) {
  return new Promise((resolve, reject) => {
    let { pipe, abort } = (0, import_server.renderToPipeableStream)(
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        import_react.RemixServer,
        {
          context: remixContext,
          url: request.url,
          abortDelay: ABORT_DELAY
        }
      ),
      {
        onAllReady() {
          let body = new import_stream.PassThrough();
          responseHeaders.set("Content-Type", "text/html"), resolve(
            new import_node.Response(body, {
              headers: responseHeaders,
              status: responseStatusCode
            })
          ), pipe(body);
        },
        onShellError(error) {
          reject(error);
        },
        onError(error) {
          responseStatusCode = 500, console.error(error);
        }
      }
    );
    setTimeout(abort, ABORT_DELAY);
  });
}
function handleBrowserRequest(request, responseStatusCode, responseHeaders, remixContext) {
  return new Promise((resolve, reject) => {
    let { pipe, abort } = (0, import_server.renderToPipeableStream)(
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        import_react.RemixServer,
        {
          context: remixContext,
          url: request.url,
          abortDelay: ABORT_DELAY
        }
      ),
      {
        onShellReady() {
          let body = new import_stream.PassThrough();
          responseHeaders.set("Content-Type", "text/html"), resolve(
            new import_node.Response(body, {
              headers: responseHeaders,
              status: responseStatusCode
            })
          ), pipe(body);
        },
        onShellError(error) {
          reject(error);
        },
        onError(error) {
          console.error(error), responseStatusCode = 500;
        }
      }
    );
    setTimeout(abort, ABORT_DELAY);
  });
}

// app/root.jsx
var root_exports = {};
__export(root_exports, {
  CatchBoundary: () => CatchBoundary,
  default: () => Root,
  links: () => links
});
var import_react3 = __toESM(require_dist3());

// node_modules/bootstrap/dist/css/bootstrap.min.css
var bootstrap_min_default = "/build/_assets/bootstrap.min-IKESOC2M.css";

// app/components/common/GlobalLoading.jsx
var import_react2 = __toESM(require_dist3()), import_jsx_runtime2 = __toESM(require_jsx_runtime()), GlobalLoading = ({ children }) => {
  let { state } = (0, import_react2.useNavigation)();
  return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: state === "loading" ? /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "spinner h-100 d-flex align-items-center justify-content-center", children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { class: "spinner-border", role: "status", children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("span", { class: "visually-hidden", children: "Loading..." }) }) }) : children });
}, GlobalLoading_default = GlobalLoading;

// app/components/style/app.css
var app_default = "/build/_assets/app-6UFR6HBD.css";

// app/utils/constants/uiConstants.js
var MAIN_PAGE = Object.freeze({
  FREE_SHIPPING: "\xDCcretsiz kargo",
  PAID_SHIPPING: "Kargo \xFCcretli",
  FOLLOWERS: "takip",
  UPDATE: "Son G\xFCncelleme: "
}), ERROR_PAGE = Object.freeze({
  HEADER: "\xDCzg\xFCn\xFCz!",
  USER_MESSAGE: "\xDCzg\xFCn\xFCz, b\xF6yle bir sayfa bulunamad\u0131!"
}), uiConstants = {
  MAIN_PAGE,
  ERROR_PAGE
}, uiConstants_default = uiConstants;

// app/root.jsx
var import_jsx_runtime3 = __toESM(require_jsx_runtime()), links = () => [
  {
    rel: "stylesheet",
    href: app_default
  },
  {
    rel: "stylesheet",
    href: bootstrap_min_default
  }
];
function Root() {
  return /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("html", { lang: "en", children: [
    /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("head", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("title", { children: "Case Study" }),
      /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(import_react3.Links, {}),
      /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(import_react3.Meta, {})
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("body", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(GlobalLoading_default, { children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(import_react3.Outlet, {}) }),
      /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(import_react3.ScrollRestoration, {}),
      /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(import_react3.Scripts, {})
    ] })
  ] });
}
function CatchBoundary() {
  return /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("html", { children: [
    /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("head", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("title", { children: uiConstants_default.ERROR_PAGE.HEADER }),
      /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(import_react3.Meta, {}),
      /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(import_react3.Links, {})
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("body", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("h1", { children: uiConstants_default.ERROR_PAGE.USER_MESSAGE }),
      /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(import_react3.Scripts, {})
    ] })
  ] });
}

// app/routes/products.$productId.jsx
var products_productId_exports = {};
__export(products_productId_exports, {
  default: () => Product,
  loader: () => loader
});
var import_react5 = __toESM(require_dist3());

// app/components/common/HistoyBackButton.jsx
var import_react4 = __toESM(require_dist3()), import_jsx_runtime4 = __toESM(require_jsx_runtime()), HistoyBackButton = () => {
  let navigate = (0, import_react4.useNavigate)();
  return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("button", { className: "back-button", onClick: () => {
    navigate(-1);
  }, children: " \u2190 " });
}, HistoyBackButton_default = HistoyBackButton;

// app/components/common/Rating.jsx
var import_react_star_ratings = __toESM(require_build()), import_jsx_runtime5 = __toESM(require_jsx_runtime()), Ratings = ({ rating = 3.4 }) => /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
  import_react_star_ratings.default,
  {
    rating,
    starRatedColor: "#e8ca09",
    numberOfStars: 5,
    isSelectable: !1,
    starDimension: "20px",
    starSpacing: "2px"
  }
), Rating_default = Ratings;

// app/utils/helpers/builder.js
var buildPriceLabel = (price) => price ? price % 1 === 0 ? price + ".00\u20BA" : price + "\u20BA" : null, buildRating = (rating) => rating || 0;

// app/components/productPage/detailPage/ProductDetail.jsx
var import_jsx_runtime6 = __toESM(require_jsx_runtime()), ProductDetail = ({ product }) => /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("div", { className: "container", children: [
  /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("div", { className: "row", children: [
    /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("div", { className: "col-5", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("div", { className: "main-img", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("img", { className: "img-fluid", src: product.imageUrl, alt: "product" }) }) }),
    /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("div", { className: "col-7", children: [
      /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("div", { className: "main-description px-2", children: [
        /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("div", { className: "category-name text-bold", children: product.mkName }),
        /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("div", { className: "product-title text-bold my-3", children: product.productName }),
        /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("div", { className: "badge-section my-4", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("p", { className: "badge-label mb-0", children: product.badge }) }),
        /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(Rating_default, { rating: buildRating(product.rating) }),
        /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("div", { className: "buttons d-flex my-5", children: product.storageOptions.map((option) => /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("a", { href: "", className: "shadow btn m-0 me-2", children: option })) })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("div", { className: "price-area my-4", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("p", { className: "price-label mb-1", children: buildPriceLabel(product.price) }) }),
      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("p", { className: "shipping-label", children: product.freeShipping ? uiConstants_default.MAIN_PAGE.FREE_SHIPPING : uiConstants_default.MAIN_PAGE.PAID_SHIPPING }),
      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("p", { className: "text-secondary", children: product.lastUpdate ? uiConstants_default.MAIN_PAGE.UPDATE + product.lastUpdate : "" })
    ] })
  ] }),
  /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("div", { className: "row d-flex justify-content-end", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("div", { className: "col-2", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(HistoyBackButton_default, {}) }) })
] }), ProductDetail_default = ProductDetail;

// node_modules/axios/lib/helpers/bind.js
function bind(fn, thisArg) {
  return function() {
    return fn.apply(thisArg, arguments);
  };
}

// node_modules/axios/lib/utils.js
var { toString } = Object.prototype, { getPrototypeOf } = Object, kindOf = ((cache) => (thing) => {
  let str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), kindOfTest = (type) => (type = type.toLowerCase(), (thing) => kindOf(thing) === type), typeOfTest = (type) => (thing) => typeof thing === type, { isArray } = Array, isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? result = ArrayBuffer.isView(val) : result = val && val.buffer && isArrayBuffer(val.buffer), result;
}
var isString = typeOfTest("string"), isFunction = typeOfTest("function"), isNumber = typeOfTest("number"), isObject = (thing) => thing !== null && typeof thing == "object", isBoolean = (thing) => thing === !0 || thing === !1, isPlainObject = (val) => {
  if (kindOf(val) !== "object")
    return !1;
  let prototype3 = getPrototypeOf(val);
  return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
}, isDate = kindOfTest("Date"), isFile = kindOfTest("File"), isBlob = kindOfTest("Blob"), isFileList = kindOfTest("FileList"), isStream = (val) => isObject(val) && isFunction(val.pipe), isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData == "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
}, isURLSearchParams = kindOfTest("URLSearchParams"), trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = !1 } = {}) {
  if (obj === null || typeof obj > "u")
    return;
  let i, l;
  if (typeof obj != "object" && (obj = [obj]), isArray(obj))
    for (i = 0, l = obj.length; i < l; i++)
      fn.call(null, obj[i], i, obj);
  else {
    let keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj), len = keys.length, key;
    for (i = 0; i < len; i++)
      key = keys[i], fn.call(null, obj[key], key, obj);
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  let keys = Object.keys(obj), i = keys.length, _key;
  for (; i-- > 0; )
    if (_key = keys[i], key === _key.toLowerCase())
      return _key;
  return null;
}
var _global = (() => typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global)(), isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  let { caseless } = isContextDefined(this) && this || {}, result = {}, assignValue = (val, key) => {
    let targetKey = caseless && findKey(result, key) || key;
    isPlainObject(result[targetKey]) && isPlainObject(val) ? result[targetKey] = merge(result[targetKey], val) : isPlainObject(val) ? result[targetKey] = merge({}, val) : isArray(val) ? result[targetKey] = val.slice() : result[targetKey] = val;
  };
  for (let i = 0, l = arguments.length; i < l; i++)
    arguments[i] && forEach(arguments[i], assignValue);
  return result;
}
var extend = (a, b, thisArg, { allOwnKeys } = {}) => (forEach(b, (val, key) => {
  thisArg && isFunction(val) ? a[key] = bind(val, thisArg) : a[key] = val;
}, { allOwnKeys }), a), stripBOM = (content) => (content.charCodeAt(0) === 65279 && (content = content.slice(1)), content), inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2), constructor.prototype.constructor = constructor, Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  }), props && Object.assign(constructor.prototype, props);
}, toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props, i, prop, merged = {};
  if (destObj = destObj || {}, sourceObj == null)
    return destObj;
  do {
    for (props = Object.getOwnPropertyNames(sourceObj), i = props.length; i-- > 0; )
      prop = props[i], (!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop] && (destObj[prop] = sourceObj[prop], merged[prop] = !0);
    sourceObj = filter2 !== !1 && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
}, endsWith = (str, searchString, position) => {
  str = String(str), (position === void 0 || position > str.length) && (position = str.length), position -= searchString.length;
  let lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
}, toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray(thing))
    return thing;
  let i = thing.length;
  if (!isNumber(i))
    return null;
  let arr = new Array(i);
  for (; i-- > 0; )
    arr[i] = thing[i];
  return arr;
}, isTypedArray = ((TypedArray) => (thing) => TypedArray && thing instanceof TypedArray)(typeof Uint8Array < "u" && getPrototypeOf(Uint8Array)), forEachEntry = (obj, fn) => {
  let iterator = (obj && obj[Symbol.iterator]).call(obj), result;
  for (; (result = iterator.next()) && !result.done; ) {
    let pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
}, matchAll = (regExp, str) => {
  let matches, arr = [];
  for (; (matches = regExp.exec(str)) !== null; )
    arr.push(matches);
  return arr;
}, isHTMLForm = kindOfTest("HTMLFormElement"), toCamelCase = (str) => str.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(m, p1, p2) {
    return p1.toUpperCase() + p2;
  }
), hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype), isRegExp = kindOfTest("RegExp"), reduceDescriptors = (obj, reducer) => {
  let descriptors2 = Object.getOwnPropertyDescriptors(obj), reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    reducer(descriptor, name, obj) !== !1 && (reducedDescriptors[name] = descriptor);
  }), Object.defineProperties(obj, reducedDescriptors);
}, freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1)
      return !1;
    let value = obj[name];
    if (isFunction(value)) {
      if (descriptor.enumerable = !1, "writable" in descriptor) {
        descriptor.writable = !1;
        return;
      }
      descriptor.set || (descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      });
    }
  });
}, toObjectSet = (arrayOrString, delimiter) => {
  let obj = {}, define2 = (arr) => {
    arr.forEach((value) => {
      obj[value] = !0;
    });
  };
  return isArray(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter)), obj;
}, noop = () => {
}, toFiniteNumber = (value, defaultValue) => (value = +value, Number.isFinite(value) ? value : defaultValue), ALPHA = "abcdefghijklmnopqrstuvwxyz", DIGIT = "0123456789", ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
}, generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "", { length } = alphabet;
  for (; size--; )
    str += alphabet[Math.random() * length | 0];
  return str;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
var toJSONObject = (obj) => {
  let stack = new Array(10), visit = (source, i) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0)
        return;
      if (!("toJSON" in source)) {
        stack[i] = source;
        let target = isArray(source) ? [] : {};
        return forEach(source, (value, key) => {
          let reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        }), stack[i] = void 0, target;
      }
    }
    return source;
  };
  return visit(obj, 0);
}, isAsyncFn = kindOfTest("AsyncFunction"), isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch), utils_default = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable
};

// node_modules/axios/lib/core/AxiosError.js
function AxiosError(message, code, config, request, response) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = message, this.name = "AxiosError", code && (this.code = code), config && (this.config = config), request && (this.request = request), response && (this.response = response);
}
utils_default.inherits(AxiosError, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils_default.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
var prototype = AxiosError.prototype, descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: !0 });
AxiosError.from = (error, code, config, request, response, customProps) => {
  let axiosError = Object.create(prototype);
  return utils_default.toFlatObject(error, axiosError, function(obj) {
    return obj !== Error.prototype;
  }, (prop) => prop !== "isAxiosError"), AxiosError.call(axiosError, error.message, code, config, request, response), axiosError.cause = error, axiosError.name = error.name, customProps && Object.assign(axiosError, customProps), axiosError;
};
var AxiosError_default = AxiosError;

// node_modules/axios/lib/platform/node/classes/FormData.js
var import_form_data = __toESM(require_form_data2(), 1), FormData_default = import_form_data.default;

// node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  return path ? path.concat(key).map(function(token, i) {
    return token = removeBrackets(token), !dots && i ? "[" + token + "]" : token;
  }).join(dots ? "." : "") : key;
}
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
var predicates = utils_default.toFlatObject(utils_default, {}, null, function(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils_default.isObject(obj))
    throw new TypeError("target must be an object");
  formData = formData || new (FormData_default || FormData)(), options = utils_default.toFlatObject(options, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(option, source) {
    return !utils_default.isUndefined(source[option]);
  });
  let metaTokens = options.metaTokens, visitor = options.visitor || defaultVisitor, dots = options.dots, indexes = options.indexes, useBlob = (options.Blob || typeof Blob < "u" && Blob) && utils_default.isSpecCompliantForm(formData);
  if (!utils_default.isFunction(visitor))
    throw new TypeError("visitor must be a function");
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils_default.isDate(value))
      return value.toISOString();
    if (!useBlob && utils_default.isBlob(value))
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    return utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value) ? useBlob && typeof Blob == "function" ? new Blob([value]) : Buffer.from(value) : value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value == "object") {
      if (utils_default.endsWith(key, "{}"))
        key = metaTokens ? key : key.slice(0, -2), value = JSON.stringify(value);
      else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value)))
        return key = removeBrackets(key), arr.forEach(function(el, index) {
          !(utils_default.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === !0 ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        }), !1;
    }
    return isVisitable(value) ? !0 : (formData.append(renderKey(path, key, dots), convertValue(value)), !1);
  }
  let stack = [], exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (!utils_default.isUndefined(value)) {
      if (stack.indexOf(value) !== -1)
        throw Error("Circular reference detected in " + path.join("."));
      stack.push(value), utils_default.forEach(value, function(el, key) {
        (!(utils_default.isUndefined(el) || el === null) && visitor.call(
          formData,
          el,
          utils_default.isString(key) ? key.trim() : key,
          path,
          exposedHelpers
        )) === !0 && build(el, path ? path.concat(key) : [key]);
      }), stack.pop();
    }
  }
  if (!utils_default.isObject(obj))
    throw new TypeError("data must be an object");
  return build(obj), formData;
}
var toFormData_default = toFormData;

// node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode(str) {
  let charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [], params && toFormData_default(params, this, options);
}
var prototype2 = AxiosURLSearchParams.prototype;
prototype2.append = function(name, value) {
  this._pairs.push([name, value]);
};
prototype2.toString = function(encoder) {
  let _encode = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;
  return this._pairs.map(function(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;

// node_modules/axios/lib/helpers/buildURL.js
function encode2(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url2, params, options) {
  if (!params)
    return url2;
  let _encode = options && options.encode || encode2, serializeFn = options && options.serialize, serializedParams;
  if (serializeFn ? serializedParams = serializeFn(params, options) : serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode), serializedParams) {
    let hashmarkIndex = url2.indexOf("#");
    hashmarkIndex !== -1 && (url2 = url2.slice(0, hashmarkIndex)), url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url2;
}

// node_modules/axios/lib/core/InterceptorManager.js
var InterceptorManager = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    return this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : !1,
      runWhen: options ? options.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    this.handlers[id] && (this.handlers[id] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils_default.forEach(this.handlers, function(h) {
      h !== null && fn(h);
    });
  }
}, InterceptorManager_default = InterceptorManager;

// node_modules/axios/lib/defaults/transitional.js
var transitional_default = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
};

// node_modules/axios/lib/platform/node/classes/URLSearchParams.js
var import_url = __toESM(require("url"), 1), URLSearchParams_default = import_url.default.URLSearchParams;

// node_modules/axios/lib/platform/node/index.js
var node_default = {
  isNode: !0,
  classes: {
    URLSearchParams: URLSearchParams_default,
    FormData: FormData_default,
    Blob: typeof Blob < "u" && Blob || null
  },
  protocols: ["http", "https", "file", "data"]
};

// node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new node_default.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      return node_default.isNode && utils_default.isBuffer(value) ? (this.append(key, value.toString("base64")), !1) : helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

// node_modules/axios/lib/helpers/formDataToJSON.js
function parsePropPath(name) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name).map((match) => match[0] === "[]" ? "" : match[1] || match[0]);
}
function arrayToObject(arr) {
  let obj = {}, keys = Object.keys(arr), i, len = keys.length, key;
  for (i = 0; i < len; i++)
    key = keys[i], obj[key] = arr[key];
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++], isNumericKey = Number.isFinite(+name), isLast = index >= path.length;
    return name = !name && utils_default.isArray(target) ? target.length : name, isLast ? (utils_default.hasOwnProp(target, name) ? target[name] = [target[name], value] : target[name] = value, !isNumericKey) : ((!target[name] || !utils_default.isObject(target[name])) && (target[name] = []), buildPath(path, value, target[name], index) && utils_default.isArray(target[name]) && (target[name] = arrayToObject(target[name])), !isNumericKey);
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    let obj = {};
    return utils_default.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    }), obj;
  }
  return null;
}
var formDataToJSON_default = formDataToJSON;

// node_modules/axios/lib/defaults/index.js
var DEFAULT_CONTENT_TYPE = {
  "Content-Type": void 0
};
function stringifySafely(rawValue, parser, encoder) {
  if (utils_default.isString(rawValue))
    try {
      return (parser || JSON.parse)(rawValue), utils_default.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError")
        throw e;
    }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults = {
  transitional: transitional_default,
  adapter: ["xhr", "http"],
  transformRequest: [function(data, headers) {
    let contentType = headers.getContentType() || "", hasJSONContentType = contentType.indexOf("application/json") > -1, isObjectPayload = utils_default.isObject(data);
    if (isObjectPayload && utils_default.isHTMLForm(data) && (data = new FormData(data)), utils_default.isFormData(data))
      return hasJSONContentType && hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
    if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data))
      return data;
    if (utils_default.isArrayBufferView(data))
      return data.buffer;
    if (utils_default.isURLSearchParams(data))
      return headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), data.toString();
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1)
        return toURLEncodedForm(data, this.formSerializer).toString();
      if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        let _FormData = this.env && this.env.FormData;
        return toFormData_default(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    return isObjectPayload || hasJSONContentType ? (headers.setContentType("application/json", !1), stringifySafely(data)) : data;
  }],
  transformResponse: [function(data) {
    let transitional2 = this.transitional || defaults.transitional, forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing, JSONRequested = this.responseType === "json";
    if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      let strictJSONParsing = !(transitional2 && transitional2.silentJSONParsing) && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing)
          throw e.name === "SyntaxError" ? AxiosError_default.from(e, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response) : e;
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: node_default.classes.FormData,
    Blob: node_default.classes.Blob
  },
  validateStatus: function(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*"
    }
  }
};
utils_default.forEach(["delete", "get", "head"], function(method) {
  defaults.headers[method] = {};
});
utils_default.forEach(["post", "put", "patch"], function(method) {
  defaults.headers[method] = utils_default.merge(DEFAULT_CONTENT_TYPE);
});
var defaults_default = defaults;

// node_modules/axios/lib/helpers/parseHeaders.js
var ignoreDuplicateOf = utils_default.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), parseHeaders_default = (rawHeaders) => {
  let parsed = {}, key, val, i;
  return rawHeaders && rawHeaders.split(`
`).forEach(function(line) {
    i = line.indexOf(":"), key = line.substring(0, i).trim().toLowerCase(), val = line.substring(i + 1).trim(), !(!key || parsed[key] && ignoreDuplicateOf[key]) && (key === "set-cookie" ? parsed[key] ? parsed[key].push(val) : parsed[key] = [val] : parsed[key] = parsed[key] ? parsed[key] + ", " + val : val);
  }), parsed;
};

// node_modules/axios/lib/core/AxiosHeaders.js
var $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  return value === !1 || value == null ? value : utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  let tokens = /* @__PURE__ */ Object.create(null), tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g, match;
  for (; match = tokensRE.exec(str); )
    tokens[match[1]] = match[2];
  return tokens;
}
var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils_default.isFunction(filter2))
    return filter2.call(this, value, header);
  if (isHeaderNameFilter && (value = header), !!utils_default.isString(value)) {
    if (utils_default.isString(filter2))
      return value.indexOf(filter2) !== -1;
    if (utils_default.isRegExp(filter2))
      return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => char.toUpperCase() + str);
}
function buildAccessors(obj, header) {
  let accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: !0
    });
  });
}
var AxiosHeaders = class {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    let self2 = this;
    function setHeader(_value, _header, _rewrite) {
      let lHeader = normalizeHeader(_header);
      if (!lHeader)
        throw new Error("header name must be a non-empty string");
      let key = utils_default.findKey(self2, lHeader);
      (!key || self2[key] === void 0 || _rewrite === !0 || _rewrite === void 0 && self2[key] !== !1) && (self2[key || _header] = normalizeValue(_value));
    }
    let setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    return utils_default.isPlainObject(header) || header instanceof this.constructor ? setHeaders(header, valueOrRewrite) : utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header) ? setHeaders(parseHeaders_default(header), valueOrRewrite) : header != null && setHeader(valueOrRewrite, header, rewrite), this;
  }
  get(header, parser) {
    if (header = normalizeHeader(header), header) {
      let key = utils_default.findKey(this, header);
      if (key) {
        let value = this[key];
        if (!parser)
          return value;
        if (parser === !0)
          return parseTokens(value);
        if (utils_default.isFunction(parser))
          return parser.call(this, value, key);
        if (utils_default.isRegExp(parser))
          return parser.exec(value);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    if (header = normalizeHeader(header), header) {
      let key = utils_default.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return !1;
  }
  delete(header, matcher) {
    let self2 = this, deleted = !1;
    function deleteHeader(_header) {
      if (_header = normalizeHeader(_header), _header) {
        let key = utils_default.findKey(self2, _header);
        key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher)) && (delete self2[key], deleted = !0);
      }
    }
    return utils_default.isArray(header) ? header.forEach(deleteHeader) : deleteHeader(header), deleted;
  }
  clear(matcher) {
    let keys = Object.keys(this), i = keys.length, deleted = !1;
    for (; i--; ) {
      let key = keys[i];
      (!matcher || matchHeaderValue(this, this[key], key, matcher, !0)) && (delete this[key], deleted = !0);
    }
    return deleted;
  }
  normalize(format) {
    let self2 = this, headers = {};
    return utils_default.forEach(this, (value, header) => {
      let key = utils_default.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value), delete self2[header];
        return;
      }
      let normalized = format ? formatHeader(header) : String(header).trim();
      normalized !== header && delete self2[header], self2[normalized] = normalizeValue(value), headers[normalized] = !0;
    }), this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    let obj = /* @__PURE__ */ Object.create(null);
    return utils_default.forEach(this, (value, header) => {
      value != null && value !== !1 && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
    }), obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    let computed = new this(first);
    return targets.forEach((target) => computed.set(target)), computed;
  }
  static accessor(header) {
    let accessors = (this[$internals] = this[$internals] = {
      accessors: {}
    }).accessors, prototype3 = this.prototype;
    function defineAccessor(_header) {
      let lHeader = normalizeHeader(_header);
      accessors[lHeader] || (buildAccessors(prototype3, _header), accessors[lHeader] = !0);
    }
    return utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header), this;
  }
};
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils_default.freezeMethods(AxiosHeaders.prototype);
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;

// node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  let config = this || defaults_default, context = response || config, headers = AxiosHeaders_default.from(context.headers), data = context.data;
  return utils_default.forEach(fns, function(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
  }), headers.normalize(), data;
}

// node_modules/axios/lib/cancel/isCancel.js
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

// node_modules/axios/lib/cancel/CanceledError.js
function CanceledError(message, config, request) {
  AxiosError_default.call(this, message ?? "canceled", AxiosError_default.ERR_CANCELED, config, request), this.name = "CanceledError";
}
utils_default.inherits(CanceledError, AxiosError_default, {
  __CANCEL__: !0
});
var CanceledError_default = CanceledError;

// node_modules/axios/lib/core/settle.js
function settle(resolve, reject, response) {
  let validateStatus2 = response.config.validateStatus;
  !response.status || !validateStatus2 || validateStatus2(response.status) ? resolve(response) : reject(new AxiosError_default(
    "Request failed with status code " + response.status,
    [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
    response.config,
    response.request,
    response
  ));
}

// node_modules/axios/lib/helpers/isAbsoluteURL.js
function isAbsoluteURL(url2) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
}

// node_modules/axios/lib/helpers/combineURLs.js
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

// node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL) {
  return baseURL && !isAbsoluteURL(requestedURL) ? combineURLs(baseURL, requestedURL) : requestedURL;
}

// node_modules/axios/lib/adapters/http.js
var import_proxy_from_env = __toESM(require_proxy_from_env(), 1), import_http = __toESM(require("http"), 1), import_https = __toESM(require("https"), 1), import_util2 = __toESM(require("util"), 1), import_follow_redirects = __toESM(require_follow_redirects(), 1), import_zlib = __toESM(require("zlib"), 1);

// node_modules/axios/lib/env/data.js
var VERSION = "1.4.0";

// node_modules/axios/lib/helpers/parseProtocol.js
function parseProtocol(url2) {
  let match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
  return match && match[1] || "";
}

// node_modules/axios/lib/helpers/fromDataURI.js
var DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
function fromDataURI(uri, asBlob, options) {
  let _Blob = options && options.Blob || node_default.classes.Blob, protocol = parseProtocol(uri);
  if (asBlob === void 0 && _Blob && (asBlob = !0), protocol === "data") {
    uri = protocol.length ? uri.slice(protocol.length + 1) : uri;
    let match = DATA_URL_PATTERN.exec(uri);
    if (!match)
      throw new AxiosError_default("Invalid URL", AxiosError_default.ERR_INVALID_URL);
    let mime = match[1], isBase64 = match[2], body = match[3], buffer = Buffer.from(decodeURIComponent(body), isBase64 ? "base64" : "utf8");
    if (asBlob) {
      if (!_Blob)
        throw new AxiosError_default("Blob is not supported", AxiosError_default.ERR_NOT_SUPPORT);
      return new _Blob([buffer], { type: mime });
    }
    return buffer;
  }
  throw new AxiosError_default("Unsupported protocol " + protocol, AxiosError_default.ERR_NOT_SUPPORT);
}

// node_modules/axios/lib/adapters/http.js
var import_stream5 = __toESM(require("stream"), 1);

// node_modules/axios/lib/helpers/AxiosTransformStream.js
var import_stream2 = __toESM(require("stream"), 1);

// node_modules/axios/lib/helpers/throttle.js
function throttle(fn, freq) {
  let timestamp = 0, threshold = 1e3 / freq, timer = null;
  return function(force, args) {
    let now = Date.now();
    if (force || now - timestamp > threshold)
      return timer && (clearTimeout(timer), timer = null), timestamp = now, fn.apply(null, args);
    timer || (timer = setTimeout(() => (timer = null, timestamp = Date.now(), fn.apply(null, args)), threshold - (now - timestamp)));
  };
}
var throttle_default = throttle;

// node_modules/axios/lib/helpers/speedometer.js
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  let bytes = new Array(samplesCount), timestamps = new Array(samplesCount), head = 0, tail = 0, firstSampleTS;
  return min = min !== void 0 ? min : 1e3, function(chunkLength) {
    let now = Date.now(), startedAt = timestamps[tail];
    firstSampleTS || (firstSampleTS = now), bytes[head] = chunkLength, timestamps[head] = now;
    let i = tail, bytesCount = 0;
    for (; i !== head; )
      bytesCount += bytes[i++], i = i % samplesCount;
    if (head = (head + 1) % samplesCount, head === tail && (tail = (tail + 1) % samplesCount), now - firstSampleTS < min)
      return;
    let passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
var speedometer_default = speedometer;

// node_modules/axios/lib/helpers/AxiosTransformStream.js
var kInternals = Symbol("internals"), AxiosTransformStream = class extends import_stream2.default.Transform {
  constructor(options) {
    options = utils_default.toFlatObject(options, {
      maxRate: 0,
      chunkSize: 64 * 1024,
      minChunkSize: 100,
      timeWindow: 500,
      ticksRate: 2,
      samplesCount: 15
    }, null, (prop, source) => !utils_default.isUndefined(source[prop])), super({
      readableHighWaterMark: options.chunkSize
    });
    let self2 = this, internals = this[kInternals] = {
      length: options.length,
      timeWindow: options.timeWindow,
      ticksRate: options.ticksRate,
      chunkSize: options.chunkSize,
      maxRate: options.maxRate,
      minChunkSize: options.minChunkSize,
      bytesSeen: 0,
      isCaptured: !1,
      notifiedBytesLoaded: 0,
      ts: Date.now(),
      bytes: 0,
      onReadCallback: null
    }, _speedometer = speedometer_default(internals.ticksRate * options.samplesCount, internals.timeWindow);
    this.on("newListener", (event) => {
      event === "progress" && (internals.isCaptured || (internals.isCaptured = !0));
    });
    let bytesNotified = 0;
    internals.updateProgress = throttle_default(function() {
      let totalBytes = internals.length, bytesTransferred = internals.bytesSeen, progressBytes = bytesTransferred - bytesNotified;
      if (!progressBytes || self2.destroyed)
        return;
      let rate = _speedometer(progressBytes);
      bytesNotified = bytesTransferred, process.nextTick(() => {
        self2.emit("progress", {
          loaded: bytesTransferred,
          total: totalBytes,
          progress: totalBytes ? bytesTransferred / totalBytes : void 0,
          bytes: progressBytes,
          rate: rate || void 0,
          estimated: rate && totalBytes && bytesTransferred <= totalBytes ? (totalBytes - bytesTransferred) / rate : void 0
        });
      });
    }, internals.ticksRate);
    let onFinish = () => {
      internals.updateProgress(!0);
    };
    this.once("end", onFinish), this.once("error", onFinish);
  }
  _read(size) {
    let internals = this[kInternals];
    return internals.onReadCallback && internals.onReadCallback(), super._read(size);
  }
  _transform(chunk, encoding, callback) {
    let self2 = this, internals = this[kInternals], maxRate = internals.maxRate, readableHighWaterMark = this.readableHighWaterMark, timeWindow = internals.timeWindow, divider = 1e3 / timeWindow, bytesThreshold = maxRate / divider, minChunkSize = internals.minChunkSize !== !1 ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;
    function pushChunk(_chunk, _callback) {
      let bytes = Buffer.byteLength(_chunk);
      internals.bytesSeen += bytes, internals.bytes += bytes, internals.isCaptured && internals.updateProgress(), self2.push(_chunk) ? process.nextTick(_callback) : internals.onReadCallback = () => {
        internals.onReadCallback = null, process.nextTick(_callback);
      };
    }
    let transformChunk = (_chunk, _callback) => {
      let chunkSize = Buffer.byteLength(_chunk), chunkRemainder = null, maxChunkSize = readableHighWaterMark, bytesLeft, passed = 0;
      if (maxRate) {
        let now = Date.now();
        (!internals.ts || (passed = now - internals.ts) >= timeWindow) && (internals.ts = now, bytesLeft = bytesThreshold - internals.bytes, internals.bytes = bytesLeft < 0 ? -bytesLeft : 0, passed = 0), bytesLeft = bytesThreshold - internals.bytes;
      }
      if (maxRate) {
        if (bytesLeft <= 0)
          return setTimeout(() => {
            _callback(null, _chunk);
          }, timeWindow - passed);
        bytesLeft < maxChunkSize && (maxChunkSize = bytesLeft);
      }
      maxChunkSize && chunkSize > maxChunkSize && chunkSize - maxChunkSize > minChunkSize && (chunkRemainder = _chunk.subarray(maxChunkSize), _chunk = _chunk.subarray(0, maxChunkSize)), pushChunk(_chunk, chunkRemainder ? () => {
        process.nextTick(_callback, null, chunkRemainder);
      } : _callback);
    };
    transformChunk(chunk, function transformNextChunk(err, _chunk) {
      if (err)
        return callback(err);
      _chunk ? transformChunk(_chunk, transformNextChunk) : callback(null);
    });
  }
  setLength(length) {
    return this[kInternals].length = +length, this;
  }
}, AxiosTransformStream_default = AxiosTransformStream;

// node_modules/axios/lib/adapters/http.js
var import_events = __toESM(require("events"), 1);

// node_modules/axios/lib/helpers/formDataToStream.js
var import_util = require("util"), import_stream3 = require("stream");

// node_modules/axios/lib/helpers/readBlob.js
var { asyncIterator } = Symbol, readBlob = async function* (blob) {
  blob.stream ? yield* blob.stream() : blob.arrayBuffer ? yield await blob.arrayBuffer() : blob[asyncIterator] ? yield* blob[asyncIterator]() : yield blob;
}, readBlob_default = readBlob;

// node_modules/axios/lib/helpers/formDataToStream.js
var BOUNDARY_ALPHABET = utils_default.ALPHABET.ALPHA_DIGIT + "-_", textEncoder = new import_util.TextEncoder(), CRLF = `\r
`, CRLF_BYTES = textEncoder.encode(CRLF), CRLF_BYTES_COUNT = 2, FormDataPart = class {
  constructor(name, value) {
    let { escapeName } = this.constructor, isStringValue = utils_default.isString(value), headers = `Content-Disposition: form-data; name="${escapeName(name)}"${!isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ""}${CRLF}`;
    isStringValue ? value = textEncoder.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF)) : headers += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`, this.headers = textEncoder.encode(headers + CRLF), this.contentLength = isStringValue ? value.byteLength : value.size, this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT, this.name = name, this.value = value;
  }
  async *encode() {
    yield this.headers;
    let { value } = this;
    utils_default.isTypedArray(value) ? yield value : yield* readBlob_default(value), yield CRLF_BYTES;
  }
  static escapeName(name) {
    return String(name).replace(/[\r\n"]/g, (match) => ({
      "\r": "%0D",
      "\n": "%0A",
      '"': "%22"
    })[match]);
  }
}, formDataToStream = (form, headersHandler, options) => {
  let {
    tag = "form-data-boundary",
    size = 25,
    boundary = tag + "-" + utils_default.generateString(size, BOUNDARY_ALPHABET)
  } = options || {};
  if (!utils_default.isFormData(form))
    throw TypeError("FormData instance required");
  if (boundary.length < 1 || boundary.length > 70)
    throw Error("boundary must be 10-70 characters long");
  let boundaryBytes = textEncoder.encode("--" + boundary + CRLF), footerBytes = textEncoder.encode("--" + boundary + "--" + CRLF + CRLF), contentLength = footerBytes.byteLength, parts = Array.from(form.entries()).map(([name, value]) => {
    let part = new FormDataPart(name, value);
    return contentLength += part.size, part;
  });
  contentLength += boundaryBytes.byteLength * parts.length, contentLength = utils_default.toFiniteNumber(contentLength);
  let computedHeaders = {
    "Content-Type": `multipart/form-data; boundary=${boundary}`
  };
  return Number.isFinite(contentLength) && (computedHeaders["Content-Length"] = contentLength), headersHandler && headersHandler(computedHeaders), import_stream3.Readable.from(async function* () {
    for (let part of parts)
      yield boundaryBytes, yield* part.encode();
    yield footerBytes;
  }());
}, formDataToStream_default = formDataToStream;

// node_modules/axios/lib/helpers/ZlibHeaderTransformStream.js
var import_stream4 = __toESM(require("stream"), 1), ZlibHeaderTransformStream = class extends import_stream4.default.Transform {
  __transform(chunk, encoding, callback) {
    this.push(chunk), callback();
  }
  _transform(chunk, encoding, callback) {
    if (chunk.length !== 0 && (this._transform = this.__transform, chunk[0] !== 120)) {
      let header = Buffer.alloc(2);
      header[0] = 120, header[1] = 156, this.push(header, encoding);
    }
    this.__transform(chunk, encoding, callback);
  }
}, ZlibHeaderTransformStream_default = ZlibHeaderTransformStream;

// node_modules/axios/lib/helpers/callbackify.js
var callbackify = (fn, reducer) => utils_default.isAsyncFn(fn) ? function(...args) {
  let cb = args.pop();
  fn.apply(this, args).then((value) => {
    try {
      reducer ? cb(null, ...reducer(value)) : cb(null, value);
    } catch (err) {
      cb(err);
    }
  }, cb);
} : fn, callbackify_default = callbackify;

// node_modules/axios/lib/adapters/http.js
var zlibOptions = {
  flush: import_zlib.default.constants.Z_SYNC_FLUSH,
  finishFlush: import_zlib.default.constants.Z_SYNC_FLUSH
}, brotliOptions = {
  flush: import_zlib.default.constants.BROTLI_OPERATION_FLUSH,
  finishFlush: import_zlib.default.constants.BROTLI_OPERATION_FLUSH
}, isBrotliSupported = utils_default.isFunction(import_zlib.default.createBrotliDecompress), { http: httpFollow, https: httpsFollow } = import_follow_redirects.default, isHttps = /https:?/, supportedProtocols = node_default.protocols.map((protocol) => protocol + ":");
function dispatchBeforeRedirect(options) {
  options.beforeRedirects.proxy && options.beforeRedirects.proxy(options), options.beforeRedirects.config && options.beforeRedirects.config(options);
}
function setProxy(options, configProxy, location) {
  let proxy = configProxy;
  if (!proxy && proxy !== !1) {
    let proxyUrl = (0, import_proxy_from_env.getProxyForUrl)(location);
    proxyUrl && (proxy = new URL(proxyUrl));
  }
  if (proxy) {
    if (proxy.username && (proxy.auth = (proxy.username || "") + ":" + (proxy.password || "")), proxy.auth) {
      (proxy.auth.username || proxy.auth.password) && (proxy.auth = (proxy.auth.username || "") + ":" + (proxy.auth.password || ""));
      let base64 = Buffer.from(proxy.auth, "utf8").toString("base64");
      options.headers["Proxy-Authorization"] = "Basic " + base64;
    }
    options.headers.host = options.hostname + (options.port ? ":" + options.port : "");
    let proxyHost = proxy.hostname || proxy.host;
    options.hostname = proxyHost, options.host = proxyHost, options.port = proxy.port, options.path = location, proxy.protocol && (options.protocol = proxy.protocol.includes(":") ? proxy.protocol : `${proxy.protocol}:`);
  }
  options.beforeRedirects.proxy = function(redirectOptions) {
    setProxy(redirectOptions, configProxy, redirectOptions.href);
  };
}
var isHttpAdapterSupported = typeof process < "u" && utils_default.kindOf(process) === "process", wrapAsync = (asyncExecutor) => new Promise((resolve, reject) => {
  let onDone, isDone, done = (value, isRejected) => {
    isDone || (isDone = !0, onDone && onDone(value, isRejected));
  }, _resolve = (value) => {
    done(value), resolve(value);
  }, _reject = (reason) => {
    done(reason, !0), reject(reason);
  };
  asyncExecutor(_resolve, _reject, (onDoneHandler) => onDone = onDoneHandler).catch(_reject);
}), http_default = isHttpAdapterSupported && function(config) {
  return wrapAsync(async function(resolve, reject, onDone) {
    let { data, lookup, family } = config, { responseType, responseEncoding } = config, method = config.method.toUpperCase(), isDone, rejected = !1, req;
    lookup && utils_default.isAsyncFn(lookup) && (lookup = callbackify_default(lookup, (entry2) => {
      if (utils_default.isString(entry2))
        entry2 = [entry2, entry2.indexOf(".") < 0 ? 6 : 4];
      else if (!utils_default.isArray(entry2))
        throw new TypeError("lookup async function must return an array [ip: string, family: number]]");
      return entry2;
    }));
    let emitter = new import_events.default(), onFinished = () => {
      config.cancelToken && config.cancelToken.unsubscribe(abort), config.signal && config.signal.removeEventListener("abort", abort), emitter.removeAllListeners();
    };
    onDone((value, isRejected) => {
      isDone = !0, isRejected && (rejected = !0, onFinished());
    });
    function abort(reason) {
      emitter.emit("abort", !reason || reason.type ? new CanceledError_default(null, config, req) : reason);
    }
    emitter.once("abort", reject), (config.cancelToken || config.signal) && (config.cancelToken && config.cancelToken.subscribe(abort), config.signal && (config.signal.aborted ? abort() : config.signal.addEventListener("abort", abort)));
    let fullPath = buildFullPath(config.baseURL, config.url), parsed = new URL(fullPath, "http://localhost"), protocol = parsed.protocol || supportedProtocols[0];
    if (protocol === "data:") {
      let convertedData;
      if (method !== "GET")
        return settle(resolve, reject, {
          status: 405,
          statusText: "method not allowed",
          headers: {},
          config
        });
      try {
        convertedData = fromDataURI(config.url, responseType === "blob", {
          Blob: config.env && config.env.Blob
        });
      } catch (err) {
        throw AxiosError_default.from(err, AxiosError_default.ERR_BAD_REQUEST, config);
      }
      return responseType === "text" ? (convertedData = convertedData.toString(responseEncoding), (!responseEncoding || responseEncoding === "utf8") && (convertedData = utils_default.stripBOM(convertedData))) : responseType === "stream" && (convertedData = import_stream5.default.Readable.from(convertedData)), settle(resolve, reject, {
        data: convertedData,
        status: 200,
        statusText: "OK",
        headers: new AxiosHeaders_default(),
        config
      });
    }
    if (supportedProtocols.indexOf(protocol) === -1)
      return reject(new AxiosError_default(
        "Unsupported protocol " + protocol,
        AxiosError_default.ERR_BAD_REQUEST,
        config
      ));
    let headers = AxiosHeaders_default.from(config.headers).normalize();
    headers.set("User-Agent", "axios/" + VERSION, !1);
    let onDownloadProgress = config.onDownloadProgress, onUploadProgress = config.onUploadProgress, maxRate = config.maxRate, maxUploadRate, maxDownloadRate;
    if (utils_default.isSpecCompliantForm(data)) {
      let userBoundary = headers.getContentType(/boundary=([-_\w\d]{10,70})/i);
      data = formDataToStream_default(data, (formHeaders) => {
        headers.set(formHeaders);
      }, {
        tag: `axios-${VERSION}-boundary`,
        boundary: userBoundary && userBoundary[1] || void 0
      });
    } else if (utils_default.isFormData(data) && utils_default.isFunction(data.getHeaders)) {
      if (headers.set(data.getHeaders()), !headers.hasContentLength())
        try {
          let knownLength = await import_util2.default.promisify(data.getLength).call(data);
          Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);
        } catch {
        }
    } else if (utils_default.isBlob(data))
      data.size && headers.setContentType(data.type || "application/octet-stream"), headers.setContentLength(data.size || 0), data = import_stream5.default.Readable.from(readBlob_default(data));
    else if (data && !utils_default.isStream(data)) {
      if (!Buffer.isBuffer(data))
        if (utils_default.isArrayBuffer(data))
          data = Buffer.from(new Uint8Array(data));
        else if (utils_default.isString(data))
          data = Buffer.from(data, "utf-8");
        else
          return reject(new AxiosError_default(
            "Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
            AxiosError_default.ERR_BAD_REQUEST,
            config
          ));
      if (headers.setContentLength(data.length, !1), config.maxBodyLength > -1 && data.length > config.maxBodyLength)
        return reject(new AxiosError_default(
          "Request body larger than maxBodyLength limit",
          AxiosError_default.ERR_BAD_REQUEST,
          config
        ));
    }
    let contentLength = utils_default.toFiniteNumber(headers.getContentLength());
    utils_default.isArray(maxRate) ? (maxUploadRate = maxRate[0], maxDownloadRate = maxRate[1]) : maxUploadRate = maxDownloadRate = maxRate, data && (onUploadProgress || maxUploadRate) && (utils_default.isStream(data) || (data = import_stream5.default.Readable.from(data, { objectMode: !1 })), data = import_stream5.default.pipeline([data, new AxiosTransformStream_default({
      length: contentLength,
      maxRate: utils_default.toFiniteNumber(maxUploadRate)
    })], utils_default.noop), onUploadProgress && data.on("progress", (progress) => {
      onUploadProgress(Object.assign(progress, {
        upload: !0
      }));
    }));
    let auth;
    if (config.auth) {
      let username = config.auth.username || "", password = config.auth.password || "";
      auth = username + ":" + password;
    }
    if (!auth && parsed.username) {
      let urlUsername = parsed.username, urlPassword = parsed.password;
      auth = urlUsername + ":" + urlPassword;
    }
    auth && headers.delete("authorization");
    let path;
    try {
      path = buildURL(
        parsed.pathname + parsed.search,
        config.params,
        config.paramsSerializer
      ).replace(/^\?/, "");
    } catch (err) {
      let customErr = new Error(err.message);
      return customErr.config = config, customErr.url = config.url, customErr.exists = !0, reject(customErr);
    }
    headers.set(
      "Accept-Encoding",
      "gzip, compress, deflate" + (isBrotliSupported ? ", br" : ""),
      !1
    );
    let options = {
      path,
      method,
      headers: headers.toJSON(),
      agents: { http: config.httpAgent, https: config.httpsAgent },
      auth,
      protocol,
      family,
      lookup,
      beforeRedirect: dispatchBeforeRedirect,
      beforeRedirects: {}
    };
    config.socketPath ? options.socketPath = config.socketPath : (options.hostname = parsed.hostname, options.port = parsed.port, setProxy(options, config.proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path));
    let transport, isHttpsRequest = isHttps.test(options.protocol);
    if (options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent, config.transport ? transport = config.transport : config.maxRedirects === 0 ? transport = isHttpsRequest ? import_https.default : import_http.default : (config.maxRedirects && (options.maxRedirects = config.maxRedirects), config.beforeRedirect && (options.beforeRedirects.config = config.beforeRedirect), transport = isHttpsRequest ? httpsFollow : httpFollow), config.maxBodyLength > -1 ? options.maxBodyLength = config.maxBodyLength : options.maxBodyLength = 1 / 0, config.insecureHTTPParser && (options.insecureHTTPParser = config.insecureHTTPParser), req = transport.request(options, function(res) {
      if (req.destroyed)
        return;
      let streams = [res], responseLength = +res.headers["content-length"];
      if (onDownloadProgress) {
        let transformStream = new AxiosTransformStream_default({
          length: utils_default.toFiniteNumber(responseLength),
          maxRate: utils_default.toFiniteNumber(maxDownloadRate)
        });
        onDownloadProgress && transformStream.on("progress", (progress) => {
          onDownloadProgress(Object.assign(progress, {
            download: !0
          }));
        }), streams.push(transformStream);
      }
      let responseStream = res, lastRequest = res.req || req;
      if (config.decompress !== !1 && res.headers["content-encoding"])
        switch ((method === "HEAD" || res.statusCode === 204) && delete res.headers["content-encoding"], res.headers["content-encoding"]) {
          case "gzip":
          case "x-gzip":
          case "compress":
          case "x-compress":
            streams.push(import_zlib.default.createUnzip(zlibOptions)), delete res.headers["content-encoding"];
            break;
          case "deflate":
            streams.push(new ZlibHeaderTransformStream_default()), streams.push(import_zlib.default.createUnzip(zlibOptions)), delete res.headers["content-encoding"];
            break;
          case "br":
            isBrotliSupported && (streams.push(import_zlib.default.createBrotliDecompress(brotliOptions)), delete res.headers["content-encoding"]);
        }
      responseStream = streams.length > 1 ? import_stream5.default.pipeline(streams, utils_default.noop) : streams[0];
      let offListeners = import_stream5.default.finished(responseStream, () => {
        offListeners(), onFinished();
      }), response = {
        status: res.statusCode,
        statusText: res.statusMessage,
        headers: new AxiosHeaders_default(res.headers),
        config,
        request: lastRequest
      };
      if (responseType === "stream")
        response.data = responseStream, settle(resolve, reject, response);
      else {
        let responseBuffer = [], totalResponseBytes = 0;
        responseStream.on("data", function(chunk) {
          responseBuffer.push(chunk), totalResponseBytes += chunk.length, config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength && (rejected = !0, responseStream.destroy(), reject(new AxiosError_default(
            "maxContentLength size of " + config.maxContentLength + " exceeded",
            AxiosError_default.ERR_BAD_RESPONSE,
            config,
            lastRequest
          )));
        }), responseStream.on("aborted", function() {
          if (rejected)
            return;
          let err = new AxiosError_default(
            "maxContentLength size of " + config.maxContentLength + " exceeded",
            AxiosError_default.ERR_BAD_RESPONSE,
            config,
            lastRequest
          );
          responseStream.destroy(err), reject(err);
        }), responseStream.on("error", function(err) {
          req.destroyed || reject(AxiosError_default.from(err, null, config, lastRequest));
        }), responseStream.on("end", function() {
          try {
            let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
            responseType !== "arraybuffer" && (responseData = responseData.toString(responseEncoding), (!responseEncoding || responseEncoding === "utf8") && (responseData = utils_default.stripBOM(responseData))), response.data = responseData;
          } catch (err) {
            reject(AxiosError_default.from(err, null, config, response.request, response));
          }
          settle(resolve, reject, response);
        });
      }
      emitter.once("abort", (err) => {
        responseStream.destroyed || (responseStream.emit("error", err), responseStream.destroy());
      });
    }), emitter.once("abort", (err) => {
      reject(err), req.destroy(err);
    }), req.on("error", function(err) {
      reject(AxiosError_default.from(err, null, config, req));
    }), req.on("socket", function(socket) {
      socket.setKeepAlive(!0, 1e3 * 60);
    }), config.timeout) {
      let timeout = parseInt(config.timeout, 10);
      if (isNaN(timeout)) {
        reject(new AxiosError_default(
          "error trying to parse `config.timeout` to int",
          AxiosError_default.ERR_BAD_OPTION_VALUE,
          config,
          req
        ));
        return;
      }
      req.setTimeout(timeout, function() {
        if (isDone)
          return;
        let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded", transitional2 = config.transitional || transitional_default;
        config.timeoutErrorMessage && (timeoutErrorMessage = config.timeoutErrorMessage), reject(new AxiosError_default(
          timeoutErrorMessage,
          transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
          config,
          req
        )), abort();
      });
    }
    if (utils_default.isStream(data)) {
      let ended = !1, errored = !1;
      data.on("end", () => {
        ended = !0;
      }), data.once("error", (err) => {
        errored = !0, req.destroy(err);
      }), data.on("close", () => {
        !ended && !errored && abort(new CanceledError_default("Request stream has been aborted", config, req));
      }), data.pipe(req);
    } else
      req.end(data);
  });
};

// node_modules/axios/lib/helpers/cookies.js
var cookies_default = node_default.isStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  function() {
    return {
      write: function(name, value, expires, path, domain, secure) {
        let cookie = [];
        cookie.push(name + "=" + encodeURIComponent(value)), utils_default.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString()), utils_default.isString(path) && cookie.push("path=" + path), utils_default.isString(domain) && cookie.push("domain=" + domain), secure === !0 && cookie.push("secure"), document.cookie = cookie.join("; ");
      },
      read: function(name) {
        let match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
        return match ? decodeURIComponent(match[3]) : null;
      },
      remove: function(name) {
        this.write(name, "", Date.now() - 864e5);
      }
    };
  }()
) : (
  // Non standard browser env (web workers, react-native) lack needed support.
  function() {
    return {
      write: function() {
      },
      read: function() {
        return null;
      },
      remove: function() {
      }
    };
  }()
);

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var isURLSameOrigin_default = node_default.isStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function() {
    let msie = /(msie|trident)/i.test(navigator.userAgent), urlParsingNode = document.createElement("a"), originURL;
    function resolveURL(url2) {
      let href = url2;
      return msie && (urlParsingNode.setAttribute("href", href), href = urlParsingNode.href), urlParsingNode.setAttribute("href", href), {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    return originURL = resolveURL(window.location.href), function(requestURL) {
      let parsed = utils_default.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  function() {
    return function() {
      return !0;
    };
  }()
);

// node_modules/axios/lib/adapters/xhr.js
function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0, _speedometer = speedometer_default(50, 250);
  return (e) => {
    let loaded = e.loaded, total = e.lengthComputable ? e.total : void 0, progressBytes = loaded - bytesNotified, rate = _speedometer(progressBytes), inRange = loaded <= total;
    bytesNotified = loaded;
    let data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate || void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e
    };
    data[isDownloadStream ? "download" : "upload"] = !0, listener(data);
  };
}
var isXHRAdapterSupported = typeof XMLHttpRequest < "u", xhr_default = isXHRAdapterSupported && function(config) {
  return new Promise(function(resolve, reject) {
    let requestData = config.data, requestHeaders = AxiosHeaders_default.from(config.headers).normalize(), responseType = config.responseType, onCanceled;
    function done() {
      config.cancelToken && config.cancelToken.unsubscribe(onCanceled), config.signal && config.signal.removeEventListener("abort", onCanceled);
    }
    utils_default.isFormData(requestData) && (node_default.isStandardBrowserEnv || node_default.isStandardBrowserWebWorkerEnv ? requestHeaders.setContentType(!1) : requestHeaders.setContentType("multipart/form-data;", !1));
    let request = new XMLHttpRequest();
    if (config.auth) {
      let username = config.auth.username || "", password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
      requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
    }
    let fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), !0), request.timeout = config.timeout;
    function onloadend() {
      if (!request)
        return;
      let responseHeaders = AxiosHeaders_default.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      ), response = {
        data: !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function(value) {
        resolve(value), done();
      }, function(err) {
        reject(err), done();
      }, response), request = null;
    }
    if ("onloadend" in request ? request.onloadend = onloadend : request.onreadystatechange = function() {
      !request || request.readyState !== 4 || request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0) || setTimeout(onloadend);
    }, request.onabort = function() {
      request && (reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config, request)), request = null);
    }, request.onerror = function() {
      reject(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request)), request = null;
    }, request.ontimeout = function() {
      let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded", transitional2 = config.transitional || transitional_default;
      config.timeoutErrorMessage && (timeoutErrorMessage = config.timeoutErrorMessage), reject(new AxiosError_default(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
        config,
        request
      )), request = null;
    }, node_default.isStandardBrowserEnv) {
      let xsrfValue = (config.withCredentials || isURLSameOrigin_default(fullPath)) && config.xsrfCookieName && cookies_default.read(config.xsrfCookieName);
      xsrfValue && requestHeaders.set(config.xsrfHeaderName, xsrfValue);
    }
    requestData === void 0 && requestHeaders.setContentType(null), "setRequestHeader" in request && utils_default.forEach(requestHeaders.toJSON(), function(val, key) {
      request.setRequestHeader(key, val);
    }), utils_default.isUndefined(config.withCredentials) || (request.withCredentials = !!config.withCredentials), responseType && responseType !== "json" && (request.responseType = config.responseType), typeof config.onDownloadProgress == "function" && request.addEventListener("progress", progressEventReducer(config.onDownloadProgress, !0)), typeof config.onUploadProgress == "function" && request.upload && request.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress)), (config.cancelToken || config.signal) && (onCanceled = (cancel) => {
      request && (reject(!cancel || cancel.type ? new CanceledError_default(null, config, request) : cancel), request.abort(), request = null);
    }, config.cancelToken && config.cancelToken.subscribe(onCanceled), config.signal && (config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled)));
    let protocol = parseProtocol(fullPath);
    if (protocol && node_default.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};

// node_modules/axios/lib/adapters/adapters.js
var knownAdapters = {
  http: http_default,
  xhr: xhr_default
};
utils_default.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
var adapters_default = {
  getAdapter: (adapters) => {
    adapters = utils_default.isArray(adapters) ? adapters : [adapters];
    let { length } = adapters, nameOrAdapter, adapter;
    for (let i = 0; i < length && (nameOrAdapter = adapters[i], !(adapter = utils_default.isString(nameOrAdapter) ? knownAdapters[nameOrAdapter.toLowerCase()] : nameOrAdapter)); i++)
      ;
    if (!adapter)
      throw adapter === !1 ? new AxiosError_default(
        `Adapter ${nameOrAdapter} is not supported by the environment`,
        "ERR_NOT_SUPPORT"
      ) : new Error(
        utils_default.hasOwnProp(knownAdapters, nameOrAdapter) ? `Adapter '${nameOrAdapter}' is not available in the build` : `Unknown adapter '${nameOrAdapter}'`
      );
    if (!utils_default.isFunction(adapter))
      throw new TypeError("adapter is not a function");
    return adapter;
  },
  adapters: knownAdapters
};

// node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config) {
  if (config.cancelToken && config.cancelToken.throwIfRequested(), config.signal && config.signal.aborted)
    throw new CanceledError_default(null, config);
}
function dispatchRequest(config) {
  return throwIfCancellationRequested(config), config.headers = AxiosHeaders_default.from(config.headers), config.data = transformData.call(
    config,
    config.transformRequest
  ), ["post", "put", "patch"].indexOf(config.method) !== -1 && config.headers.setContentType("application/x-www-form-urlencoded", !1), adapters_default.getAdapter(config.adapter || defaults_default.adapter)(config).then(function(response) {
    return throwIfCancellationRequested(config), response.data = transformData.call(
      config,
      config.transformResponse,
      response
    ), response.headers = AxiosHeaders_default.from(response.headers), response;
  }, function(reason) {
    return isCancel(reason) || (throwIfCancellationRequested(config), reason && reason.response && (reason.response.data = transformData.call(
      config,
      config.transformResponse,
      reason.response
    ), reason.response.headers = AxiosHeaders_default.from(reason.response.headers))), Promise.reject(reason);
  });
}

// node_modules/axios/lib/core/mergeConfig.js
var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? thing.toJSON() : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  let config = {};
  function getMergedValue(target, source, caseless) {
    return utils_default.isPlainObject(target) && utils_default.isPlainObject(source) ? utils_default.merge.call({ caseless }, target, source) : utils_default.isPlainObject(source) ? utils_default.merge({}, source) : utils_default.isArray(source) ? source.slice() : source;
  }
  function mergeDeepProperties(a, b, caseless) {
    if (utils_default.isUndefined(b)) {
      if (!utils_default.isUndefined(a))
        return getMergedValue(void 0, a, caseless);
    } else
      return getMergedValue(a, b, caseless);
  }
  function valueFromConfig2(a, b) {
    if (!utils_default.isUndefined(b))
      return getMergedValue(void 0, b);
  }
  function defaultToConfig2(a, b) {
    if (utils_default.isUndefined(b)) {
      if (!utils_default.isUndefined(a))
        return getMergedValue(void 0, a);
    } else
      return getMergedValue(void 0, b);
  }
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2)
      return getMergedValue(a, b);
    if (prop in config1)
      return getMergedValue(void 0, a);
  }
  let mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), !0)
  };
  return utils_default.forEach(Object.keys(Object.assign({}, config1, config2)), function(prop) {
    let merge2 = mergeMap[prop] || mergeDeepProperties, configValue = merge2(config1[prop], config2[prop], prop);
    utils_default.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  }), config;
}

// node_modules/axios/lib/helpers/validator.js
var validators = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
  validators[type] = function(thing) {
    return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
validators.transitional = function(validator, version, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator === !1)
      throw new AxiosError_default(
        formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
        AxiosError_default.ERR_DEPRECATED
      );
    return version && !deprecatedWarnings[opt] && (deprecatedWarnings[opt] = !0, console.warn(
      formatMessage(
        opt,
        " has been deprecated since v" + version + " and will be removed in the near future"
      )
    )), validator ? validator(value, opt, opts) : !0;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options != "object")
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  let keys = Object.keys(options), i = keys.length;
  for (; i-- > 0; ) {
    let opt = keys[i], validator = schema[opt];
    if (validator) {
      let value = options[opt], result = value === void 0 || validator(value, opt, options);
      if (result !== !0)
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (allowUnknown !== !0)
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
  }
}
var validator_default = {
  assertOptions,
  validators
};

// node_modules/axios/lib/core/Axios.js
var validators2 = validator_default.validators, Axios = class {
  constructor(instanceConfig) {
    this.defaults = instanceConfig, this.interceptors = {
      request: new InterceptorManager_default(),
      response: new InterceptorManager_default()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(configOrUrl, config) {
    typeof configOrUrl == "string" ? (config = config || {}, config.url = configOrUrl) : config = configOrUrl || {}, config = mergeConfig(this.defaults, config);
    let { transitional: transitional2, paramsSerializer, headers } = config;
    transitional2 !== void 0 && validator_default.assertOptions(transitional2, {
      silentJSONParsing: validators2.transitional(validators2.boolean),
      forcedJSONParsing: validators2.transitional(validators2.boolean),
      clarifyTimeoutError: validators2.transitional(validators2.boolean)
    }, !1), paramsSerializer != null && (utils_default.isFunction(paramsSerializer) ? config.paramsSerializer = {
      serialize: paramsSerializer
    } : validator_default.assertOptions(paramsSerializer, {
      encode: validators2.function,
      serialize: validators2.function
    }, !0)), config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders;
    contextHeaders = headers && utils_default.merge(
      headers.common,
      headers[config.method]
    ), contextHeaders && utils_default.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    ), config.headers = AxiosHeaders_default.concat(contextHeaders, headers);
    let requestInterceptorChain = [], synchronousRequestInterceptors = !0;
    this.interceptors.request.forEach(function(interceptor) {
      typeof interceptor.runWhen == "function" && interceptor.runWhen(config) === !1 || (synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous, requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected));
    });
    let responseInterceptorChain = [];
    this.interceptors.response.forEach(function(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise, i = 0, len;
    if (!synchronousRequestInterceptors) {
      let chain = [dispatchRequest.bind(this), void 0];
      for (chain.unshift.apply(chain, requestInterceptorChain), chain.push.apply(chain, responseInterceptorChain), len = chain.length, promise = Promise.resolve(config); i < len; )
        promise = promise.then(chain[i++], chain[i++]);
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    for (i = 0; i < len; ) {
      let onFulfilled = requestInterceptorChain[i++], onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    for (i = 0, len = responseInterceptorChain.length; i < len; )
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    let fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
};
utils_default.forEach(["delete", "get", "head", "options"], function(method) {
  Axios.prototype[method] = function(url2, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url: url2,
      data: (config || {}).data
    }));
  };
});
utils_default.forEach(["post", "put", "patch"], function(method) {
  function generateHTTPMethod(isForm) {
    return function(url2, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: url2,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod(), Axios.prototype[method + "Form"] = generateHTTPMethod(!0);
});
var Axios_default = Axios;

// node_modules/axios/lib/cancel/CancelToken.js
var CancelToken = class {
  constructor(executor) {
    if (typeof executor != "function")
      throw new TypeError("executor must be a function.");
    let resolvePromise;
    this.promise = new Promise(function(resolve) {
      resolvePromise = resolve;
    });
    let token = this;
    this.promise.then((cancel) => {
      if (!token._listeners)
        return;
      let i = token._listeners.length;
      for (; i-- > 0; )
        token._listeners[i](cancel);
      token._listeners = null;
    }), this.promise.then = (onfulfilled) => {
      let _resolve, promise = new Promise((resolve) => {
        token.subscribe(resolve), _resolve = resolve;
      }).then(onfulfilled);
      return promise.cancel = function() {
        token.unsubscribe(_resolve);
      }, promise;
    }, executor(function(message, config, request) {
      token.reason || (token.reason = new CanceledError_default(message, config, request), resolvePromise(token.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(listener) : this._listeners = [listener];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners)
      return;
    let index = this._listeners.indexOf(listener);
    index !== -1 && this._listeners.splice(index, 1);
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    return {
      token: new CancelToken(function(c) {
        cancel = c;
      }),
      cancel
    };
  }
}, CancelToken_default = CancelToken;

// node_modules/axios/lib/helpers/spread.js
function spread(callback) {
  return function(arr) {
    return callback.apply(null, arr);
  };
}

// node_modules/axios/lib/helpers/isAxiosError.js
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === !0;
}

// node_modules/axios/lib/helpers/HttpStatusCode.js
var HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
var HttpStatusCode_default = HttpStatusCode;

// node_modules/axios/lib/axios.js
function createInstance(defaultConfig) {
  let context = new Axios_default(defaultConfig), instance = bind(Axios_default.prototype.request, context);
  return utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: !0 }), utils_default.extend(instance, context, null, { allOwnKeys: !0 }), instance.create = function(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  }, instance;
}
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;

// node_modules/axios/index.js
var {
  Axios: Axios2,
  AxiosError: AxiosError2,
  CanceledError: CanceledError2,
  isCancel: isCancel2,
  CancelToken: CancelToken2,
  VERSION: VERSION2,
  all: all2,
  Cancel,
  isAxiosError: isAxiosError2,
  spread: spread2,
  toFormData: toFormData2,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode: HttpStatusCode2,
  formToJSON,
  mergeConfig: mergeConfig2
} = axios_default;

// app/services/productService.js
var serverUrl = "https://mocki.io/v1/", getProductsListRequest = (url2) => new Promise(function(resolve, reject) {
  axios_default.get(
    url2
  ).then(function(result) {
    resolve(result);
  }, function(error) {
    reject(error.response);
  });
}), getProductByIdRequest = (productId) => new Promise(function(resolve, reject) {
  axios_default.get(
    serverUrl + "1a1fb542-22d1-4919-914a-750114879775?code=" + productId
  ).then(function(result) {
    resolve(result.data);
  }, function(error) {
    reject(error.response);
  });
});

// app/controllers/productController.js
var getProductsList = (url2) => new Promise((resolve, reject) => {
  getProductsListRequest(url2).then((result) => {
    resolve(result.data.result);
  }, (error) => {
    reject([]);
  });
}), getProductById = (productId) => new Promise((resolve, reject) => {
  getProductByIdRequest(productId).then((result) => {
    resolve(result);
  }, (error) => {
    reject([]);
  });
}), ProductController = {
  getProductsList,
  getProductById
}, productController_default = ProductController;

// app/routes/products.$productId.jsx
var import_jsx_runtime7 = __toESM(require_jsx_runtime());
function Product() {
  let loaderData = (0, import_react5.useLoaderData)();
  return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(import_jsx_runtime7.Fragment, { children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(ProductDetail_default, { product: loaderData }) });
}
var loader = ({ params }) => new Promise((resolve, reject) => {
  productController_default.getProductById(params.productId).then((product) => {
    resolve(product.result);
  }).catch(() => {
    reject(null);
  });
});

// app/routes/_index.jsx
var index_exports = {};
__export(index_exports, {
  default: () => Index,
  loader: () => loader2
});
var import_react10 = __toESM(require_dist3());

// app/components/productPage/listPage/HorizontalProductList.jsx
var import_react7 = __toESM(require_dist3());

// app/components/common/Slider.jsx
var import_react6 = __toESM(require_react());

// app/components/common/CardView.jsx
var import_jsx_runtime8 = __toESM(require_jsx_runtime()), CardView = ({ product, onClickCallback }) => /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "card card-view h-100 w-100", onClick: () => onClickCallback(product), children: [
  /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "p-3 d-flex justify-content-center", children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
    "img",
    {
      src: product.imageUrl,
      className: "img-fluid",
      alt: "product"
    }
  ) }),
  /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { className: "card-body", children: [
    /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "d-flex justify-content-start", children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { className: "my-auto product-name-label", children: product.name }) }),
    /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("hr", { className: "my-3" }),
    /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { className: "d-flex justify-content-between", children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { className: "price-label", children: buildPriceLabel(product.price) }) }),
    /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { className: "small text-muted", children: product.followCount ? product.followCount + " " + uiConstants_default.MAIN_PAGE.FOLLOWERS : null })
  ] })
] }), CardView_default = CardView;

// app/components/common/Slider.jsx
var import_jsx_runtime9 = __toESM(require_jsx_runtime()), Slider = ({ products, onClickCallback }) => {
  let [currentIndex, setCurrentIndex] = (0, import_react6.useState)(0), handlePrev = () => {
    setCurrentIndex(
      (prevIndex) => prevIndex === 0 ? products.length - 1 : prevIndex - 1
    );
  }, handleNext = () => {
    setCurrentIndex(
      (prevIndex) => prevIndex === products.length - 1 ? 0 : prevIndex + 1
    );
  }, handleDotClick = (index) => {
    setCurrentIndex(index);
  };
  return /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "h-100", children: [
    /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "slider d-flex justify-content-center h-100 w-100", children: [
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "slider-controls", children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("button", { className: "direction-button", onClick: handlePrev, children: "<" }) }),
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "slider-inner d-flex", children: products.slice(currentIndex, currentIndex + 1).map((product, index) => /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "col-6 px-4", children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(CardView_default, { product, onClickCallback }) }, index)) }),
      /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "slider-controls", children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("button", { className: "direction-button", onClick: handleNext, children: ">" }) })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "slider-dots", children: products.map((_, index) => /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
      "span",
      {
        className: `slider-dot ${index === currentIndex ? "active" : ""}`,
        onClick: () => handleDotClick(index)
      },
      index
    )) })
  ] });
}, Slider_default = Slider;

// app/components/productPage/listPage/HorizontalProductList.jsx
var import_jsx_runtime10 = __toESM(require_jsx_runtime()), HorizontalProductList = ({ products }) => {
  let navigate = (0, import_react7.useNavigate)(), onClickProduct = (product) => {
    navigate(`/products/${product.code}`);
  };
  return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("div", { className: "horizontal-products", children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(Slider_default, { products, onClickCallback: (product) => {
    onClickProduct(product);
  } }) });
}, HorizontalProductList_default = HorizontalProductList;

// app/components/productPage/listPage/VerticalProductList.jsx
var import_react8 = __toESM(require_dist3()), import_react9 = __toESM(require_react());

// app/components/common/PaginationButtons.jsx
var import_jsx_runtime11 = __toESM(require_jsx_runtime()), PaginationButtons = ({
  isPrevDisabled,
  isNextDisabled,
  onPreviousPageClickCallback,
  onNextPageClickCallback
}) => /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)("div", { className: "d-flex justify-content-center m-auto pagination", children: [
  /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
    "button",
    {
      className: "direction-button px-3",
      disabled: isPrevDisabled,
      onClick: onPreviousPageClickCallback,
      children: "<"
    }
  ),
  /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
    "button",
    {
      className: "direction-button px-3",
      disabled: isNextDisabled,
      onClick: onNextPageClickCallback,
      children: ">"
    }
  )
] }), PaginationButtons_default = PaginationButtons;

// app/utils/models/productPage.js
var ProductPageModel = ({
  pageNumber = "",
  productList = []
}) => ({
  pageNumber,
  productList
});

// app/components/productPage/listPage/VerticalProductList.jsx
var import_jsx_runtime12 = __toESM(require_jsx_runtime()), VerticalProductList = ({ result }) => {
  let [nextPage, setNextPage] = (0, import_react9.useState)(result.nextUrl), [cachedProducts, setCachedProducts] = (0, import_react9.useState)([]), [currentPage, setCurrentPage] = (0, import_react9.useState)(1), navigate = (0, import_react8.useNavigate)(), [productPerPage, setProductPerPage] = (0, import_react9.useState)(result.products);
  (0, import_react9.useEffect)(() => {
    setCachedProducts([...cachedProducts, ProductPageModel({ pageNumber: currentPage, productList: productPerPage })]);
  }, []);
  let onClickProduct = (product) => {
    navigate(`/products/${product.code}`);
  }, onPreviousPageClick = () => {
    setCurrentPage(currentPage - 1), setProductPerPage(cachedProducts.find((productDetail) => productDetail.pageNumber === currentPage - 1).productList);
  }, onNextPageClick = () => {
    let cachedData = cachedProducts.find((productDetail) => productDetail.pageNumber === currentPage + 1);
    cachedData ? (setCurrentPage(currentPage + 1), setProductPerPage(cachedData.productList)) : productController_default.getProductsList(nextPage).then((result2) => {
      setNextPage(result2.nextPage), setProductPerPage(result2.products), setCurrentPage(currentPage + 1), setCachedProducts([...cachedProducts, ProductPageModel({ pageNumber: currentPage + 1, productList: result2.products })]);
    });
  };
  return /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)("div", { className: "vertical-products", children: [
    /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("div", { className: "row col-6 m-auto", children: productPerPage.map((product, index) => /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("div", { className: "col-6 p-4", children: /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(
      CardView_default,
      {
        product,
        onClickCallback: (product2) => {
          onClickProduct(product2);
        }
      }
    ) }, index)) }),
    /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(
      PaginationButtons_default,
      {
        isNextDisabled: !nextPage && currentPage === cachedProducts.length,
        isPrevDisabled: currentPage === 1,
        onPreviousPageClickCallback: () => {
          onPreviousPageClick();
        },
        onNextPageClickCallback: () => {
          onNextPageClick();
        }
      }
    )
  ] });
}, VerticalProductList_default = VerticalProductList;

// app/components/productPage/listPage/ProductList.jsx
var import_jsx_runtime13 = __toESM(require_jsx_runtime()), ProductList = ({ result }) => /* @__PURE__ */ (0, import_jsx_runtime13.jsxs)("div", { className: "app", children: [
  /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(HorizontalProductList_default, { products: result.horizontalProducts }),
  /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(VerticalProductList_default, { result })
] }), ProductList_default = ProductList;

// app/routes/_index.jsx
var import_jsx_runtime14 = __toESM(require_jsx_runtime()), initialApiUrl = "https://mocki.io/v1/59906f35-d5d5-40f7-8d44-53fd26eb3a05";
function Index() {
  let result = (0, import_react10.useLoaderData)();
  return /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(import_jsx_runtime14.Fragment, { children: /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(ProductList_default, { result }) });
}
var loader2 = () => new Promise((resolve, reject) => {
  productController_default.getProductsList(initialApiUrl).then((result) => {
    resolve(result);
  }).catch(() => {
    reject(null);
  });
});

// server-assets-manifest:@remix-run/dev/assets-manifest
var assets_manifest_default = { entry: { module: "/build/entry.client-LFQKVX6D.js", imports: ["/build/_shared/chunk-PZ3YZIJT.js"] }, routes: { root: { id: "root", parentId: void 0, path: "", index: void 0, caseSensitive: void 0, module: "/build/root-OGWN4ICZ.js", imports: ["/build/_shared/chunk-6GHL46BL.js"], hasAction: !1, hasLoader: !1, hasCatchBoundary: !0, hasErrorBoundary: !1 }, "routes/_index": { id: "routes/_index", parentId: "root", path: void 0, index: !0, caseSensitive: void 0, module: "/build/routes/_index-XIJOPNJA.js", imports: ["/build/_shared/chunk-DPIC6ZBA.js"], hasAction: !1, hasLoader: !0, hasCatchBoundary: !1, hasErrorBoundary: !1 }, "routes/products.$productId": { id: "routes/products.$productId", parentId: "root", path: "products/:productId", index: void 0, caseSensitive: void 0, module: "/build/routes/products.$productId-52GEZMEC.js", imports: ["/build/_shared/chunk-DPIC6ZBA.js"], hasAction: !1, hasLoader: !0, hasCatchBoundary: !1, hasErrorBoundary: !1 } }, cssBundleHref: void 0, version: "a4e7900c", hmr: void 0, url: "/build/manifest-A4E7900C.js" };

// server-entry-module:@remix-run/dev/server-build
var assetsBuildDirectory = "public/build", future = { unstable_dev: !1, unstable_postcss: !1, unstable_tailwind: !1, v2_errorBoundary: !1, v2_meta: !1, v2_normalizeFormMethod: !1, v2_routeConvention: !0 }, publicPath = "/build/", entry = { module: entry_server_react_stream_exports }, routes = {
  root: {
    id: "root",
    parentId: void 0,
    path: "",
    index: void 0,
    caseSensitive: void 0,
    module: root_exports
  },
  "routes/products.$productId": {
    id: "routes/products.$productId",
    parentId: "root",
    path: "products/:productId",
    index: void 0,
    caseSensitive: void 0,
    module: products_productId_exports
  },
  "routes/_index": {
    id: "routes/_index",
    parentId: "root",
    path: void 0,
    index: !0,
    caseSensitive: void 0,
    module: index_exports
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  assets,
  assetsBuildDirectory,
  entry,
  future,
  publicPath,
  routes
});
/*! Bundled license information:

@remix-run/node/dist/fetch.js:
  (**
   * @remix-run/node v1.16.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/node/dist/base64.js:
  (**
   * @remix-run/node v1.16.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/node/dist/globals.js:
  (**
   * @remix-run/node v1.16.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

cookie/index.js:
  (*!
   * cookie
   * Copyright(c) 2012-2014 Roman Shtylman
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

@remix-run/server-runtime/dist/warnings.js:
  (**
   * @remix-run/server-runtime v1.16.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/cookies.js:
  (**
   * @remix-run/server-runtime v1.16.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/formData.js:
  (**
   * @remix-run/server-runtime v1.16.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/router/dist/router.cjs.js:
  (**
   * @remix-run/router v1.6.2
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/mode.js:
  (**
   * @remix-run/server-runtime v1.16.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/errors.js:
  (**
   * @remix-run/server-runtime v1.16.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/responses.js:
  (**
   * @remix-run/server-runtime v1.16.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/entry.js:
  (**
   * @remix-run/server-runtime v1.16.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/headers.js:
  (**
   * @remix-run/server-runtime v1.16.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/invariant.js:
  (**
   * @remix-run/server-runtime v1.16.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/routeMatching.js:
  (**
   * @remix-run/server-runtime v1.16.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/data.js:
  (**
   * @remix-run/server-runtime v1.16.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/routes.js:
  (**
   * @remix-run/server-runtime v1.16.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/markup.js:
  (**
   * @remix-run/server-runtime v1.16.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/serverHandoff.js:
  (**
   * @remix-run/server-runtime v1.16.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/server.js:
  (**
   * @remix-run/server-runtime v1.16.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/sessions.js:
  (**
   * @remix-run/server-runtime v1.16.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/sessions/cookieStorage.js:
  (**
   * @remix-run/server-runtime v1.16.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/sessions/memoryStorage.js:
  (**
   * @remix-run/server-runtime v1.16.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/upload/errors.js:
  (**
   * @remix-run/server-runtime v1.16.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/upload/memoryUploadHandler.js:
  (**
   * @remix-run/server-runtime v1.16.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/dev.js:
  (**
   * @remix-run/server-runtime v1.16.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/server-runtime/dist/index.js:
  (**
   * @remix-run/server-runtime v1.16.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/node/dist/crypto.js:
  (**
   * @remix-run/node v1.16.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/node/dist/implementations.js:
  (**
   * @remix-run/node v1.16.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/node/dist/sessions/fileStorage.js:
  (**
   * @remix-run/node v1.16.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/node/dist/stream.js:
  (**
   * @remix-run/node v1.16.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/node/dist/upload/fileUploadHandler.js:
  (**
   * @remix-run/node v1.16.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/node/dist/index.js:
  (**
   * @remix-run/node v1.16.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

react/cjs/react.production.min.js:
  (**
   * @license React
   * react.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-router/dist/umd/react-router.production.min.js:
  (**
   * React Router v6.11.2
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

react-router/dist/main.js:
  (**
   * React Router v6.11.2
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

react-router-dom/dist/umd/react-router-dom.production.min.js:
  (**
   * React Router DOM v6.11.2
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

react-router-dom/dist/main.js:
  (**
   * React Router DOM v6.11.2
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/_virtual/_rollupPluginBabelHelpers.js:
  (**
   * @remix-run/react v1.16.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/errorBoundaries.js:
  (**
   * @remix-run/react v1.16.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/invariant.js:
  (**
   * @remix-run/react v1.16.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/routeModules.js:
  (**
   * @remix-run/react v1.16.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/links.js:
  (**
   * @remix-run/react v1.16.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/markup.js:
  (**
   * @remix-run/react v1.16.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/transition.js:
  (**
   * @remix-run/react v1.16.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/warnings.js:
  (**
   * @remix-run/react v1.16.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/components.js:
  (**
   * @remix-run/react v1.16.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/errors.js:
  (**
   * @remix-run/react v1.16.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/data.js:
  (**
   * @remix-run/react v1.16.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/routes.js:
  (**
   * @remix-run/react v1.16.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/browser.js:
  (**
   * @remix-run/react v1.16.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/scroll-restoration.js:
  (**
   * @remix-run/react v1.16.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/server.js:
  (**
   * @remix-run/react v1.16.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@remix-run/react/dist/index.js:
  (**
   * @remix-run/react v1.16.1
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

react-dom/cjs/react-dom-server-legacy.node.production.min.js:
  (**
   * @license React
   * react-dom-server-legacy.node.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom-server.node.production.min.js:
  (**
   * @license React
   * react-dom-server.node.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-runtime.production.min.js:
  (**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)

react/cjs/react.production.min.js:
  (** @license React v16.14.0
   * react.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

classnames/index.js:
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)

mime-db/index.js:
  (*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

mime-types/index.js:
  (*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)
*/
